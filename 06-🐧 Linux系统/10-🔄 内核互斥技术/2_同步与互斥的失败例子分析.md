
在上一节中，我们了解了并发与竞争的基本概念。现在我们通过一个具体的失败例子来深刻理解为什么需要同步机制，以及不使用同步机制会发生什么严重后果。

## 1 经典的失败例子

让我们看一个看似正确，实际上存在严重问题的驱动程序代码：

```c
static int valid = 1;

static ssize_t gpio_key_drv_open (struct inode *node, struct file *file){
     if (!valid){
			 return -EBUSY;
     }else{
             valid = 0;
     }

     return 0; //成功
}

static int gpio_key_drv_close (struct inode *node, struct file *file){
     valid = 1;
     return 0;
}
```

这段代码的设计意图是通过全局变量`valid`来确保设备只能被一个进程打开，实现互斥访问

> [!note]+ 代码逻辑说明
> 
> 1. `valid = 1`表示设备可用
> 2. 当有程序打开设备时，先检查`valid`是否为1
> 3. 如果为1，则设置`valid = 0`，表示设备已被占用
> 4. 如果为0，则返回`-EBUSY`，表示设备忙

## 2 问题分析：竞争条件的出现

表面上看，这个逻辑很完美。但在多任务系统中，这段代码存在严重的**竞争条件**问题。

### 2.1 问题场景重现

让我们看看问题是如何发生的：

> [!warning]+ 关键问题
> 
> 在检查`valid`和设置`valid = 0`之间，程序可能被其他进程抢占！

具体的问题场景：
1. **程序A**先发现`valid = 1`，执行到第7行准备设置`valid = 0`
2. 此时**程序A**被优先级更高的**程序B**抢占了CPU
3. **程序B**调用`gpio_key_drv_open`时，发现`valid`仍然等于1，所以成功返回0
4. **程序B**将`valid`设置为0
5. 当**程序A**重新获得CPU时，它继续执行第11行，也将`valid`设置为0
6. 结果：程序A、B都成功打开了驱动程序，违背了互斥的设计目标

### 2.2 时序图分析

```txt
时间线：   程序A                    程序B
  |     执行第5行 if(!valid)
  |     发现valid=1，准备执行第11行
  |         ↓                    
  |     被抢占 ←────────────→   开始执行
  |                             发现valid=1
  |                             设置valid=0，成功返回
  |     重新获得CPU                ↓
  |     执行第11行: valid=0
  |     成功返回
  ↓
```

> [!danger]+ 严重后果
> 
> 两个程序都成功打开了设备，可能导致：
> 
> - 数据冲突和丢失
> - 硬件状态异常
> - 系统不稳定甚至崩溃

## 3 问题的本质分析

### 3.1 非原子性操作

这个问题的根本原因是**检查和设置操作不是原子性的**。

换句话说，从检查`valid`的值到设置`valid = 0`这个过程中，程序可能被打断，导致操作不完整。

```c
// 这不是一个原子操作，而是两个分离的操作：
if (!valid)     // 操作1：检查
{
    valid = 0;  // 操作2：设置  
}
```

### 3.2 临界区未保护

在并发编程中，访问共享资源`valid`的代码段被称为**临界区**。这个临界区没有任何保护机制，多个执行单元可以同时进入，导致竞争条件。

## 4 内核抢占的概念

在分析这个问题时，我们需要理解一个重要概念：**内核抢占**(preempt)。

> [!info]+ 内核抢占解释
> 
> 在内核态，程序A不是主动去休眠、主动放弃CPU资源；而是被优先级更高的程序B抢占了，这种行为被称为"preempt"(抢占)。

- **被动性**：程序没有主动放弃CPU，而是被强制切换
- **不可预测性**：抢占可能在任何时刻发生
- **原子性破坏**：抢占会破坏看似完整的操作序列

## 5 解决方案预览

既然我们已经看到了问题，那么如何解决呢？在后续的章节中，我们将学习多种同步机制：
1. **原子操作**：适合简单的计算处理，但不适合复杂的判断逻辑
2. **信号量**：若信号量等于1（等同于互斥锁），适合可睡眠的场景
3. **互斥锁**：临界区任务少，可以睡眠的场景
4. **自旋锁**：临界区很短，不能睡眠的场景
5. **中断屏蔽**：需要防止中断干扰的场景
6. **读写锁**：读多写少的场景

> [!tip]+ 选择建议
> 
> 对于上面的例子，我们可以使用原子操作、互斥锁或者信号量来解决。具体选择哪种机制，需要根据实际的使用场景来决定

## 6 总结

通过这个失败的例子，我们深刻理解了为什么需要同步机制：
1. **竞争条件**是多任务系统中的常见问题
2. **看似简单的检查-设置操作**实际上不是原子的
3. **内核抢占**会在任意时刻发生，破坏操作的完整性
4. **不使用同步机制**可能导致严重的系统问题

编写驱动程序时，必须有系统性的思维，时刻考虑到程序可能被其他进程或中断打断的情况。

在下一节中，我们将学习最基础的同步机制——原子操作，看看如何正确地处理这类问题。
