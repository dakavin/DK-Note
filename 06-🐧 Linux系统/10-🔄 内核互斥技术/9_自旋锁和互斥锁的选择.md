
在前面的章节中，我们分别学习了自旋锁和互斥锁两种重要的同步机制。现在面临一个实际问题：**在什么情况下选择哪种锁？** 这是驱动开发中经常遇到的决策问题。

## 1 两种锁机制的根本差异

当已经有一个线程加锁后，其他线程加锁失败的处理方式是两者的**根本区别**：
- **互斥锁**：加锁失败后，线程会释放CPU，给其他线程
- **自旋锁**：加锁失败后，线程会忙等待，直到它拿到锁

> [!note]+ 形象比喻
> 
> **互斥锁就像排队买票**：发现窗口忙就找个地方坐下等待叫号
> 
> **自旋锁就像等红绿灯**：站在原地一直盯着信号灯，随时准备通行

## 2 互斥锁的特点分析

### 2.1 工作机制

互斥锁是一种**独占锁**。当线程A加锁成功后，互斥锁已经被线程A独占了，只要线程A没有释放锁，线程B加锁就会失败，于是就会释放CPU让给其他线程

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/d3a41bd6da46a1477984632810e4c20c.png)

### 2.2 性能开销分析

互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程。虽然简化了使用锁的难度，但存在一定的性能开销成本。

> [!warning]+ 上下文切换开销
> 
> 会有两次线程上下文切换的成本：
> 
> 1. 当线程加锁失败时，内核把线程状态从"运行"设置为"等待"，把CPU切换给其他线程
> 2. 当锁被释放时，"等待"状态的线程变为"就绪"，内核在合适时机把CPU切换给该线程

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/210656ee290f5fbfb594522fc791f895.png)

### 2.3 线程上下文切换的内容

当两个线程属于同一个进程时，因为虚拟内存是共享的，所以在切换时：
- **保持不动的资源**：虚拟内存等共享资源
- **需要切换的内容**：线程的私有数据、寄存器等不共享的数据

> [!info]+ 性能数据
> 
> 上下文切换的耗时大概在几十纳秒到几微秒之间。如果锁住的代码执行时间比较短，那可能上下文切换的时间都比锁住的代码执行时间还要长。

## 3 自旋锁的特点分析

### 3.1 工作机制

自旋锁通过CPU提供的**CAS函数**(Compare And Swap)，**在用户态完成加锁和解锁操作，不会主动产生线程上下文切换**，所以相比互斥锁来说会快一些，开销也小一些。

### 3.2 加锁过程

一般加锁过程包含两个步骤：
1. **查看锁的状态**：如果锁是空闲的，则执行第二步
2. **设置锁状态**：将锁设置为当前线程持有

CAS函数把这两个步骤合并成一条硬件级指令，形成**原子指令**，保证了这两个步骤的不可分割性。

### 3.3 忙等待机制

使用自旋锁时，当发生多线程竞争锁的情况，加锁失败的线程会**忙等待**，直到它拿到锁。

> [!tip]+ 实现细节
> 
> 忙等待可以用while循环实现，但最好使用CPU提供的PAUSE指令，因为可以减少循环等待时的耗电量。

### 3.4 适用环境

- **多核系统**：自旋锁在多核系统下一般不会主动产生线程切换
- **单核系统**：需要抢占式调度器，否则自旋线程永远不会放弃CPU

> [!warning]+ 单核系统注意事项
> 
> 在单CPU上，自旋锁无法使用，因为一个自旋的线程永远不会放弃CPU，必须要有抢占式调度器不断通过时钟中断切换线程。

## 4 性能对比与选择依据

### 4.1 执行时间是关键因素

> [!success]+ 核心原则
> 
> 如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁。

### 4.2 资源消耗对比

**互斥锁的资源消耗**：
- 主要开销：线程状态切换
- 适用场景：临界资源涉及多个函数的执行

**自旋锁的资源消耗**：
- 主要开销：CPU资源(但开销小)
- 适用场景：临界资源主要是变量操作

### 4.3 使用场景总结

|锁类型|临界区特点|CPU资源|适用场景|典型操作|
|---|---|---|---|---|
|互斥锁|执行时间长|释放CPU|复杂的业务逻辑|多个函数调用|
|自旋锁|执行时间短|占用CPU|简单的状态操作|变量读写|

## 5 实际应用指导

### 5.1 选择流程图

```txt
开始
  ↓
是否在中断上下文？
  ├─是→ 只能使用自旋锁
  └─否
    ↓
是否需要睡眠或长时间等待？
  ├─是→ 使用互斥锁/信号量
  └─否
    ↓
临界区是否很短（<100条指令）？
  ├─是→ 使用自旋锁
  └─否→ 使用互斥锁
    ↓
是否需要计数功能？
  ├─是→ 使用信号量
  └─否→ 使用互斥锁
```

### 5.2 具体选择建议

1. **临界区很短且不能睡眠**：使用自旋锁
    ```c
    spin_lock_irqsave(&lock, flags);
    // 几行简单的变量操作
    variable = new_value;
    spin_unlock_irqrestore(&lock, flags);
    ```

2. **临界区较长或可以睡眠**：使用互斥锁
    ```c
    mutex_lock(&mutex);
    // 复杂的业务逻辑，可能包含多个函数调用
    complex_function1();
    complex_function2();
    mutex_unlock(&mutex);
    ```

3. **中断处理函数中**：只能使用自旋锁
    ```c
    // 中断处理函数中不能睡眠，只能用自旋锁
    static irqreturn_t my_interrupt_handler(int irq, void *dev_id)
    {
        spin_lock(&lock);
        // 处理中断相关的临界区
        spin_unlock(&lock);
        return IRQ_HANDLED;
    }
    ```


## 6 常见的错误选择

### 6.1 错误案例1：在长时间操作中使用自旋锁

```c
// 错误：在长时间操作中使用自旋锁
spin_lock(&lock);
msleep(100);  // 睡眠100毫秒！
// 其他耗时操作
spin_unlock(&lock);
```

> [!danger]+ 问题分析
> 
> 这会导致其他CPU一直自旋等待100毫秒，浪费大量CPU资源。

### 6.2 错误案例2：在中断中使用互斥锁

```c
// 错误：在中断处理函数中使用互斥锁
static irqreturn_t my_interrupt_handler(int irq, void *dev_id)
{
    mutex_lock(&mutex);  // 错误！中断中不能睡眠
    // 处理逻辑
    mutex_unlock(&mutex);
    return IRQ_HANDLED;
}
```

> [!danger]+ 问题分析
> 
> 中断处理函数不能睡眠，但互斥锁可能导致睡眠，会引起系统崩溃。

## 7 性能优化建议

### 7.1 最小化临界区

无论选择哪种锁，都应该尽量减少临界区的大小：

```c
// 优化前：临界区过大
mutex_lock(&mutex);
prepare_data();        // 可以放到临界区外
critical_operation();  // 必须在临界区内
cleanup_data();        // 可以放到临界区外
mutex_unlock(&mutex);

// 优化后：最小化临界区
prepare_data();        // 移到临界区外
mutex_lock(&mutex);
critical_operation();  // 只保护必要的操作
mutex_unlock(&mutex);
cleanup_data();        // 移到临界区外
```

### 7.2 避免锁竞争

1. **读写分离**：考虑使用读写锁
2. **分段锁**：将一个大锁拆分成多个小锁
3. **无锁算法**：在某些场景下使用原子操作替代锁

## 8 总结

选择合适的锁机制是确保系统性能和正确性的关键：

### 8.1 决策要点

1. **临界区执行时间**：短用自旋锁，长用互斥锁
2. **执行上下文**：中断中只能用自旋锁
3. **是否允许睡眠**：可睡眠用互斥锁，不可睡眠用自旋锁
4. **资源争用程度**：高争用倾向于互斥锁，低争用倾向于自旋锁

### 8.2 记忆口诀

> [!tip]+ 选择口诀
> 
> - **短小精悍用自旋**：临界区短用自旋锁
> - **复杂耗时用互斥**：临界区长用互斥锁
> - **中断上下文自旋**：中断中只能用自旋锁
> - **可睡眠时用互斥**：允许睡眠就用互斥锁

正确选择锁机制不仅能保证程序的正确性，还能显著提升系统性能。在实际开发中，要根据具体场景的特点，选择最合适的同步机制。

在下一节中，我们将学习**读写锁**——一种专门针对读多写少场景优化的同步机制。
