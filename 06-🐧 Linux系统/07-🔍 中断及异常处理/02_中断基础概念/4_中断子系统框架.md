# 中断子系统框架

在学习了[4_中断控制器](../07-🔍%20中断及异常处理/02_中断基础概念/4_中断控制器.md)的基本概念后，我们对GIC有了初步认识。现在需要从更高的视角来理解整个**中断子系统框架**的组织结构。

简单来说，Linux中断子系统就像一座"四层大厦"，每一层都有明确的职责分工。从最底层的硬件信号，到最顶层的驱动程序，这个框架确保了中断处理的高效性和可移植性。

> [!note]+ 重要笔记
> 
> 理解中断子系统的分层架构，有助于我们在驱动开发中准确定位问题，并编写出高质量的中断处理代码。

## 1 中断子系统的四层架构

### 1.1 整体架构概览

一个完整的中断子系统框架可以分为四个层次，由上到下分别为**用户层、通用层、硬件相关层和硬件层**。这种分层设计的核心思想是实现硬件抽象和代码复用。

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/f283f44413998866941163494dab0058.png)

换句话说，就像盖房子一样，每一层都有自己的功能，上层不需要关心下层的具体实现细节，只需要通过标准接口进行交互。

### 1.2 各层详细功能

**用户层**：
- 中断的使用者，主要包括各类设备驱动
- 这些驱动程序通过中断相关的接口进行中断的申请和注册
- 当外设触发中断时，用户层驱动程序会进行相应的回调处理，执行特定的操作

> [!example]+ 示例
> 
> 网卡驱动程序就是典型的用户层，它注册网卡中断处理函数，当网卡接收到数据包时，通过中断通知驱动程序及时处理数据。

**通用层**：
- 也可称为框架层，它是硬件无关的层次
- 通用层的代码在所有硬件平台上都是通用的，不依赖于具体的硬件架构或中断控制器
- 通用层提供了统一的接口和功能，用于管理和处理中断，使得驱动程序能够在不同的硬件平台上复用

**硬件相关层**：包含两部分代码
- 一部分是与`特定处理器架构`相关的代码，比如ARM64处理器的中断处理相关代码。这些代码负责处理特定架构的中断机制，包括中断向量表、中断处理程序等。
- 另一部分是`中断控制器`的驱动代码，用于与中断控制器进行通信和配置。这些代码与具体的中断控制器硬件相关

**硬件层**：
- 硬件层位于最底层，与具体的硬件连接相关。
- 它包括外设与SoC（系统片上芯片）的物理连接部分。
- 中断信号从外设传递到中断控制器，由中断控制器统一管理和路由到处理器。

> [!tip]+ 重要提示
> 
> 这种分层设计的最大优势是**代码复用性**。比如，同一个网卡驱动程序可以在不同的ARM平台上运行，而不需要修改上层代码。

## 2 GIC中断控制器详解

### 2.1 GIC版本演进和特性

**中断控制器GIC**（Generic Interrupt Controller）是中断子系统框架硬件层中的一个关键组件，用于管理和控制中断。它接收来自各种中断源的中断请求，并根据预先配置的中断优先级、屏蔽和路由规则，将中断请求分发给适当的处理器核心或中断服务例程。

GIC是由ARM公司提出设计规范，当前有四个版本，GIC V1-v4。设计规范中最常用的，有3个版本V2.0、V3.1、V4.1，GICv3版本设计主要运行在Armv8-A, Armv9-A等架构上。

> [!note]+ 重要笔记
> 
> ARM公司并给出一个实际的控制器设计参考，比如GIC-400(支持GIC v2架构)、GIC-500(支持GIC v3架构)、GIC-600(支持GIC v3和GIC v4架构)。最终芯片厂商可以自己实现GIC或者直接购买ARM提供的设计。

每个GIC版本及相应特性如下表所示：

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/3485d6f70fd2f0e6997f91ab02fda5a6.png)
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/5e59c0ab41e48b420699f1725ab27ed6.png)

### 2.2 GICv3架构组成

在RK3568上使用的GIC版本为GICv3，相应的中断控制器模型如下所示：

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/665f4ff7f16be7ae7b8c2bb4ed579d81.png)

GIC中断控制器可以分为**Distributor接口、Redistributor接口和CPU接口**，下面详细介绍每个部分的功能：

#### 2.2.1 Distributor（中断仲裁器）

**Distributor**包含影响所有处理器核心中断的全局设置，它就像一个"中央调度员"，负责管理所有共享外设中断（`SPI`）

主要功能包括：
- **启用和禁用SPI**：控制哪些共享外设中断可以被处理
- **设置每个SPI的优先级级别**：决定中断的重要程度
- **每个SPI的路由信息**：确定中断应该发送给哪个处理器核心
- **将每个SPI设置为电平触发或边沿触发**：配置中断的触发方式
- **生成基于消息的SPI**：支持高级中断传递机制
- **控制SPI的活动和挂起状态**：管理中断的生命周期

#### 2.2.2 Redistributor（重新分配器）

对于每个连接的处理器核心（PE），都有一个重新分配器（Redistributor）。换句话说，每个CPU核心都有自己的"专属管家"。

**Redistributor**提供以下编程接口：
- **启用和禁用SGI和PPI**：管理软件中断和私有外设中断
- **设置SGI和PPI的优先级级别**：配置私有中断的优先级
- **将每个PPI设置为电平触发或边沿触发**：控制私有中断的触发方式
- **将每个SGI和PPI分配给一个中断组**：实现中断分组管理
- **控制SGI和PPI的状态**：管理私有中断的生命周期
- **支持与连接的处理器核心的电源管理**：配合CPU的电源状态

#### 2.2.3 CPU接口

每个重新分配器都连接到一个CPU接口。CPU接口就像处理器的"中断接收窗口"。

**CPU接口**提供以下编程接口：
- **通用控制和配置，用于启用中断处理**：控制中断处理的总开关
- **确认中断**：通知系统已经开始处理中断
- **执行中断的优先级降低和停用**：完成中断处理流程
- **为处理器核心设置中断优先级屏蔽**：过滤低优先级中断
- **定义处理器核心的抢占策略**：控制中断嵌套行为
- **确定处理器核心最高优先级的挂起中断**：选择最重要的待处理中断

> [!tip]+ 重要提示
> 
> GICv3相比GICv2的一个重要改进是引入了Redistributor，这使得每个CPU核心都有独立的私有中断管理能力，提高了多核系统的扩展性。

## 3 中断类型和状态管理

### 3.1 四种中断类型

GIC-V3支持四种类型的中断，分别是**SGI、PPI、SPI和LPI**，每个中断类型都有其特定的用途和特点：

**SGI（Software Generated Interrupt，软件生成中断）**：
- **用途**：处理器之间的通信
- **触发方式**：通过向GIC中的SGI寄存器写入来生成
- **中断号范围**：ID0 - ID15
- **典型应用**：多核系统中，一个核心通知其他核心执行某些任务

**PPI（Private Peripheral Interrupt，私有外设中断）**：
- **用途**：针对特定处理器核心的外设中断
- **特点**：不与其他处理器核心共享
- **中断号范围**：ID16 - ID31
- **典型应用**：每个核心专属的定时器中断

**SPI（Shared Peripheral Interrupt，共享外设中断）**：
- **用途**：全局外设中断，可以路由到指定的处理器核心
- **特点**：允许多个处理器核心接收同一个中断
- **中断号范围**：ID32 - ID1019
- **典型应用**：网卡、硬盘等公共外设的中断

**LPI（Locality-specific Peripheral Interrupt，特定局部外设中断）**：
- **特点**：GICv3中引入的新型中断类型
- **配置方式**：配置存储在内存表中，而不是寄存器中
- **传递方式**：总是基于消息的中断

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/6aef36412388e3510b6d9f03209a8594.png)

> [!example]+ 示例
> 
> 在四核处理器系统中，当网卡接收到数据包时，会产生一个SPI中断。GIC可以将这个中断路由到任意一个空闲的处理器核心，实现负载均衡。

### 3.2 中断状态机

中断处理的状态机如下图所示：

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/d630f80139e969c34254cdec49a50898.png)

**四种中断状态**：

- **Inactive（非活动状态）**：中断源当前未被触发，处于待命状态
- **Pending（等待状态）**：中断源已被触发，但尚未被处理器核心确认
- **Active（活动状态）**：中断源已被触发，并且已被处理器核心确认，正在处理中
- **Active and Pending（活动且等待状态）**：已确认一个中断实例，同时另一个中断实例正在等待处理

> [!warning]+ 警告或注意
> 
> Active and Pending状态表明同一个中断源在短时间内连续触发了多次，这种情况在高频中断中比较常见，需要在中断处理程序中妥善处理。

中断状态的转换反映了完整的处理流程：
1. **Inactive → Pending**：外围设备发出中断请求
2. **Pending → Active**：处理器确认并开始处理中断
3. **Active → Inactive**：处理器完成中断处理

**---------------让我们跟踪一个完整的中断处理过程---------------**
**第一步：中断发送**
- 外围设备将中断发送给分发器
- 如果中断当前状态是inactive，则切换得到pending
- 如果已经是active状态，则切换到active and pending

**第二步：中断转发**
- 分发器从所有pending状态的中断中选出优先级最高的
- 转发到目标处理器的处理器接口
- 通过接口将中断信号发送给对应的处理器

**第三步：中断确认**
- 处理器开始执行对应的中断处理程序
- 程序会先读取处理器接口的 **中断确认寄存器**，获得具体的**中断号**
- 该操作会自动将分发器中的中断状态从pending切换到active

**第四步：设备处理**
- 中断处理程序根据中断号识别是哪个设备发出的中断
- 然后调用对应设备的专用处理程序

**第五步：结束处理**
- 处理完成后，程序将中断号写入处理器接口的 **中断结束寄存器**，通知系统中断处理完毕
- 分发器收到通知后，将中断状态从active切换回inactive，或从active and pending切换到pending

### 3.3 中断触发方式

每个外设中断可以是以下两种类型之一：

**边沿触发（Edge-triggered）**：
- 这是一种在检测到中断信号上升沿时触发的中断
- 触发后保持触发状态，直到满足清除条件
- 适用于瞬时事件，如按键按下

**电平触发（Level-sensitive）**：
- 这是一种在中断信号电平处于活动状态时触发的中断
- 在电平不处于活动状态时取消触发
- 适用于持续状态，如外设数据准备就绪

> [!tip]+ 重要提示
> 
> 选择合适的触发方式对中断处理的可靠性至关重要。边沿触发响应快但可能丢失信号，电平触发更可靠但需要及时清除中断源。

## 4 中断号管理机制

### 4.1 虚拟中断号vs硬件中断号

在Linux内核中，我们使用**IRQ number**和**HW interrupt ID**两个ID来标识一个来自外设的中断。理解这两个概念的区别对于掌握中断系统至关重要。

**IRQ number（虚拟中断号）**：
- CPU需要为每一个外设中断编号，我们称之IRQ Number
- 这个IRQ number是一个虚拟的interrupt ID，和硬件无关
- 仅仅是被CPU用来标识一个外设中断
- 类似于"身份证号码"，全系统唯一

**HW interrupt ID（硬件中断号）**：
- 对于GIC中断控制器而言，它收集了多个外设的interrupt request line并`向上传递`
- GIC中断控制器需要对外设中断进行编码
- GIC中断控制器用HW interrupt ID来标识外设的中断
- 类似于"门牌号"，在`同一个控制器内唯一`

> [!note]+ 重要笔记
> 
> 如果只有一个GIC中断控制器，那IRQ number和HW interrupt ID是可以一一对应的。但在级联情况下，就需要irq domain机制来管理映射关系。

### 4.2 中断域映射机制（irq_domain）

在GIC中断控制器级联的情况下，仅仅用HW interrupt ID就不能唯一标识一个外设中断，还需要知道该HW interrupt ID所属的GIC中断控制器（HW interrupt ID在不同的Interrupt controller上是会重复编码的）

这样，CPU和中断控制器在标识中断上就有了一些不同的概念。对于驱动工程师而言，我们和CPU视角是一样的，我们只希望得到一个IRQ number，而不关心具体是哪个GIC中断控制器上的哪个HW interrupt ID。

为了管理这种复杂的层次结构，Linux内核引入了 **中断域（irq_domain）** 概念

简单来说，中断域就像一个“翻译器”，负责将每个中断控制器的**HW interrupt ID映射成全局唯一的IRQ number**

> [!tip]+ 重要提示
> 
> 这样一个好处是在中断相关的硬件发生变化的时候，驱动软件不需要修改。因此，Linux kernel中的中断子系统需要提供一个将HW interrupt ID映射到IRQ number上来的机制，也就是irq domain。

### 4.3 映射方法的选择

中断域支持三种不同的映射策略，每种都有其适用场景

**1、线性映射**：
- 使用固定大小的数组，`硬件中断号直接作为数组索引`
- 这种方式查找速度最快，适合硬件中断号数量固定且较小（<256）的场景

```c
static inline struct irq_domain *irq_domain_add_linear(struct device_node *of_node,
                           unsigned int size,
                           const struct irq_domain_ops *ops,
                           void *host_data)
{
      return __irq_domain_add(of_node_to_fwnode(of_node), size, size, 0, ops, host_data);
}
```
- of_node：指向设备树节点的指针，用于关联中断域与具体硬件
- size：中断域支持的最大中断数量
- ops：实现hwirq到virq映射逻辑的回调函数
- host_data：指向控制器私有数据的指针

**2、树映射**
- 使用基数树数据结构保存映射关系
- 这种方式内存效率高，适合意见中断号可能很大但实际使用的中断数量相对较少的场景

```c
static inline struct irq_domain *irq_domain_add_tree(struct device_node *of_node,
                            const struct irq_domain_ops *ops,
                            void *host_data)
{
      return __irq_domain_add(of_node_to_fwnode(of_node), 0,～0, 0, ops, host_data);
}
```

**3、不映射**
- 适用于功能强大的中断控制器，这些控制器的硬件中断号可以直接配置为Linux中断号，无需额外映射
- 例如PowerPC架构的MPIC控制器

```c
static inline struct irq_domain *irq_domain_add_nomap(struct device_node *of_node,
                            unsigned int max_irq,
                            const struct irq_domain_ops *ops,
                            void *host_data)
{
      return __irq_domain_add(of_node_to_fwnode(of_node), 0, max_irq, max_irq, ops, host_data);
}
```

> [!tip]+ 实现细节 
> 所有分配函数最终都会调用`__irq_domain_add()`来完成实际工作：分配irq_domain结构体、初始化成员变量，并将新的中断域添加到全局链表irq_domain_list中。

### 4.4 映射操作

创建中断域后，需要建立具体的映射关系：

**1、创建映射**：使用`irq_create_mapping()`函数像中断域添加新的映射关系
```c
unsigned int irq_create_mapping(struct irq_domain  *domain, irq_hw_number_t hwirq);
```
- 该函数接收中断域和硬件中断号作为参数，返回分配的Linux中断号
- 内部流程是**先分配一个全局唯一的Linux中断号**，然后在指定的中断域中建立硬件中断号到Linux中断号的映射关系

**2、查找映射**：中断处理过程中需要根据hwirq快速找到virq，使用`irq_find_mapping()`函数
```c
unsigned int irq_find_mapping(struct irq_domain *domain, irq_hw_number_t hwirq);
```
- 这个函数是中断处理的关键环节，它接收中断域和硬件中断号，返回对应的Linux中断号，让系统能够正确调用相应的中断处理程序

## 5 中断编程API

### 5.1 request_irq函数详解

**request_irq**函数是在Linux内核中用于注册中断处理程序的函数。它用于请求一个中断号（IRQ number）并将一个中断处理程序与该中断关联起来。

```c
// linux/interrupt.h
int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev);
```

**函数作用**： request_irq函数的主要功能是请求一个中断号，并将一个中断处理程序与该中断号关联起来。当中断事件发生时，与该中断号关联的中断处理程序会被调用执行。

**参数详解**：
- **irq**：请求的中断号（IRQ number），通过之前学习的[2 从设备树获取中断号](../07-🔍%20中断及异常处理/02_中断基础概念/3_获取中断号.md#2%20从设备树获取中断号)方法获得
- **handler**：指向中断处理程序的函数指针，必须符合特定的函数签名
- **flags**：标志位，用于指定中断处理程序的行为和属性
- **name**：中断的名称，用于标识该中断，会在/proc/interrupts中显示
- **dev**：指向设备或数据结构的指针，可以在中断处理程序中使用

**常用标志位flags**：
- **IRQF_TRIGGER_NONE**：无触发方式，表示中断不会被触发
- **IRQF_TRIGGER_RISING**：上升沿触发方式，表示中断在信号上升沿时触发
- **IRQF_TRIGGER_FALLING**：下降沿触发方式，表示中断在信号下降沿时触发
- **IRQF_TRIGGER_HIGH**：高电平触发方式，表示中断在信号为高电平时触发
- **IRQF_TRIGGER_LOW**：低电平触发方式，表示中断在信号为低电平时触发
- **IRQF_SHARED**：中断共享方式，表示中断可以被多个设备共享使用

> [!note]+ 重要笔记
> 
> flags参数用于指定中断处理程序的行为和属性，如中断触发方式、中断共享等。可以使用位运算来组合多个属性。

**返回值**：
- 成功：0或正数，表示中断请求成功
- 失败：负数，表示中断请求失败，返回的负数值表示错误代码

### 5.2 gpio_to_irq函数

**gpio_to_irq**函数用于将GPIO引脚的编号（GPIO pin number）转换为对应的中断请求号（interrupt request number）

```c
// linux/gpio.h
unsigned int gpio_to_irq(unsigned int gpio);
```

**功能描述**： gpio_to_irq是一个用于将GPIO引脚映射到对应中断号的函数。其作用是根据指定的GPIO引脚号，获取与之关联的中断号。

**参数说明**：
- **gpio**：要映射的GPIO引脚号

**返回值**：
- 成功：返回值为该GPIO引脚所对应的中断号
- 失败：返回值为负数，表示映射失败或无效的GPIO引脚号

> [!warning]+ 警告或注意
> 
> 不是所有的GPIO都支持中断功能，使用前需要确认硬件是否支持，并检查返回值的有效性。

### 5.3 free_irq函数

**free_irq**函数用于释放之前通过request_irq函数注册的中断处理程序。它的作用是取消对中断的注册并释放相关的系统资源。

```c
// linux/interrupt.h
void free_irq(unsigned int irq, void *dev_id);
```

**功能描述**： free_irq函数用于释放之前通过request_irq函数注册的中断处理程序。它会取消对中断的注册并释放相关的系统资源，包括中断号、中断处理程序和设备标识等。

**参数说明**：
- **irq**：要释放的中断号
- **dev_id**：设备标识，用于区分不同的中断请求。通常是在request_irq函数中传递的设备特定数据指针

## 6 中断服务函数

### 6.1 函数原型和参数

中断处理程序是在中断事件发生时自动调用的函数。它负责处理与中断相关的操作，例如读取数据、清除中断标志、更新状态等。

```c
irqreturn_t handler(int irq, void *dev_id);
```

**函数功能**： handler函数是一个中断服务函数，用于处理特定中断事件。它在中断事件发生时被操作系统或硬件调用，执行必要的操作来响应和处理中断请求。

**参数说明**：
- **irq**：表示中断号或中断源的标识符。它指示引发中断的硬件设备或中断控制器
- **dev_id**：是一个void类型的指针，用于传递设备特定的数据或标识符。它通常用于在中断处理程序中区分不同的设备或资源

**返回值类型**：**irqreturn_t**是一个特定类型的枚举值，用于表示中断服务函数的返回状态。它可以有以下几种取值：
- **IRQ_NONE**：表示中断服务函数未处理该中断，中断控制器可以继续处理其他中断请求
- **IRQ_HANDLED**：表示中断服务函数已成功处理该中断，中断控制器无需进一步处理
- **IRQ_WAKE_THREAD**：表示中断服务函数已收到中断，并且请求唤醒一个内核线程来继续执行进一步的处理。适用于一些需要长时间处理的中断情况

### 6.2 编程注意事项

在编写中断处理程序时，通常需要注意以下几个方面：

> [!warning]+ 警告或注意
> 
> **快速执行**：处理程序应该尽可能地快速执行，以避免中断丢失或过多占用CPU时间。

> [!tip]+ 重要提示
> 
> - **共享中断处理**：如果中断源是共享的，处理程序需要处理多个设备共享同一个中断的情况。
> - **同步考虑**：处理程序可能需要与其他部分的代码进行同步，例如访问共享数据结构或使用同步机制来保护临界区域。
> - **线程通信**：处理程序可能需要与其他线程或进程进行通信，例如唤醒等待的线程或发送信号给其他进程。

> [!example]+ 示例
> 
> 一个典型的中断处理程序流程：读取硬件状态 → 清除中断标志 → 处理数据 → 唤醒等待线程 → 返回IRQ_HANDLED

## 7 总结

通过这个章节的学习，我们全面了解了Linux中断子系统的框架结构：

> [!abstract]+ 摘要或总结
> 
> **核心知识掌握**：
> 
> - 理解了中断子系统四层架构的设计思想和各层职责
> - 掌握了GICv3中断控制器的组成和工作原理
> - 学习了四种中断类型的特点和应用场景
> - 了解了中断号管理和irq domain映射机制
> - 掌握了中断编程接口的使用方法和注意事项

中断子系统框架为Linux提供了统一、高效的中断处理机制。理解这个框架有助于我们在后续的驱动开发中正确使用中断功能，编写出高质量的设备驱动程序。

> [!question]+ 常见问题
> 
> **Q**: 为什么需要虚拟中断号和硬件中断号两套编号系统？ 
> **A**: 虚拟中断号提供了硬件抽象，使驱动程序可以在不同硬件平台间移植。当硬件发生变化时，只需要修改底层映射关系，而不需要修改驱动代码。

