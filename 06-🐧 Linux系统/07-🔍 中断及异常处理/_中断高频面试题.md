
1. 发生硬件中断后，ARM64处理器做了哪些事情？
    
2. 硬件中断号和Linux内核的IRQ号是如何映射的？
    
3. 一个硬件中断发生后，Linux内核如何响应并处理该中断？
    
4. 为什么说中断上下文不能执行睡眠操作？
    
5. 软中断的回调函数执行过程中是否允许响应本地中断？
    
6. 同一类型的软中断是否允许多个CPU并行执行？
    
7. 软中断上下文包括哪几种情况？
    
8. 软中断上下文还是进程上下文的优先级高？为什么？
    
9. 是否允许同一个tasklet在多个CPU上并行执行？
    
10. 工作队列是运行在中断上下文，还是进程上下文？它回调函数允许睡眠吗？
    
11. 旧版本（Linux 2.6.25）的工作队列机制在实际应用中遇到了哪些问题和挑战？
    
12. CMWQ机制如何动态管理工作线程池的线程呢？
    
13. 如果多个work挂入一个工作线程中执行，当某个work的回调函数执行了阻塞操作时，那么剩下的work该怎么办？
    
14. 、什么是中断现场？中断现场中需要保存哪些内容？
    
15. 中断现场保存在什么地方？
    

## **1. 发生硬件中断后，ARM64 处理器做了哪些事情？**

1. **中断屏蔽**：
    
    1. 处理器会自动屏蔽同级或更低级别的中断，防止嵌套中断干扰当前中断处理。
        
2. **中断异常向量跳转**：
    
    1. 处理器从当前程序状态跳转到对应的中断向量表中的异常处理程序入口点（`elX_irq`）。
        
3. **保存寄存器上下文**：
    
    1. 处理器会将部分寄存器（如 PC 和 CPSR）自动保存到堆栈中。
        
4. **进入异常模式**：
    
    1. 处理器切换到相应的异常模式（IRQ 模式），并更新程序状态寄存器（SPSR）。
        
5. **跳转到内核中断处理程序**：
    
    1. 根据异常向量表的偏移，跳转到对应的中断处理逻辑。
        

---

## **2. 硬件中断号和 Linux 内核的** **IRQ** **号是如何映射的？**

- **硬件中断号**：
    
    - 通常由硬件设备（如 GIC，Generic Interrupt Controller）分配，用于唯一标识设备发出的中断信号。
        
- **IRQ** **号**：
    
    - Linux 内核中的逻辑编号，用于抽象化中断管理。
        
- **映射关系**：
    
    - 中断控制器（如 GIC）通过 `irqchip` 驱动，将硬件中断号映射到 Linux 内核的 IRQ 号。
        
    - 在设备树（`Device Tree`）中，硬件中断号通过 `interrupts` 属性配置。
        

---

## **3. 一个硬件中断发生后，Linux 内核如何响应并处理该中断？**

1. **硬件响应中断**：
    
    1. 中断控制器捕获硬件中断信号，并将其发送到 CPU。
        
2. **进入内核中断入口**：
    
    1. ARM64 的中断向量入口 (`elX_irq`) 被触发。
        
3. **调用通用中断处理程序**：
    
    1. 内核调用通用中断入口函数（`handle_irq`），确定具体中断源。
        
4. **执行中断处理程序**：
    
    1. 内核通过中断号找到对应的中断处理程序（`irq_handler`）。
        
5. **结束中断处理**：
    
    1. 内核通知中断控制器清除中断状态。
        

---

## **4. 为什么说中断上下文不能执行睡眠操作？**

- **中断上下文没有进程**：
    
    - 中断上下文不属于任何进程，无法被调度。
        
- **睡眠需要调度支持**：
    
    - 睡眠操作（如 `schedule()`）会将当前任务挂起，而中断上下文无法切换任务。
        
- **影响系统响应**：
    
    - 中断上下文执行睡眠可能导致中断处理时间过长，影响系统实时性。
        

---

## **5. 软中断的回调函数执行过程中是否允许响应本地中断？**

- **允许响应本地中断**：
    
    - 在软中断执行过程中，默认开启中断（`local_irq_enable()`），允许更高级别的中断抢占当前软中断。
        

---

## **6. 同一类型的软中断是否允许多个 CPU 并行执行？**

- **允许并行执行**：
    
    - 软中断是按 CPU 局部处理的，多个 CPU 上可以同时执行同一类型的软中断，但每个 CPU 上只能处理自己的软中断。
        

---

## **7. 软中断上下文包括哪几种情况？**

软中断上下文可以通过以下两种方式触发：

1. **中断退出时**：
    
    1. 硬中断处理程序返回时，内核会检查挂起的软中断并执行。
        
2. **内核主动触发**：
    
    1. 调用 `raise_softirq()` 函数显式触发软中断。
        

---

## **8. 软中断上下文还是进程上下文的优先级高？为什么？**

- **软中断优先级更高**：
    
    - 软中断会抢占进程上下文，原因是软中断用于处理高优先级的任务，如网络数据包处理。
        
- **原因**：
    
    - 确保实时性，软中断的延迟可能影响系统的响应能力。
        

---

## **9. 是否允许同一个 tasklet 在多个 CPU 上并行执行？**

- **不允许**：
    
    - Tasklet 设计为单线程执行机制，同一个 tasklet 在任何时刻只能在一个 CPU 上运行。
        

---

## **10. 工作队列是运行在中断上下文，还是进程上下文？它的回调函数允许睡眠吗？**

- **工作队列运行在进程上下文**：
    
    - 工作队列通过内核线程执行，与中断上下文无关。
        
- **允许睡眠**：
    
    - 回调函数运行在进程上下文，可以调用睡眠相关操作。
        

---

## **11. 旧版本（Linux 2.6.25）的工作队列机制在实际应用中遇到了哪些问题和挑战？**

1. **资源浪费**：
    
    1. 每个工作队列都有独立的线程，导致线程数量过多，浪费系统资源。
        
2. **任务调度不均衡**：
    
    1. 难以动态调整线程负载，可能造成某些线程过载而其他线程空闲。
        
3. **延迟问题**：
    
    1. 全局队列的任务可能出现处理延迟，影响实时性。
        

---

## **12. CMWQ 机制如何动态管理工作线程池的线程？**

- **线程动态创建与销毁**：
    
    - 根据系统负载，CMWQ 会动态增加或销毁 `worker` 线程。
        
- **按需调度**：
    
    - 当任务队列增加时，CMWQ 会唤醒空闲线程或创建新的线程来处理任务。
        
- **负载均衡**：
    
    - 在多 CPU 系统中，CMWQ 会将任务分配到不同 CPU 的 `worker_pool` 中。
        

---

## **13. 如果多个 work 挂入一个工作线程中执行，当某个 work 的回调函数执行了阻塞操作时，剩下的 work 该怎么办？**

- **队列阻塞**：
    
    - 队列中的剩余 `work` 会被阻塞，直到当前 `work` 的回调函数完成。
        
- **解决方案**：
    
    - 应避免阻塞操作，或使用独立的工作队列来隔离任务。
        

---

## **14. 什么是中断现场？中断现场中需要保存哪些内容？**

- **中断现场**：
    
    - 中断发生时，处理器的当前执行状态，包括寄存器内容、程序计数器和状态寄存器。
        
- **需要保存的内容**：
    
    - 通用寄存器（如 `x0`-`x30`）。
        
    - 程序计数器（PC）。
        
    - 程序状态寄存器（PSTATE）。
        

---

## **15. 中断现场保存在什么地方？**

- **保存位置**：
    
    - ARM64 处理器会将中断现场保存到堆栈中。
        
- **堆栈类型**：
    
    - 硬中断堆栈：由内核为每个 CPU 分配的专用堆栈，用于保存中断上下文。