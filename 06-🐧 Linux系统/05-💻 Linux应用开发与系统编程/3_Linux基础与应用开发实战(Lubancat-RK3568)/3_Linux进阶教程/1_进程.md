---
文章标题: "[[1_进程]]"
文章作者: Dakkk
文章概要: |
  文章详细介绍了Linux进程的核心概念，包括PID、PPID、程序与进程的区别、进程状态及转换。通过`fork`、`exec`、`wait`、`exit`等系统调用，演示了进程的创建、执行、终止与等待机制，为Linux系统编程打下基础。
tags:
  - Linux
  - 进程
  - 系统调用
  - 进程管理
  - fork
  - exec
  - 进程状态
  - wait
相关文章:
  - "[[../../../../05-💻 Linux应用开发与系统编程/2_Linux上层应用编程(迅为)/0_Linux系统编程]]"
  - "[[../../../../02-💻 开发环境/3_Lubancat-RK3568/2_镜像构建与部署/07_Linux的介绍]]"
  - "[[../../../../05-💻 Linux应用开发与系统编程/2_Linux上层应用编程(迅为)/4_进程基础]]"
  - "[[../2_使用板卡开发C程序/7_文件操作与系统调用📕]]"
  - "[[0_课程介绍]]"
文章分类: 🐧 Linux系统
文章路径: 06-🐧 Linux系统/04-🔌 驱动开发/02-💾 Lubancat-RK3568/3_Linux基础与应用开发实战/3_Linux进阶教程/1_进程.md
文章难度: 中级 🌳
目前阶段: ✅ 已完成
重要性: ⭐⭐⭐⭐⭐ 精通必备
创建时间: 2025-05-06 17:06:57
修改时间: 2025-05-28 00:42:46
---

接下来我们学习Linux内核提供的进程、管道、信号等内核对象，了解这些内核对象的应用有利于
- 知道Linux内核为应用层提供了什么特性
- 有益于后续编程更底层的驱动程序
## 1 简单了解进程

首先在虚拟机中打开一个终端，一般来说Ubuntu中有很多shell终端，而**一个终端就是一个进程**，这些进程独立运行在系统中，互不影响，下图打开了3个Shell终端，终端各自有输入，互不干扰
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/d016705f6916ff11e0f0a54f5e07e6da.png)

- 在shell内调用程序时，对应的程序是在新进程中运行的，运行结束后shell继续工作
- 高级程序员经常在一个程序中同时启用多个协作的进程使得程序可以并行更多任务、使程序更健壮，或者直接利用已有的其他程序，这样让整个系统中运行的进程可以相互配合，而不是独立运行（涉及进程间通信）
## 2 查看进程

即使我们打开虚拟机，没有运行任何程序，进程仍旧会存在，因为系统必须要有进程在处理一些必要的程序，以保证系统能正常运行。

**Linux中是通过检查表记录进程相关信息的，进程表就是一个数据结构/表**（加载在内存中的所有进程的有关信息），这表包括如下信息
- 进程PID：进程表的索引
- 进程状态
- 命令字符串
- 其他ps命令输出的信息

OS通过进程ID对其进行管理，对于Linux系统来说，支持同时运行的进程数只与用于建立进程表项的内存有关，没有具体数量限制，即**内存足够大，理论可以运行无数个进程**。
### 2.1 进程ID

Linux系统中每个进程都会被分配一个唯一的数字编号，称为进程ID（ProcessID，PID）
- 进程ID 是一个16位的正整数， 默认取值范围是从2到32768（可以修改）
- 由Linux在启动新进程的时候自动依次分配，当进程被启动时， 系统将按顺序选择下一个未被使用的数字作为它的PID
- 当PID的数值达到最大时， 系统将重新选择下一个未使用的数值
- 新的PID将重新从2开始，这是因为**PID数字为1的值一般是为特殊进程init保留， 即系统在运行时就存在的第一个进程**，init进程负责管理其他进程
### 2.2 父进程ID

任何进程（除init进程）都是由另一个进程启动的，该进程称为**父进程**，被启动的进程称为子进程

父进程号无法在用户层修改。父进程的进程号（PID）即为子进程的父进程号（PPID）。用户可以通过**调用`getppid()`函数来获得当前进程的父进程号**。

可以使用ps命令去查看系统中的进程情况， ps命令可以显示我们正在运行的进程、其他用户正在运行的进程或者目前在系统上运行的所有进程。
```shell
ps -aux
```

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/e0beea27c8a2079afc8f7df85cf90088.png)

- 编号1的进程为init进程，位于`/sbin/init` 目录中
- 整个系统的进程可不止这一些，由于太多没法截图， 就只展示这小部分的进程
- 在Linux中， ps命令有很多选项，因为它试图与很多不同 UNIX 版本的ps命令兼容， 这些选项决定显示哪些进程以及要显示的信息
  ![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/74eed0ff7d6dc97575c8f361ae8369bc.png)
### 2.3 父进程与子进程

进程启动时，启动进程是新进程的父进程，新进程是启动进程的子进程

每个进程都有一个父进程（除了系统中如“僵尸进程”这种特殊进程外），所以
- 把可以Linux中的进程结构想象为一个树状结构，其中init进程就是树的root
- 也可以把init看做OS的进程管理器，它是其他所有进程的祖先进程
- 所以，其他系统进程要么是由init进程启动的，要么是由被init进程启动的其他进程启动的

**总的来说：** init进程下有很多子进程，这些子进程又可能存在子进程，类似家族一样。系统中所有的父进 程ID被称为PPID，不同进程的父进程是不同的，这个值只是当前进程的父进程的ID，**系统中的父进程与子进 程是相对而言的**，就好比 `爷爷<->爸爸<->儿子` 之间的关系，爸爸相对于爷爷而言是儿子， 相对于儿子而言则是爸爸

为了更加直观看出系统中父进程与子进程，此处我们使用 `pstree` 命令将进程以树状关系列出来
```shell
pstree

#若系统提示command not found，可通过如下指令安装：
sudo apt update
sudo apt install psmisc
```

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/280c0a1f4e720a65e792af08e642efb8.png)

## 3 程序和进程

那么我们写的代码，它是程序 ，是如何变成进程的呢？这时我们需要了解程序和进程之间的关系
### 3.1 程序的概念

程序（program）是一个**普通文件**，是为了完成特定任务而准备好的**指令序列与数据的集合**， 这些指令和数据以”可执行映像”的格式**保存在磁盘**中

例如我们写的代码，经过编译器编译后， 就会生成对应的可执行文件，那么这个就是程序，或者称之为可执行程序。
### 3.2 进程的概念

**进程（process）则是程序执行的具体实例**，比如一个可执行文件，在执行的时候， 它就是一个进程，直到该程序执行完毕。

那么**在程序执行的过程中，它享有系统的资源**， 至少包括进程的运行环境、CPU、外设、内存、进程ID等资源与信息，同样的一个程序， 可以实例化为多个进程，在Linux系统下使用ps命令可以查看到当前正在执行的进程， 当这个可执行程序运行完毕后，进程也会随之被销毁（可能不是立即销毁，但是总会被销毁）

程序并不能单独执行，只有将程序加载到内存中，系统为它分配资源后才能够执行， 这种`正在执行的程序称之为进程`，也就是说`📕进程是系统进行资源分配和调度的一个独立单位`， 每个进程都有自己单独的地址空间

例如在/bin目录下有很多可执行文件，我们打开一个中断就是一个进程，这个进程由bash可执行文件（程序）实例化而来。而一个Linux系统可以打开多个终端， 并且这些终端是独立运行在系统中的
### 3.3 程序变成进程

在Linux系统中，`程序只是个静态的文件`，而`进程是一个动态的实体`， 进程的状态（后续讲解进程状态）会在运行过程中改变，那么问题来了，**程序到底是如何变成一个进程的呢？**

正如我们运行一个程序（可执行文件），通常在Shell中输入命令运行就可以了， 在这运行的过程中包含了程序到进程转换的过程，整个转换过程主要包含以下3个步骤：
- 查找命令对应程序文件的位置
- 使用`fork()`函数启动**一个新进程**
- 在新进程中调用`exec族函数` **装载**程序文件，并**执行**程序文件中的main()函数
### 3.4 总结

总的来说，程序与进程有以下的关系：
**程序**
- 一系列指令序列与数据的集合，一个静态的实体

**进程**
- 程序在某个数据集上的执行过程，一个动态运行的实体，有生命周期
- 因启动而产生，因调度而运行，因等待资源或事件而处于等待状态，因完成任务而销毁
- 进程具有并发性，而程序没有
- 进程是竞争计算机资源的基本单位，而程序不是

**关联**
- `程序和进程不是一一对应的`，一个程序执行在不同的数据集上运行就会成为不同的进程， 可以用进程控制块来唯一地标识系统中的每个进程
- 由于程序没有和数据产生直接的联系，既使是执行不同的数据的程序， 他们的指令的集合依然是一样的，所以无法唯一地标识出这些运行于不同数据集上的程序
- **一个进程肯定有一个与之对应的程序，而且有且只有一个**
- 一个程序有可能没有与之对应的进程（因为这个程序没有被运行）， 也有可能有多个进程与之对应（这个程序可能运行在多个不同的数据集上）
## 4 进程状态

先带领大家看看系统中常见的进程状态， 可以通过ps命令将系统中运行的进程信息打印出来，我们只需要关注STAT那一列的信息即可， 进程的状态非常多种，具体如下图：
```shell
# u选项：显示当前用户相关的进程
# x选项：显示没有bash的进程
ps -ux
```

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/1f3e4690de5b313f8efc8950e9cab621.png)

Linux系统中进程状态说明

| 状态  | 说明                                                                                          |
| --- | ------------------------------------------------------------------------------------------- |
| R   | `运行状态。严格来说，应该是“可运行状态”`，即表示进程在运行队列中，处于正在执行或即将运行状态，只有在该状态的进程才可能在 CPU 上运行，而同一时刻可能有多个进程处于可运行状态。 |
| S   | `可中断的睡眠状态`。处于这个状态的进程因为等待某种事件的发生而被挂起，比如进程在等待信号。                                              |
| D   | `不可中断的睡眠状态`。通常是在等待输入或输出（I/O）完成，处于这种状态的进程不能响应异步信号。                                           |
| T   | `停止状态`。通常是被shell的工作信号控制，或因为它被追踪，进程正处于调试器的控制之下。                                              |
| Z   | `退出状态`。进程成为僵尸进程。                                                                            |
| X   | `退出状态`。进程即将被回收。                                                                             |
| s   | 进程是会话其首进程，即会话的创建者，该会话的第一个进程                                                                 |
| l   | 进程是多线程的。                                                                                    |
| +   | 进程属于前台进程组。                                                                                  |
| <   | 高优先级任务。                                                                                     |
## 5 进程状态转换📕

进程是动态的活动的实例，这其实指的是进程会有很多种运行状态， 一会儿睡眠、一会儿暂停、一会儿又继续执行。

Linux操作系统是一个多用户多任务的操作系统， 但对于**单核的CPU系统**来说，在**某一时刻，只能有一个进程处于运行状态（此处的运行状态指的是占用CPU）**， 其他进程都处于其他状态，等待系统资源，各任务根据调度算法在这些状态之间不停地切换。但由于CPU处理速率较快，使用户感觉每个进程都是同时运行。

下图展示了Linux进程从被启动到退出的全部状态，以及这些状态发生转换时的条件
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/9d6c97fbbdbfa20e48cafa1bf299e02c.png)

**上图的描述**
1. 一个进程的**开始都是由其父进程调用fork函数**开始的，这些进程要么是init进程启动的，要么是init进程的子进程启动的

2. 进程启动后处于可运行状态（此时并未占用CPU运行），该状态的进程是正在进程等待队列中排队（`就绪态`），也可以占用CPU指针运行（`运行态`）

3. 如OS产生进程调度时，就绪态的进程可以占用CPU，然后进入运行态。运行态是有时间限制的，比如10ms（`时间片`）。
	- 当时间片耗光时，如果进程还没有结束运行，就会被OS重新放入等待队列中进入就绪态
	- 就是时间片没耗光，也可被更高优先级的进程抢占，重新回到就绪态

4. 运行态的进程可能会等待某些事件、信号或资源而进入`可中断睡眠态`，如
	- 读取一个管道文件数据而管道为空
	- 进程要获得一个锁资源而当前锁不可获取
	- 进程自己调用slepp函数来强制进入睡眠
	- 不过该状态是可以被中断的，能响应信号，在特定条件后，进入就绪态
5. 运行态的进程还可能进入`不可中断睡眠态`，且不能响应信号，不过状态非常短暂，无法通过ps命令将其显示。一般该状态进程都是在等待输入或输出（I/O）完成，等待完成后自动进入就绪态
6. 运行态进程收到 `SIGSTOP` 或 `SIGTSTP` 其中一个信号时，会进入`暂停态`，此时不再存于调度，系统资源不会释放，直到收到`SIGCONT`信号后重新回到就绪态
	- 典型的情况是使用调试器调试应用程序
	- 收到任何信号状态都会被置于 TASK_TRACED状态（和暂停态的一样的）
7. 进程在完成后会退出，此时进程进入`退出状态`，
	- 正常的退出：main函数内return、调用exit、线程调用pthread_exit
	- 异常的退出：进程被kill信号杀死，不管如何死，内核都会调用do_exit函数让进程进入`僵尸态（僵尸进程）`
	8. 父进程处理僵尸进程时，会将其状态设置为EXIT_DEAD，即`死亡态（退出态）`，便于系统回收僵尸进程的内存空间，避免OOM


**补充1：僵尸进程**
- “僵尸”指的是进程的PCB（Process Control Block，进程控制块）
- **为什么一个进程的死掉之后还要把尸体（PCB）留下？**
	- 进程在退出的时候， 系统会将其退出信息都保存在进程控制块中，比如如果他正常退出，那进程的退出值是什么？ 如果是被信号杀死？那么是哪个信号将其杀死？这些“死亡信息”都被一一封存在该进程的PCB当中， 好让别人可以清楚地知道：我是怎么死的。
- **那谁会关心它是怎么死的呢？**
	- 那就是它的父进程，它的父进程之所以要启动它，很大的原因是要让这个进程去干某一件事情， 现在这个孩子已死，那事情办得如何，因此需要把这些信息保存在进程控制块中，等着父进程去查看这些信息。

**补充2：处理僵尸进程**
- **假如父进程由于太忙而没能及时去处理僵尸进程的时候， 要如何处理？**
	- 可能不同的程序员有不同的处理， 父进程有别的事情要干，不能随时去处理僵尸进程。在这样的情形下，可以考虑使用`信号异步通知机制`， 让一个孩子在变成僵尸的时候，给其父进程发一个信号，父进程接收到这个信号之后， 再对其进行处理，在此之前父进程该干嘛就干嘛
- **假如在子进程变成“僵尸态”之前，它的父进程已经先它而去了（退出）， 那么这个子进程变成僵尸态由谁处理呢？**
	- 如果一个进程的父进程先退出， 那么这个子进程将变成“`孤儿进程`”（没有父进程），那么这个进程将会被他的祖先进程收养（adopt）， 它的祖先进程是init（该进程是系统第一个运行的进程，他的PCB是从内核的启动镜像文件中直接加载的， 系统中的所有其他进程都是init进程的后代）。那么当子进程退出的时候，init进程将回收这些资源。
## 6 启动新进程

在Linux中启动一个进程有多种方法
- 可以使用system()函数，方法简单，效率低下且存在安全风险
- 可以使用fork()函数，复杂，不过提供了更好的弹性、效率和安全性
### 6.1 system() 进程实验

system()函数是C标准库中提供的，它主要是提供了一种**调用其它程序**的简单方法。它产生的结果与从shell中执行这个程序基本相似。

事实上，system()启动了一个运行着/bin/sh的子进程，然后将命令交由它执行，其中/bin/sh是一个shell的一种。

**代码：使用system()函数启动一个新进程ls**
```c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main(){
    pid_t result;
    printf("This is a system demo!\n\n");

    //调用system函数，传入shell命令 ls -l
    result = system("ls -l");

    printf("Done!\n\n");
    return result;
}
```
- 如果系统中shell自身无法运行， system() 函数返回 127
- 如果出现了其它错误，system()函数将返回-1
- 本例没有检查system调用是否真正工作，因为system()函数使用 shell 调用命令， 它受到系统shell自身的功能特性和安全缺陷的限制，因此，并不推荐使用这种方法去启动一个进程

编写makefile文件，是通用的，不做介绍，下面给出代码
```makefile
#生成可执行文件的名称
Target = system_demo
ARCH ?= x86
#编译器CC
#根据传入的参数ARCH，确定使用的编译器
#默认使用gcc编译器
#make ARCH=ARM64 时使用ARM-GCC编译器
ifeq ($(ARCH), x86)
	CC = gcc
else
	CC = aarch64-linux-gnu-gcc
endif
#存放中间文件的路径
build_dir = build_$(ARCH)
#存放源文件的文件夹
src_dir =  sources
#存放头文件的文件夹
inc_dir = includes .

#源文件，递归收集c文件
sources = $(foreach dir,$(src_dir),$(wildcard $(dir)/*.c))
#目标文件（*.o），转换目标文件
objects = $(patsubst %.c,$(build_dir)/%.o,$(notdir $(sources)))
#头文件，收集所有头文件
includes = $(foreach dir,$(inc_dir),$(wildcard $(dir)/*.h))

#目标依赖文件
# 生成.d依赖文件路径
DEP_FILES := $(patsubst %, .%.d,$(objects))
# 过滤已存在的依赖文件
DEP_FILES := $(wildcard $(DEP_FILES))

#判断依赖文件是否存在
ifneq ($(DEP_FILES),)
#如果存在依赖文件，需要导入依赖文件
include $(DEP_FILES)
endif

#编译参数
#指定头文件的路径
CFLAGS = $(patsubst %, -I%, $(inc_dir)) -MD -MF $(@D)/.$(@F).d

#链接过程
$(build_dir)/$(Target) : $(objects)  | create_build
	$(CC) $^ -o $@

#编译工程
#编译src文件夹中的源文件，并将生成的目标文件放在objs文件夹中
$(build_dir)/%.o : $(src_dir)/%.c $(includes) | create_build
	$(CC) -c $(CFLAGS) $< -o $@


#以下为伪目标，调用方式：make 伪目标
#clean：用于Clean Project
#check：用于检查某个变量的值
.PHONY:clean cleanall check create_build
#按架构删除
clean:
	rm -rf $(build_dir)

#全部删除
cleanall:
	rm -rf build_x86 build_arm

#命令前带"@",表示不在终端上输出执行的命令
#这个目标主要是用来调试Makefile时输出一些内容
check:
	@echo $(CFLAGS)
	@echo $(CURDIR)
	@echo $(src_dir)
	@echo $(sources)
	@echo $(objects)


#创建一个新目录create，用于存放过程文件
create_build:
	@mkdir -p $(build_dir)
```

- DEP_FILES讲解

**实验操作：**
```shell
# 编译版本程序
make
# 运行版本程序
./build_ARM64/system_demo
```

程序执行后，是通过调用system()函数启动一个进程输出的结果， 它与我们在shell终端中执行 `ls –l` 命令产生的结果是一致的
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/c019de8e32546bf691965bb15e215783.png)
- 运行结果来看，只用system函数运行完毕后，才会输出Done
- 虽然system()函数很有用，但它有局限性，因为程序必须等待system函数结束后才能继续

当然也可以在命令在后台运行，修改为 `ls -l &`即可，此时system()函数的调用将在shell命令结束后立刻返回。因为它是一个后台运行程序的请求，所以ls程序一启动shell就返回了

**修改代码后实验一下，可以看到下面的现象**
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/af5cee7ea9b58221ba4bec700692bae0.png)
- ls命令未完全输出结果，system函数就结束了（Done字符串先出来）
- 在system()程序退出后，ls命令继续完成它的输出

这类的处理行为往往会给用户带来很大的困惑，也不一定如用户所预料的结果一致， 因此如果读者想要让进程按照自己的意愿执行，就需要能够对它们的行为做更细致的控制， 接下来讲解其他方式启动新的进程。
### 6.2 fork() 进程实验

#### 6.2.1 相关理论

init进程可以启动子进程，它通过fork()函数创建一个完全分离的子进程，这只是init启动子进程的第一步，后续还有其他操作。所以，**fork函数的基础功能就是启动一个子进程**，示意图如下
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/a227c8dc77ed36b2bb129aaa122044b3.png)
- 在父进程中的fork()调用后返回的是新的子进程的PID
- 在子进程的上下文种fork()函数调用返回的是0

使用fork()函数的`本质是将父进程的内容复制一份`，正如细胞分裂一样， 得到的是几乎两个完全一样的细胞，因此这个启动的子进程基本上是父进程的一个复制品， 但子进程与父进程有不一样的地方，它们的联系与区别简单列举如下：

**一致的内容：**
- 进程的地址空间
- 进程上下文、代码段
- 进程堆空间、栈空间、内存信息
- 进程的环境变量
- 标准IO的缓冲区
- 打开的文件描述符
- 信号响应函数
- 当前工作路径

**子进程独有的内容**
- 进程号PID
- 记录锁：父进程对某文件加了把锁，子进程不会继承这把锁
- 挂起信号：已经响应但尚未处理的信号，也就是”悬挂”的信号， 子进程也不会继承这些信号

**这种复制存在一个很大的问题，就是资源和时间消耗很大，因为会做如下事情：**
- 为子进程的页表分配页面
- 为子进程的页分配页面
- 初始化子进程的页表
- 把父进程的页复制到子进程相应的页中
创建一个地址空间又涉及到许多内存访问，消耗很多CPU周期，并且完全破坏了高速缓存中的内容，因此直接复制物理内存对OS的开销影响很大

#### 6.2.2 写时复制（COW）

*更重要的是，上述直接拷贝是毫无意义的*，因为许多子进程通过装入一个新的程序开始它们的指向，这样就完全丢弃了继承的地址空间。所以在Linux中引入一种`写时复制技术（Copy On Write，简称COW）`

前面我们学过，Linux系统中的进程使用的是*虚拟内存地址*，虚拟地址和真实物理地址存在映射关系，每个进程都有自己的虚拟地址空间，操作虚拟地址明显比直接操作物理内存更加简便快捷，**所以，写时复制技术是可以推迟甚至避免复制数据的技术**，*内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间（页面）*

**写时复制的思想：**
- `父进程和子进程共享页面而不是复制页面`
- 无论父进程和子进程何时试图向一个共享的页面写入内容时， 都会产生一个错误，这时内核就把这个页复制到一个新的页面中并标记为可写
- 原来的页面仍然是写保护的，当还有进程试图写入时，内核检查写进程是否是这个页面的唯一属主， 如果是则把这个页面标记为对这个进程是可写的

所以，**写时复制只会在需要写入的时候才会复制地址空间**，资源的复制是在需要写入时才会进行，在次之前，父进程和子进程都是以只读方式共享页面，这样使得地址空间上的页拷贝推迟到实际发生写入的时候。

绝大多数的时候共享的页面根本不会被写入，例如，在调用fork()函数后立即执行exec()， 地址空间就无需被复制了，这样一来**fork()的实际开销就是复制父进程的页表以及给子进程创建一个进程描述符**

理论相关的知识了解至此即可，下面就看看fork()函数的使用，它的函数原型如下：
```c
pid_t fork(void);
```
- 在fork()启动新的进程后，子进程与父进程开始并发执行，谁先执行由内核调度算法来决定
-  fork()函数如果成功启动了进程，会对父子进程各返回一次，其中对父进程返回子进程的PID，对子进程返回0。如果fork()函数启动子进程失败，它将返回-1
- 失败通常是因为父进程所拥有的子进程数目超过了规定的限制（CHILD_MAX）， 此时errno将被设为`EAGAIN`
- 如果是因为进程表里没有足够的空间用于创建新的表单或虚拟内存不足， errno变量将被设为`ENOMEM`

#### 6.2.3 相关实验

使用fork函数启动一个新进程，并且在进程中打印相关信息，如在父进程中打印出"In father process!!"
```c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main(){
    pid_t res;
    printf("This is a fork demo!\n\n");
    // 调用fork函数
    res = fork();

    // 判断fork函数是否成功
    if(res == -1){
        printf("Fork error\n");
        //返回值0，表示子进程
    } else if(res == 0){
        printf("The returned value is %d, In child process!! My PID is %d\n\n", result, getpid());
        //返回值大于 0 代表父进程
    } else {
        printf("The returned value is %d, In father process!! My PID is %d\n\n", result, getpid());
    }
    return res;
}
```

makefile文件一样，照抄即可

**实验操作：**
```shell
make
```

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/3bf257f5152b5afe312293621cf87128.png)
- 父进程的返回值就是子进程的PID，而子进程的返回值则是0
- 子进程并不会再次执行fork()函数之前的内容，而fork()函数之后的内容在父进程和子进程都会执行一遍
### 6.3 exec 系列函数进程实验

#### 6.3.1 execl函数演示

事实上，使用fork()函数启动一个子进程是并没有太大作用的，因为子进程跟父进程都是一样的， 子进程能干的活父进程也一样能干，要想子进程做不一样的事情，就需要使用`exec系列函数`
- **主要是用于替换进程的执行程序**，即指定可执行文件，并用其取代原调用进程的数据段、代码段和堆栈段，在执行完之后，*原调用进程的内容除了进程号外，其他全部被新程序的内容替换*
- 可执行文件既可以是二进制文件，也可以是Linux下任何可执行脚本文件

简单来说，就是**覆盖进程**，举个例子
- A进程通过exec系列函数启动一个进程B，此时进程B会替换进程A， 进程A的内存空间、数据段、代码段等内容都将被进程B占用，然后进程A将不复存在

**实验分析**：通过execl()函数进行讲解
```c
int execl(const char *path, const char *arg, ...)
```
- path：文件路径（必须指定）
- arg：一系列可变参数，代表指向文件传递过去的`argv[0]、argv[1]… argv[n]`
- 最后一个参数必须用NULL作为结束的标记

```c
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

int main(){
    int err;
    printf("this is a execl function test demo!\n\n");

    err = execl("bin/ls","ls","-la",NULL);

    if(err<0){
        printf("execl error!\n");
    }

    printf("Done!\n");
    return 0;
}
```
- 其实就是与我们在终端上运行”ls -la”产生的结果是一样的

**执行make编译c文件后，执行程序**
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/bf92053cf30d91b8acfac7b98c900f25.png)

**💡提示：** 
- exec系列函数是直接将当前进程替换掉，所以示例程序中的 done 不会被输出
- 一般情况下，exec系列函数是不会返回的，除非发生错误，返回-1，并会设置错误变量errno

所以，**我们可以fork复制启动一个子进程，并且在子进程中调用exec系列函数替换子进程**，它们结合在一起就是创建一个新进程所需要的一切了
#### 6.3.2 exec族其他函数

exec族实际包含有 6 个不同的 exec 函数，它们功能一样，主要是传参的形式不同， 函数原型分别如下：
```c
int execl(const char *path, const char *arg, ...)

int execlp(const char *file, const char *arg, ...)

int execle(const char *path, const char *arg, ..., char *const envp[])

int execv(const char *path, char *const argv[])

int execvp(const char *file, char *const argv[])

int execve(const char *path, char *const argv[], char *const envp[])
```

**上面函数可以分为两大类：**
- execl、execlp和execle传递给子程序的参数个数是可变的
- execv、execvp和execve通过数组去装载子程序的参数
- 无论那种形式，参数都以一个空指针NULL结束

总的来说，可以通过后缀来区分它们的作用：
- 包含 `l` 字母，接收参数列表（list）
- 包含 `p` 字母，接收程序名（在PATH或当前路径搜索）
- 包含 `v` 字母，接收数组（Vector）
- 包含 `e` 字母，多接收一个指明环境变量列表的参数，即envp传递字符串数组作为新程序的环境变量，envp所指的字符串数组应该以NULL指针作为结束，每个字符串的形式为 `environment = virables`
## 7 终止进程

Linux系统中，进程终止的常见方式有5种，可以分为正常终止和异常终止
**正常终止**
- main函数返回
- 调用exit函数终止
- 调用_exit函数终止

**异常终止**
- 调用abort函数异常终止
- 由系统信号终止

**exit描述**
- `exit()`函数定义在stdlib.h中，`_exit()`函数定义在unistd.h中，都是用来终止进程的
- 当程序执行到上面两个函数时，进程会无条件停止剩下的操作，清除包括PCB在内的各种数据结构，并终止当前进程的运行
- 不过这两个函数还是有区别的，图下图
  ![image.png|200](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/377616889e5234d8cd27b84f11c89a34.png)
	- `_exit()`函数最简单：直接通过系统调用使进程终止运行
	- `exit()`函数在上面的基础上做了包装，如检查文件打开情况，把文件缓冲区的内容写会文件，即 **清除IO缓冲**
- 不管是那种退出方式，系统最终都会执行内核中的同一代码，这段代码用来关闭进程所用已打开的文件描述符， 释放它所占用的内存和其他资源

**缓冲 I/O（buffered I/O）操作**
- 特点：每打开一个文件，内存都有一篇缓冲区
- 读文件时，连续读若干条记录，这样下次读可以直接从内存缓冲区读取
- 写文件时，只写入内存缓冲区，满足一定条件后，再把缓冲区内容一次性写入文件
- **优点**：大大增加了文件读写的速度
- **缺点**：用`_exit()函数`直接将进程关闭，缓冲区中的数据就会丢失
- **解决**：若想保证数据的完整性，就一定要使用exit()函数

**函数使用**
```c
#include <unistd.h>
#include <stdlib.h>

void _exit(int status);
void exit(int status);
```

**参数status：**
- 表示的是进程终止时的状态码，0表示正常终止， 其他非0值表示异常终止
- 一般都可以使用-1或者1表示，标准C里有EXIT_SUCCESS和EXIT_FAILURE两个宏， 表示正常与异常终止

这些函数的使用都是非常简单的，只需要在需要终止的地方调用一下即可，此处就不深入讲解。
## 8 等待进程

在某些时候，可能父进程希望知道一个子进程何时结束，或者想要知道子进程结束的状态， 甚至是等待着子进程结束，那么我们可以通过**在父进程中调用wait()或者waitpid()函数让父进程等待子进程的结束**

前面我们了解到，一个进程调用exit()之后，进程并不会立即完全消失，而是变成了一个**僵尸进程（几乎无内存空间，无可执行代码，不能被调度，仅保留其在进程列表的位置）**。该位置记录进程的退出状态等信息给其他进程收集。

无论如何，父进程都要回收这个僵尸进程，因此`调用wait()或者waitpid()函数就是将这些僵尸进程回收，释放进程占用的内存空间，并且了解进程终止的状态信息`。
### 8.1 wait()函数

#### 8.1.1 定义

wait()函数原型如下：
```c
pid_t wait(int *wstatus);
```
- 在被调用的时候，系统将暂停父进程的执行，直到有信号来到或子进程结束， 如果在调用wait()函数时子进程已经结束，则会立即返回子进程结束状态值
-  子进程的结束`状态信息会由参数wstatus返回`，与此同时该函数会返子进程的PID， 它通常是已经结束运行的子进程的PID
- 态信息允许父进程了解子进程的退出状态， 如果不在意子进程的结束状态信息，则参数wstatus可以设成NULL

wait()函数有几点需要注意的地方：
- wait()要与fork()配套出现，如果**在使用fork()之前调用wait()，wait()的返回值则为-1**， 正常情况下wait()的返回值为子进程的PID
- 参数wstatus用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针， 但**如果我们对这个子进程是如何死掉毫不在意，只想把这个僵尸进程消灭掉**， （事实上绝大多数情况下，我们都会这样做），我们就可以设定这个参数为**NULL**

当然，Linux系统提供了关于等待子进程退出状态的一些宏定义， 我们可以使用这些宏定义来直接判断子进程退出的状态：
- WIFEXITED(status) ：如果子进程正常结束，返回一个非零值
- WEXITSTATUS(status)： 如果WIFEXITED非零，返回子进程退出码
- WIFSIGNALED(status) ：子进程因为捕获信号而终止，返回非零值
- WTERMSIG(status) ：如果WIFSIGNALED非零，返回信号代码
- WIFSTOPPED(status)： 如果子进程被暂停，返回一个非零值
- WSTOPSIG(status)： 如果WIFSTOPPED非零，返回一个信号代码

#### 8.1.2 实验代码

```c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main(){
    pid_t pid,child_pid;
    int status;

    pid = fork();

    if(pid<0){
        printf("Error fork\n");
    }
    // 子进程
    else if(pid==0){ 
        printf("I am a child process!, my pid is %d!\n\n",getpid());
        // 子进程暂停3s
        sleep(3);
        printf("I am about to quit the process!\n\n");
        // 子进程正常退出
        exit(0);
    }
    // 父进程
    else {
        // 调用wait，父进程阻塞
        child_pid = wait(&status);

        // 若发现子进程退出，打印出相应情况
        if(child_pid == pid){
            printf("Get exit child process id: %d\n",child_pid);
            printf("Get child exit status: %d\n\n",status);
        }else{
            printf("Some error occured.\n\n");
        }
        exit(0);
    }
}
```

执行结果如下图
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/427067d8e62569c53939f3e38261b181.png)

### 8.2 waitpid()函数

waitpid()函数的作用和wait()函数一样，但它并不一定要等待第一个终止的子进程， 还有其他选项
- 指定等待某个pid的子进程
- 提供一个非阻塞版本的wait()功能

实际上**wait()函数只是 waitpid() 函数的一个特例**，在 Linux内部实现 wait函数时直接调用的就是 waitpid 函数

函数原型如下
```c
pid_t waitpid(pid_t pid, int *wstatus, int options);
```

- pid：要等待的子进程ID，具体含义如下
	- pid<-1：等待进程组号为pid绝对值的任何子进程
	- pid = -1：**等待任何子进程，此时的waitpid()函数就等同于wait()函数**。
	- pid = 0：等待进程组号与目前进程相同的任何子进程， 即等待任何与调用waitpid()函数的进程在同一个进程组的进程。
	- pid > 0：等待指定进程号为pid的子进程。

- wstatus：和wait()函数一致

- options：提供其他选项来控制waitpid函数，如果不想使用，可以设为0
	- WNOHANG：如果pid指定的**子进程没有终止运行**，则**waitpid()函数立即返回0**， 而不是阻塞在这个函数上等待；如果子进程已经终止运行，则立即返回该子进程的进程号与状态信息
	- WUNTRACED：如果**子进程进入了暂停状态**（可能子进程正处于被追踪等情况），则**马上返回**
	- WCONTINUED：如果**子进程恢复通过SIGCONT信号运行**，也会**立即返回**（这个不常用，了解一下即可）

很显然，当waitpid()函数的参数为(子进程pid, status,0)时，waitpid()函数就完全退化成了wait()函数
接下来我们学习Linux内核提供的进程、管道、信号等内核对象，了解这些内核对象的应用有利于
- 知道Linux内核为应用层提供了什么特性
- 有益于后续编程更底层的驱动程序
## 1 简单了解进程

首先在虚拟机中打开一个终端，一般来说Ubuntu中有很多shell终端，而**一个终端就是一个进程**，这些进程独立运行在系统中，互不影响，下图打开了3个Shell终端，终端各自有输入，互不干扰
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/d016705f6916ff11e0f0a54f5e07e6da.png)

- 在shell内调用程序时，对应的程序是在新进程中运行的，运行结束后shell继续工作
- 高级程序员经常在一个程序中同时启用多个协作的进程使得程序可以并行更多任务、使程序更健壮，或者直接利用已有的其他程序，这样让整个系统中运行的进程可以相互配合，而不是独立运行（涉及进程间通信）
## 2 查看进程

即使我们打开虚拟机，没有运行任何程序，进程仍旧会存在，因为系统必须要有进程在处理一些必要的程序，以保证系统能正常运行。

**Linux中是通过检查表记录进程相关信息的，进程表就是一个数据结构/表**（加载在内存中的所有进程的有关信息），这表包括如下信息
- 进程PID：进程表的索引
- 进程状态
- 命令字符串
- 其他ps命令输出的信息

OS通过进程ID对其进行管理，对于Linux系统来说，支持同时运行的进程数只与用于建立进程表项的内存有关，没有具体数量限制，即**内存足够大，理论可以运行无数个进程**。
### 2.1 进程ID

Linux系统中每个进程都会被分配一个唯一的数字编号，称为进程ID（ProcessID，PID）
- 进程ID 是一个16位的正整数， 默认取值范围是从2到32768（可以修改）
- 由Linux在启动新进程的时候自动依次分配，当进程被启动时， 系统将按顺序选择下一个未被使用的数字作为它的PID
- 当PID的数值达到最大时， 系统将重新选择下一个未使用的数值
- 新的PID将重新从2开始，这是因为**PID数字为1的值一般是为特殊进程init保留， 即系统在运行时就存在的第一个进程**，init进程负责管理其他进程
### 2.2 父进程ID

任何进程（除init进程）都是由另一个进程启动的，该进程称为**父进程**，被启动的进程称为子进程

父进程号无法在用户层修改。父进程的进程号（PID）即为子进程的父进程号（PPID）。用户可以通过**调用`getppid()`函数来获得当前进程的父进程号**。

可以使用ps命令去查看系统中的进程情况， ps命令可以显示我们正在运行的进程、其他用户正在运行的进程或者目前在系统上运行的所有进程。
```shell
ps -aux
```

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/e0beea27c8a2079afc8f7df85cf90088.png)

- 编号1的进程为init进程，位于`/sbin/init` 目录中
- 整个系统的进程可不止这一些，由于太多没法截图， 就只展示这小部分的进程
- 在Linux中， ps命令有很多选项，因为它试图与很多不同 UNIX 版本的ps命令兼容， 这些选项决定显示哪些进程以及要显示的信息
  ![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/74eed0ff7d6dc97575c8f361ae8369bc.png)
### 2.3 父进程与子进程

进程启动时，启动进程是新进程的父进程，新进程是启动进程的子进程

每个进程都有一个父进程（除了系统中如“僵尸进程”这种特殊进程外），所以
- 把可以Linux中的进程结构想象为一个树状结构，其中init进程就是树的root
- 也可以把init看做OS的进程管理器，它是其他所有进程的祖先进程
- 所以，其他系统进程要么是由init进程启动的，要么是由被init进程启动的其他进程启动的

**总的来说：** init进程下有很多子进程，这些子进程又可能存在子进程，类似家族一样。系统中所有的父进 程ID被称为PPID，不同进程的父进程是不同的，这个值只是当前进程的父进程的ID，**系统中的父进程与子进 程是相对而言的**，就好比 `爷爷<->爸爸<->儿子` 之间的关系，爸爸相对于爷爷而言是儿子， 相对于儿子而言则是爸爸

为了更加直观看出系统中父进程与子进程，此处我们使用 `pstree` 命令将进程以树状关系列出来
```shell
pstree

#若系统提示command not found，可通过如下指令安装：
sudo apt update
sudo apt install psmisc
```

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/280c0a1f4e720a65e792af08e642efb8.png)

## 3 程序和进程

那么我们写的代码，它是程序 ，是如何变成进程的呢？这时我们需要了解程序和进程之间的关系
### 3.1 程序的概念

程序（program）是一个**普通文件**，是为了完成特定任务而准备好的**指令序列与数据的集合**， 这些指令和数据以”可执行映像”的格式**保存在磁盘**中

例如我们写的代码，经过编译器编译后， 就会生成对应的可执行文件，那么这个就是程序，或者称之为可执行程序。
### 3.2 进程的概念

**进程（process）则是程序执行的具体实例**，比如一个可执行文件，在执行的时候， 它就是一个进程，直到该程序执行完毕。

那么**在程序执行的过程中，它享有系统的资源**， 至少包括进程的运行环境、CPU、外设、内存、进程ID等资源与信息，同样的一个程序， 可以实例化为多个进程，在Linux系统下使用ps命令可以查看到当前正在执行的进程， 当这个可执行程序运行完毕后，进程也会随之被销毁（可能不是立即销毁，但是总会被销毁）

程序并不能单独执行，只有将程序加载到内存中，系统为它分配资源后才能够执行， 这种`正在执行的程序称之为进程`，也就是说`📕进程是系统进行资源分配和调度的一个独立单位`， 每个进程都有自己单独的地址空间

例如在/bin目录下有很多可执行文件，我们打开一个中断就是一个进程，这个进程由bash可执行文件（程序）实例化而来。而一个Linux系统可以打开多个终端， 并且这些终端是独立运行在系统中的
### 3.3 程序变成进程

在Linux系统中，`程序只是个静态的文件`，而`进程是一个动态的实体`， 进程的状态（后续讲解进程状态）会在运行过程中改变，那么问题来了，**程序到底是如何变成一个进程的呢？**

正如我们运行一个程序（可执行文件），通常在Shell中输入命令运行就可以了， 在这运行的过程中包含了程序到进程转换的过程，整个转换过程主要包含以下3个步骤：
- 查找命令对应程序文件的位置
- 使用`fork()`函数启动**一个新进程**
- 在新进程中调用`exec族函数` **装载**程序文件，并**执行**程序文件中的main()函数
### 3.4 总结

总的来说，程序与进程有以下的关系：
**程序**
- 一系列指令序列与数据的集合，一个静态的实体

**进程**
- 程序在某个数据集上的执行过程，一个动态运行的实体，有生命周期
- 因启动而产生，因调度而运行，因等待资源或事件而处于等待状态，因完成任务而销毁
- 进程具有并发性，而程序没有
- 进程是竞争计算机资源的基本单位，而程序不是

**关联**
- `程序和进程不是一一对应的`，一个程序执行在不同的数据集上运行就会成为不同的进程， 可以用进程控制块来唯一地标识系统中的每个进程
- 由于程序没有和数据产生直接的联系，既使是执行不同的数据的程序， 他们的指令的集合依然是一样的，所以无法唯一地标识出这些运行于不同数据集上的程序
- **一个进程肯定有一个与之对应的程序，而且有且只有一个**
- 一个程序有可能没有与之对应的进程（因为这个程序没有被运行）， 也有可能有多个进程与之对应（这个程序可能运行在多个不同的数据集上）
## 4 进程状态

先带领大家看看系统中常见的进程状态， 可以通过ps命令将系统中运行的进程信息打印出来，我们只需要关注STAT那一列的信息即可， 进程的状态非常多种，具体如下图：
```shell
# u选项：显示当前用户相关的进程
# x选项：显示没有bash的进程
ps -ux
```

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/1f3e4690de5b313f8efc8950e9cab621.png)

Linux系统中进程状态说明

| 状态  | 说明                                                                                          |
| --- | ------------------------------------------------------------------------------------------- |
| R   | `运行状态。严格来说，应该是“可运行状态”`，即表示进程在运行队列中，处于正在执行或即将运行状态，只有在该状态的进程才可能在 CPU 上运行，而同一时刻可能有多个进程处于可运行状态。 |
| S   | `可中断的睡眠状态`。处于这个状态的进程因为等待某种事件的发生而被挂起，比如进程在等待信号。                                              |
| D   | `不可中断的睡眠状态`。通常是在等待输入或输出（I/O）完成，处于这种状态的进程不能响应异步信号。                                           |
| T   | `停止状态`。通常是被shell的工作信号控制，或因为它被追踪，进程正处于调试器的控制之下。                                              |
| Z   | `退出状态`。进程成为僵尸进程。                                                                            |
| X   | `退出状态`。进程即将被回收。                                                                             |
| s   | 进程是会话其首进程，即会话的创建者，该会话的第一个进程                                                                 |
| l   | 进程是多线程的。                                                                                    |
| +   | 进程属于前台进程组。                                                                                  |
| <   | 高优先级任务。                                                                                     |
## 5 进程状态转换📕

进程是动态的活动的实例，这其实指的是进程会有很多种运行状态， 一会儿睡眠、一会儿暂停、一会儿又继续执行。

Linux操作系统是一个多用户多任务的操作系统， 但对于**单核的CPU系统**来说，在**某一时刻，只能有一个进程处于运行状态（此处的运行状态指的是占用CPU）**， 其他进程都处于其他状态，等待系统资源，各任务根据调度算法在这些状态之间不停地切换。但由于CPU处理速率较快，使用户感觉每个进程都是同时运行。

下图展示了Linux进程从被启动到退出的全部状态，以及这些状态发生转换时的条件
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/9d6c97fbbdbfa20e48cafa1bf299e02c.png)

**上图的描述**
1. 一个进程的**开始都是由其父进程调用fork函数**开始的，这些进程要么是init进程启动的，要么是init进程的子进程启动的

2. 进程启动后处于可运行状态（此时并未占用CPU运行），该状态的进程是正在进程等待队列中排队（`就绪态`），也可以占用CPU指针运行（`运行态`）

3. 如OS产生进程调度时，就绪态的进程可以占用CPU，然后进入运行态。运行态是有时间限制的，比如10ms（`时间片`）。
	- 当时间片耗光时，如果进程还没有结束运行，就会被OS重新放入等待队列中进入就绪态
	- 就是时间片没耗光，也可被更高优先级的进程抢占，重新回到就绪态

4. 运行态的进程可能会等待某些事件、信号或资源而进入`可中断睡眠态`，如
	- 读取一个管道文件数据而管道为空
	- 进程要获得一个锁资源而当前锁不可获取
	- 进程自己调用slepp函数来强制进入睡眠
	- 不过该状态是可以被中断的，能响应信号，在特定条件后，进入就绪态
5. 运行态的进程还可能进入`不可中断睡眠态`，且不能响应信号，不过状态非常短暂，无法通过ps命令将其显示。一般该状态进程都是在等待输入或输出（I/O）完成，等待完成后自动进入就绪态
6. 运行态进程收到 `SIGSTOP` 或 `SIGTSTP` 其中一个信号时，会进入`暂停态`，此时不再存于调度，系统资源不会释放，直到收到`SIGCONT`信号后重新回到就绪态
	- 典型的情况是使用调试器调试应用程序
	- 收到任何信号状态都会被置于 TASK_TRACED状态（和暂停态的一样的）
7. 进程在完成后会退出，此时进程进入`退出状态`，
	- 正常的退出：main函数内return、调用exit、线程调用pthread_exit
	- 异常的退出：进程被kill信号杀死，不管如何死，内核都会调用do_exit函数让进程进入`僵尸态（僵尸进程）`
	8. 父进程处理僵尸进程时，会将其状态设置为EXIT_DEAD，即`死亡态（退出态）`，便于系统回收僵尸进程的内存空间，避免OOM


**补充1：僵尸进程**
- “僵尸”指的是进程的PCB（Process Control Block，进程控制块）
- **为什么一个进程的死掉之后还要把尸体（PCB）留下？**
	- 进程在退出的时候， 系统会将其退出信息都保存在进程控制块中，比如如果他正常退出，那进程的退出值是什么？ 如果是被信号杀死？那么是哪个信号将其杀死？这些“死亡信息”都被一一封存在该进程的PCB当中， 好让别人可以清楚地知道：我是怎么死的。
- **那谁会关心它是怎么死的呢？**
	- 那就是它的父进程，它的父进程之所以要启动它，很大的原因是要让这个进程去干某一件事情， 现在这个孩子已死，那事情办得如何，因此需要把这些信息保存在进程控制块中，等着父进程去查看这些信息。

**补充2：处理僵尸进程**
- **假如父进程由于太忙而没能及时去处理僵尸进程的时候， 要如何处理？**
	- 可能不同的程序员有不同的处理， 父进程有别的事情要干，不能随时去处理僵尸进程。在这样的情形下，可以考虑使用`信号异步通知机制`， 让一个孩子在变成僵尸的时候，给其父进程发一个信号，父进程接收到这个信号之后， 再对其进行处理，在此之前父进程该干嘛就干嘛
- **假如在子进程变成“僵尸态”之前，它的父进程已经先它而去了（退出）， 那么这个子进程变成僵尸态由谁处理呢？**
	- 如果一个进程的父进程先退出， 那么这个子进程将变成“`孤儿进程`”（没有父进程），那么这个进程将会被他的祖先进程收养（adopt）， 它的祖先进程是init（该进程是系统第一个运行的进程，他的PCB是从内核的启动镜像文件中直接加载的， 系统中的所有其他进程都是init进程的后代）。那么当子进程退出的时候，init进程将回收这些资源。
## 6 启动新进程

在Linux中启动一个进程有多种方法
- 可以使用system()函数，方法简单，效率低下且存在安全风险
- 可以使用fork()函数，复杂，不过提供了更好的弹性、效率和安全性
### 6.1 system() 进程实验

system()函数是C标准库中提供的，它主要是提供了一种**调用其它程序**的简单方法。它产生的结果与从shell中执行这个程序基本相似。

事实上，system()启动了一个运行着/bin/sh的子进程，然后将命令交由它执行，其中/bin/sh是一个shell的一种。

**代码：使用system()函数启动一个新进程ls**
```c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main(){
    pid_t result;
    printf("This is a system demo!\n\n");

    //调用system函数，传入shell命令 ls -l
    result = system("ls -l");

    printf("Done!\n\n");
    return result;
}
```
- 如果系统中shell自身无法运行， system() 函数返回 127
- 如果出现了其它错误，system()函数将返回-1
- 本例没有检查system调用是否真正工作，因为system()函数使用 shell 调用命令， 它受到系统shell自身的功能特性和安全缺陷的限制，因此，并不推荐使用这种方法去启动一个进程

编写makefile文件，是通用的，不做介绍，下面给出代码
```makefile
#生成可执行文件的名称
Target = system_demo
ARCH ?= x86
#编译器CC
#根据传入的参数ARCH，确定使用的编译器
#默认使用gcc编译器
#make ARCH=ARM64 时使用ARM-GCC编译器
ifeq ($(ARCH), x86)
	CC = gcc
else
	CC = aarch64-linux-gnu-gcc
endif
#存放中间文件的路径
build_dir = build_$(ARCH)
#存放源文件的文件夹
src_dir =  sources
#存放头文件的文件夹
inc_dir = includes .

#源文件，递归收集c文件
sources = $(foreach dir,$(src_dir),$(wildcard $(dir)/*.c))
#目标文件（*.o），转换目标文件
objects = $(patsubst %.c,$(build_dir)/%.o,$(notdir $(sources)))
#头文件，收集所有头文件
includes = $(foreach dir,$(inc_dir),$(wildcard $(dir)/*.h))

#目标依赖文件
# 生成.d依赖文件路径
DEP_FILES := $(patsubst %, .%.d,$(objects))
# 过滤已存在的依赖文件
DEP_FILES := $(wildcard $(DEP_FILES))

#判断依赖文件是否存在
ifneq ($(DEP_FILES),)
#如果存在依赖文件，需要导入依赖文件
include $(DEP_FILES)
endif

#编译参数
#指定头文件的路径
CFLAGS = $(patsubst %, -I%, $(inc_dir)) -MD -MF $(@D)/.$(@F).d

#链接过程
$(build_dir)/$(Target) : $(objects)  | create_build
	$(CC) $^ -o $@

#编译工程
#编译src文件夹中的源文件，并将生成的目标文件放在objs文件夹中
$(build_dir)/%.o : $(src_dir)/%.c $(includes) | create_build
	$(CC) -c $(CFLAGS) $< -o $@


#以下为伪目标，调用方式：make 伪目标
#clean：用于Clean Project
#check：用于检查某个变量的值
.PHONY:clean cleanall check create_build
#按架构删除
clean:
	rm -rf $(build_dir)

#全部删除
cleanall:
	rm -rf build_x86 build_arm

#命令前带"@",表示不在终端上输出执行的命令
#这个目标主要是用来调试Makefile时输出一些内容
check:
	@echo $(CFLAGS)
	@echo $(CURDIR)
	@echo $(src_dir)
	@echo $(sources)
	@echo $(objects)


#创建一个新目录create，用于存放过程文件
create_build:
	@mkdir -p $(build_dir)
```

- DEP_FILES讲解

**实验操作：**
```shell
# 编译版本程序
make
# 运行版本程序
./build_ARM64/system_demo
```

程序执行后，是通过调用system()函数启动一个进程输出的结果， 它与我们在shell终端中执行 `ls –l` 命令产生的结果是一致的
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/c019de8e32546bf691965bb15e215783.png)
- 运行结果来看，只用system函数运行完毕后，才会输出Done
- 虽然system()函数很有用，但它有局限性，因为程序必须等待system函数结束后才能继续

当然也可以在命令在后台运行，修改为 `ls -l &`即可，此时system()函数的调用将在shell命令结束后立刻返回。因为它是一个后台运行程序的请求，所以ls程序一启动shell就返回了

**修改代码后实验一下，可以看到下面的现象**
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/af5cee7ea9b58221ba4bec700692bae0.png)
- ls命令未完全输出结果，system函数就结束了（Done字符串先出来）
- 在system()程序退出后，ls命令继续完成它的输出

这类的处理行为往往会给用户带来很大的困惑，也不一定如用户所预料的结果一致， 因此如果读者想要让进程按照自己的意愿执行，就需要能够对它们的行为做更细致的控制， 接下来讲解其他方式启动新的进程。
### 6.2 fork() 进程实验

#### 6.2.1 相关理论

init进程可以启动子进程，它通过fork()函数创建一个完全分离的子进程，这只是init启动子进程的第一步，后续还有其他操作。所以，**fork函数的基础功能就是启动一个子进程**，示意图如下
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/a227c8dc77ed36b2bb129aaa122044b3.png)
- 在父进程中的fork()调用后返回的是新的子进程的PID
- 在子进程的上下文种fork()函数调用返回的是0

使用fork()函数的`本质是将父进程的内容复制一份`，正如细胞分裂一样， 得到的是几乎两个完全一样的细胞，因此这个启动的子进程基本上是父进程的一个复制品， 但子进程与父进程有不一样的地方，它们的联系与区别简单列举如下：

**一致的内容：**
- 进程的地址空间
- 进程上下文、代码段
- 进程堆空间、栈空间、内存信息
- 进程的环境变量
- 标准IO的缓冲区
- 打开的文件描述符
- 信号响应函数
- 当前工作路径

**子进程独有的内容**
- 进程号PID
- 记录锁：父进程对某文件加了把锁，子进程不会继承这把锁
- 挂起信号：已经响应但尚未处理的信号，也就是”悬挂”的信号， 子进程也不会继承这些信号

**这种复制存在一个很大的问题，就是资源和时间消耗很大，因为会做如下事情：**
- 为子进程的页表分配页面
- 为子进程的页分配页面
- 初始化子进程的页表
- 把父进程的页复制到子进程相应的页中
创建一个地址空间又涉及到许多内存访问，消耗很多CPU周期，并且完全破坏了高速缓存中的内容，因此直接复制物理内存对OS的开销影响很大

#### 6.2.2 写时复制（COW）

*更重要的是，上述直接拷贝是毫无意义的*，因为许多子进程通过装入一个新的程序开始它们的指向，这样就完全丢弃了继承的地址空间。所以在Linux中引入一种`写时复制技术（Copy On Write，简称COW）`

前面我们学过，Linux系统中的进程使用的是*虚拟内存地址*，虚拟地址和真实物理地址存在映射关系，每个进程都有自己的虚拟地址空间，操作虚拟地址明显比直接操作物理内存更加简便快捷，**所以，写时复制技术是可以推迟甚至避免复制数据的技术**，*内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间（页面）*

**写时复制的思想：**
- `父进程和子进程共享页面而不是复制页面`
- 无论父进程和子进程何时试图向一个共享的页面写入内容时， 都会产生一个错误，这时内核就把这个页复制到一个新的页面中并标记为可写
- 原来的页面仍然是写保护的，当还有进程试图写入时，内核检查写进程是否是这个页面的唯一属主， 如果是则把这个页面标记为对这个进程是可写的

所以，**写时复制只会在需要写入的时候才会复制地址空间**，资源的复制是在需要写入时才会进行，在次之前，父进程和子进程都是以只读方式共享页面，这样使得地址空间上的页拷贝推迟到实际发生写入的时候。

绝大多数的时候共享的页面根本不会被写入，例如，在调用fork()函数后立即执行exec()， 地址空间就无需被复制了，这样一来**fork()的实际开销就是复制父进程的页表以及给子进程创建一个进程描述符**

理论相关的知识了解至此即可，下面就看看fork()函数的使用，它的函数原型如下：
```c
pid_t fork(void);
```
- 在fork()启动新的进程后，子进程与父进程开始并发执行，谁先执行由内核调度算法来决定
-  fork()函数如果成功启动了进程，会对父子进程各返回一次，其中对父进程返回子进程的PID，对子进程返回0。如果fork()函数启动子进程失败，它将返回-1
- 失败通常是因为父进程所拥有的子进程数目超过了规定的限制（CHILD_MAX）， 此时errno将被设为`EAGAIN`
- 如果是因为进程表里没有足够的空间用于创建新的表单或虚拟内存不足， errno变量将被设为`ENOMEM`

#### 6.2.3 相关实验

使用fork函数启动一个新进程，并且在进程中打印相关信息，如在父进程中打印出"In father process!!"
```c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main(){
    pid_t res;
    printf("This is a fork demo!\n\n");
    // 调用fork函数
    res = fork();

    // 判断fork函数是否成功
    if(res == -1){
        printf("Fork error\n");
        //返回值0，表示子进程
    } else if(res == 0){
        printf("The returned value is %d, In child process!! My PID is %d\n\n", result, getpid());
        //返回值大于 0 代表父进程
    } else {
        printf("The returned value is %d, In father process!! My PID is %d\n\n", result, getpid());
    }
    return res;
}
```

makefile文件一样，照抄即可

**实验操作：**
```shell
make
```

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/3bf257f5152b5afe312293621cf87128.png)
- 父进程的返回值就是子进程的PID，而子进程的返回值则是0
- 子进程并不会再次执行fork()函数之前的内容，而fork()函数之后的内容在父进程和子进程都会执行一遍
### 6.3 exec 系列函数进程实验

#### 6.3.1 execl函数演示

事实上，使用fork()函数启动一个子进程是并没有太大作用的，因为子进程跟父进程都是一样的， 子进程能干的活父进程也一样能干，要想子进程做不一样的事情，就需要使用`exec系列函数`
- **主要是用于替换进程的执行程序**，即指定可执行文件，并用其取代原调用进程的数据段、代码段和堆栈段，在执行完之后，*原调用进程的内容除了进程号外，其他全部被新程序的内容替换*
- 可执行文件既可以是二进制文件，也可以是Linux下任何可执行脚本文件

简单来说，就是**覆盖进程**，举个例子
- A进程通过exec系列函数启动一个进程B，此时进程B会替换进程A， 进程A的内存空间、数据段、代码段等内容都将被进程B占用，然后进程A将不复存在

**实验分析**：通过execl()函数进行讲解
```c
int execl(const char *path, const char *arg, ...)
```
- path：文件路径（必须指定）
- arg：一系列可变参数，代表指向文件传递过去的`argv[0]、argv[1]… argv[n]`
- 最后一个参数必须用NULL作为结束的标记

```c
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>

int main(){
    int err;
    printf("this is a execl function test demo!\n\n");

    err = execl("bin/ls","ls","-la",NULL);

    if(err<0){
        printf("execl error!\n");
    }

    printf("Done!\n");
    return 0;
}
```
- 其实就是与我们在终端上运行”ls -la”产生的结果是一样的

**执行make编译c文件后，执行程序**
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/bf92053cf30d91b8acfac7b98c900f25.png)

**💡提示：** 
- exec系列函数是直接将当前进程替换掉，所以示例程序中的 done 不会被输出
- 一般情况下，exec系列函数是不会返回的，除非发生错误，返回-1，并会设置错误变量errno

所以，**我们可以fork复制启动一个子进程，并且在子进程中调用exec系列函数替换子进程**，它们结合在一起就是创建一个新进程所需要的一切了
#### 6.3.2 exec族其他函数

exec族实际包含有 6 个不同的 exec 函数，它们功能一样，主要是传参的形式不同， 函数原型分别如下：
```c
int execl(const char *path, const char *arg, ...)

int execlp(const char *file, const char *arg, ...)

int execle(const char *path, const char *arg, ..., char *const envp[])

int execv(const char *path, char *const argv[])

int execvp(const char *file, char *const argv[])

int execve(const char *path, char *const argv[], char *const envp[])
```

**上面函数可以分为两大类：**
- execl、execlp和execle传递给子程序的参数个数是可变的
- execv、execvp和execve通过数组去装载子程序的参数
- 无论那种形式，参数都以一个空指针NULL结束

总的来说，可以通过后缀来区分它们的作用：
- 包含 `l` 字母，接收参数列表（list）
- 包含 `p` 字母，接收程序名（在PATH或当前路径搜索）
- 包含 `v` 字母，接收数组（Vector）
- 包含 `e` 字母，多接收一个指明环境变量列表的参数，即envp传递字符串数组作为新程序的环境变量，envp所指的字符串数组应该以NULL指针作为结束，每个字符串的形式为 `environment = virables`
## 7 终止进程

Linux系统中，进程终止的常见方式有5种，可以分为正常终止和异常终止
**正常终止**
- main函数返回
- 调用exit函数终止
- 调用_exit函数终止

**异常终止**
- 调用abort函数异常终止
- 由系统信号终止

**exit描述**
- `exit()`函数定义在stdlib.h中，`_exit()`函数定义在unistd.h中，都是用来终止进程的
- 当程序执行到上面两个函数时，进程会无条件停止剩下的操作，清除包括PCB在内的各种数据结构，并终止当前进程的运行
- 不过这两个函数还是有区别的，图下图
  ![image.png|200](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/377616889e5234d8cd27b84f11c89a34.png)
	- `_exit()`函数最简单：直接通过系统调用使进程终止运行
	- `exit()`函数在上面的基础上做了包装，如检查文件打开情况，把文件缓冲区的内容写会文件，即 **清除IO缓冲**
- 不管是那种退出方式，系统最终都会执行内核中的同一代码，这段代码用来关闭进程所用已打开的文件描述符， 释放它所占用的内存和其他资源

**缓冲 I/O（buffered I/O）操作**
- 特点：每打开一个文件，内存都有一篇缓冲区
- 读文件时，连续读若干条记录，这样下次读可以直接从内存缓冲区读取
- 写文件时，只写入内存缓冲区，满足一定条件后，再把缓冲区内容一次性写入文件
- **优点**：大大增加了文件读写的速度
- **缺点**：用`_exit()函数`直接将进程关闭，缓冲区中的数据就会丢失
- **解决**：若想保证数据的完整性，就一定要使用exit()函数

**函数使用**
```c
#include <unistd.h>
#include <stdlib.h>

void _exit(int status);
void exit(int status);
```

**参数status：**
- 表示的是进程终止时的状态码，0表示正常终止， 其他非0值表示异常终止
- 一般都可以使用-1或者1表示，标准C里有EXIT_SUCCESS和EXIT_FAILURE两个宏， 表示正常与异常终止

这些函数的使用都是非常简单的，只需要在需要终止的地方调用一下即可，此处就不深入讲解。
## 8 等待进程

在某些时候，可能父进程希望知道一个子进程何时结束，或者想要知道子进程结束的状态， 甚至是等待着子进程结束，那么我们可以通过**在父进程中调用wait()或者waitpid()函数让父进程等待子进程的结束**

前面我们了解到，一个进程调用exit()之后，进程并不会立即完全消失，而是变成了一个**僵尸进程（几乎无内存空间，无可执行代码，不能被调度，仅保留其在进程列表的位置）**。该位置记录进程的退出状态等信息给其他进程收集。

无论如何，父进程都要回收这个僵尸进程，因此`调用wait()或者waitpid()函数就是将这些僵尸进程回收，释放进程占用的内存空间，并且了解进程终止的状态信息`。
### 8.1 wait()函数

#### 8.1.1 定义

wait()函数原型如下：
```c
pid_t wait(int *wstatus);
```
- 在被调用的时候，系统将暂停父进程的执行，直到有信号来到或子进程结束， 如果在调用wait()函数时子进程已经结束，则会立即返回子进程结束状态值
-  子进程的结束`状态信息会由参数wstatus返回`，与此同时该函数会返子进程的PID， 它通常是已经结束运行的子进程的PID
- 态信息允许父进程了解子进程的退出状态， 如果不在意子进程的结束状态信息，则参数wstatus可以设成NULL

wait()函数有几点需要注意的地方：
- wait()要与fork()配套出现，如果**在使用fork()之前调用wait()，wait()的返回值则为-1**， 正常情况下wait()的返回值为子进程的PID
- 参数wstatus用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针， 但**如果我们对这个子进程是如何死掉毫不在意，只想把这个僵尸进程消灭掉**， （事实上绝大多数情况下，我们都会这样做），我们就可以设定这个参数为**NULL**

当然，Linux系统提供了关于等待子进程退出状态的一些宏定义， 我们可以使用这些宏定义来直接判断子进程退出的状态：
- WIFEXITED(status) ：如果子进程正常结束，返回一个非零值
- WEXITSTATUS(status)： 如果WIFEXITED非零，返回子进程退出码
- WIFSIGNALED(status) ：子进程因为捕获信号而终止，返回非零值
- WTERMSIG(status) ：如果WIFSIGNALED非零，返回信号代码
- WIFSTOPPED(status)： 如果子进程被暂停，返回一个非零值
- WSTOPSIG(status)： 如果WIFSTOPPED非零，返回一个信号代码

#### 8.1.2 实验代码

```c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main(){
    pid_t pid,child_pid;
    int status;

    pid = fork();

    if(pid<0){
        printf("Error fork\n");
    }
    // 子进程
    else if(pid==0){ 
        printf("I am a child process!, my pid is %d!\n\n",getpid());
        // 子进程暂停3s
        sleep(3);
        printf("I am about to quit the process!\n\n");
        // 子进程正常退出
        exit(0);
    }
    // 父进程
    else {
        // 调用wait，父进程阻塞
        child_pid = wait(&status);

        // 若发现子进程退出，打印出相应情况
        if(child_pid == pid){
            printf("Get exit child process id: %d\n",child_pid);
            printf("Get child exit status: %d\n\n",status);
        }else{
            printf("Some error occured.\n\n");
        }
        exit(0);
    }
}
```

执行结果如下图
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/427067d8e62569c53939f3e38261b181.png)

### 8.2 waitpid()函数

waitpid()函数的作用和wait()函数一样，但它并不一定要等待第一个终止的子进程， 还有其他选项
- 指定等待某个pid的子进程
- 提供一个非阻塞版本的wait()功能

实际上**wait()函数只是 waitpid() 函数的一个特例**，在 Linux内部实现 wait函数时直接调用的就是 waitpid 函数

函数原型如下
```c
pid_t waitpid(pid_t pid, int *wstatus, int options);
```

- pid：要等待的子进程ID，具体含义如下
	- pid<-1：等待进程组号为pid绝对值的任何子进程
	- pid = -1：**等待任何子进程，此时的waitpid()函数就等同于wait()函数**。
	- pid = 0：等待进程组号与目前进程相同的任何子进程， 即等待任何与调用waitpid()函数的进程在同一个进程组的进程。
	- pid > 0：等待指定进程号为pid的子进程。

- wstatus：和wait()函数一致

- options：提供其他选项来控制waitpid函数，如果不想使用，可以设为0
	- WNOHANG：如果pid指定的**子进程没有终止运行**，则**waitpid()函数立即返回0**， 而不是阻塞在这个函数上等待；如果子进程已经终止运行，则立即返回该子进程的进程号与状态信息
	- WUNTRACED：如果**子进程进入了暂停状态**（可能子进程正处于被追踪等情况），则**马上返回**
	- WCONTINUED：如果**子进程恢复通过SIGCONT信号运行**，也会**立即返回**（这个不常用，了解一下即可）

很显然，当waitpid()函数的参数为(子进程pid, status,0)时，waitpid()函数就完全退化成了wait()函数