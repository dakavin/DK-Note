---
文章标题: "[[3_Linux系统下的程序]]"
文章作者: Dakkk
文章概要: |
  深入剖析Linux系统下Hello World程序的完整执行流程，从GCC编译链接到内核加载、glibc库服务，对比裸机开发揭示操作系统的工作机制
tags:
  - Linux系统编程
  - Hello World
  - GCC编译
  - 动态链接
  - 系统调用
  - glibc库
  - 程序加载
  - 进程创建
相关文章:
  - "[[../../../../05-💻 Linux应用开发与系统编程/2_Linux上层应用编程(迅为)/0_Linux系统编程]]"
  - "[[2_程序编译GCC📕]]"
  - "[[../4_补充部分/2_open和mkdir函数中的mode]]"
  - "[[3_环境搭建]]"
  - "[[../../../../05-💻 Linux应用开发与系统编程/2_Linux上层应用编程(迅为)/1_文件IO和标准IO]]"
文章分类: 🐧 Linux系统
文章路径: 06-🐧 Linux系统/04-🔌 驱动开发/02-💾 Lubancat-RK3568/3_Linux基础与应用开发实战/2_使用板卡开发C程序/3_Linux系统下的程序.md
文章难度: 中级 🌳
目前阶段: ✅ 已完成
重要性: ⭐⭐⭐⭐ 核心能力
创建时间: 2025-05-06 17:05:46
修改时间: 2025-05-28 00:19:51
---


前面的章节主要是借助它来给大家介绍GCC编译工具链，并没有涉及太多**Hello World程序的核心**。 
- 这里可能你会疑惑:Hello World程序有啥核心？
- 但是如果你对Hello World程序掉以轻心，那你就错了。
- 如果我们深入思考一个简单的“Hello World程序”，就会发现很多问题看似简单， 但是实质上我们并没有一个非常清晰的思路，准确来说，应该大部分人脑海中都有一些模糊的印象， 但是真正深入到细节中去的时候，可能又模糊不清了。

**“Hello World程序”是一个典型的案例，我们搞懂它在Linux系统下的运行机制，对我们以后开发其他程序， 有非常好的借鉴意义。尤其是当你的程序编译链接出错的时候，可以清晰地判断问题出现在哪个环节。 而不用再一脸懵逼地复制各种报错的信息，到谷歌百度中苦苦寻找解决方法。**

下面以“裸机下的Hello World”为比较对象，给大家扒一扒“Linux系统下的Hello World”。 **在接下来的分析内容里面，大家重点把握整个执行流程。在没有对Linux系统有深入研究之前， 千万不要陷进去其中的大部分细节。在学习初期，掌握宏观思想已经很不错了， 足以指导我们以后进一步学习其他内容**。
## 1 裸机下的HW

在单片机中，实现Hello World程序的步骤并不复杂，下面的这张图片基本上涵括了全部的开发过程，非常清晰:
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/6eafd50be4140230591eb8b04a5caa12.png)
- 第一步：源代码编写，关键点是printf函数的实现（依赖单片机的串口驱动程序）
- 第二步：借助集成开发环境进行程序的编译（一键编译，无需学习编译链接相关知识）
- 第三步：借助烧录工具烧录到具体芯片（一键烧录，无需学习芯片的flash和各种各样启动方式）
- 第四步：上电启动板卡，串口输出"hello world！"字符串
## 2 Linux下的HW

上面谈到了裸机开发Hello World，其实它也涉及到很多编译链接和烧录的知识，但是因为裸机程序不是本章节的重点， 在这里不适合展开来讲。而我们Linux系统下的Hello World，则是因为它的借鉴意义非常强， 对我们以后进一步学习其他课程起到很好的指导作用，所以在这里会尽可能详细剖析它整体的工作原理。

我们先来看Linux系统下，Hello World程序的流程图，如下所示:
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/0a6283f8fbce777a5f6b9367ca8c25ad.png)

总体上整个程序的编译执行过程，可以按图片从上到下的顺序，分为四大部分的内容：
- 程序的编译
- Linux内核提供的服务
- glibc库提供的服务
- 用户程序

下面对每一个子步骤进行讲解：
**gcc处理阶段**
1. 预处理hello.c，主要是处理程序里面的文件包含、处理宏定义、条件编译
2. 把c文件编译成为汇编文件(`.s`)，其中进行了词法、语法和语义分析，生成中间代码，对代码进行优化等工作
3. 把汇编文件(`.s`)编译成可重定位文件(`.o`)
4. 把可重定位文件(`.o`)链接称为可执行文件，其中链接可分为静态链接和动态链接

**Shell命令阶段**
- 控制台输入 `./hello` 命令后，Shell会创建一个新的进程来执行该程序。

**Linux Kernel阶段**
5. fork()函数是用于创建一个新的进程的。可以简单理解为程序的容器
6. exeve()函数可以理解为在这个进程（容器）内，填充一个可执行程序（hello）
7. sys_exeve()函数为Linux系统调用，被exeve()函数调用，这里系统调用可以理解为OS系统开放给用户的最底层接口
8. do_exeve()函数是sys_exeve()函数的核心
9. **load_elf_binary()函数会去文件系统中读取hello程序到内存**，然后**判断**它是否是动态链接的可执行程序，如果不是，则进一步判断是否是静态链接的文件

**glibc库相关**
- ld-linux-xx.so是glibc库中的动态链接器。
	10. hello是动态链接程序，该链接器会去加载共享库，完成共享库和程序的链接工作，准备真正开始执行hello程序
	11. hello是静态链接程序，无需加载链接共享库，直接开始准备执行hello程序

12. `__libc_start_main()`也是glibc中的函数，用于执行用户程序前进行的一些**初始化工作**
13. 调用用户程序中的main()函数，开始执行printf打印函数
14. 程序执行完后，调用glibc库中的 `_exit()` 函数，结束当前进程

对比裸机和linux系统下的“Hello World”,很明显可以看到操作系统为我们做了大量的工作， 甚至为了节省内存空间，还把程序的链接这种非常基础性的工作，交给了glibc中的动态连接器来完成。 避免静态链接的那种低效的开发方式，这是裸机开发难以做到的。

大家可能会对里面的内容有很多陌生的地方，也可能有很多疑惑的地方， 但是这里面的内容实在没有办法展开来讲，每个子步骤的后面都是一个庞然大物。如果在这个地方耗费过多精力， 势必会大大耽误学习的进度。对于深入高阶的内容，还是需要循序渐进的。

但是另一方面，脑海中有了程序执行的整体轮廓之后，我们以后的学习和编程， 就有了指导和前进的方向。我们对程序开发过程中，进行的每个步骤就了然于胸。这才是我们这个章节的意义所在。
