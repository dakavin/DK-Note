
背景：

字符设备驱动通常适用于相对简单的设备，对于一些更复杂的功能，比如说电源管理和热插拔事件管理，使用字符设备框架可能不够灵活和高效。为了应对更复杂的设备和功能，Linux 内核提供了设备模型。

## 驱动模型1.0：字符设备

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/3b6f06992708e315f6e66f3ca84c0985.png)

## 驱动模型2.0：platform

设备模型允许开发人员以更高级的方式来描述硬件设备和它们之间的关系，并提供一组通用 API 和机制来处理设备的注册，热插拔事件，电源管理等。

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/df011f4fb9b63ef648d18c5134101c2f.png)


好处：代码稍微复杂，但是易于扩展。

坏处：冗余代码太多，修改引脚时设备端的代码需要重新编译。

## 驱动模型3.0：设备树

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/f91b1e58bfeb6b9926652238dc87715c.png)


通过配置文件──设备树来定义“资源”。代码稍微复杂，但是易于扩展。

无冗余代码，修改引脚时只需要修改 dts 文件并编译得到 dtb 文件，把它传给内核。

无需重新编译内核/驱动。

## 设备模块的好处


设备模型在内核驱动中扮演着重要的角色，它提供了一种统一的方式来描述硬件设备和它 们之间的关系。以下是设备模型在内核驱动中的几个重要方面。

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/181221351a76a61d18c0c4975b2dface.png)


1. **代码复用：**
    

设备模型**允许多个设备复用同一个驱动**。通过在设备树或总线上定义不同的设备节点，这些设备可以使用相同的驱动进行初始化和管理。这样可以减少代码的冗余，提高驱动的复用性和维护性。

2. **资源的动态申请和释放：**
    

设备模型提供了一种机制来动态申请和释放设备所需的资源， 如内存，中断等。驱动可以使用这些机制来管理设备所需的资源，确保在设备初始化和关闭时进行正确的资源分配和释放。

3. **简化驱动编写:**
    

设备模型提供了一组通用 API 和机制，使得驱动编写更加简化和模块化。

开发人员可以使用这些 API 来注册设备，处理设备事件，进行设备的读写操作等，而无需重复实现这些通用功能。

4. **热插拔机制：（hotpulg/uevent）**
    

设备模型支持热插拔机制，能够在运行时动态添加或移除设备。当设备插入或拔出时，内核会生成相应的热插拔事件，驱动可以通过监听这些事件来执行相应的操作，如设备的初始化或释放。

5. **驱动的面向对象思想：(USB、platform、I2C)**
    

设备模型的设计借鉴了面向对象编程（OOP）的思想。每个设备都被看作是一个对象，具有自己的属性和方法，并且可以通过设备模型的机制进行继承和扩展。

这种设计使得驱动的编写更加模块化和可扩展，可以更好地应对不同类型的设备和功能需求。

总之，设备模型在内核驱动中扮演着关键的角色，通过提供统一的设备描述和管理机制，简化了驱动的编写和维护过程，提高了代码的复用性和可维护性，并支持热插拔和动态资源管理等重要功能。