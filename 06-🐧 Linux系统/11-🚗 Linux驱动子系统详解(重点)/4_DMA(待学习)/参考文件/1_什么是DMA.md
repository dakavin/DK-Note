📢本篇将带领大家深刻理解`DMA`。

## 什么是DMA

> DMA (Direct Memory Access) is used to copy data directly between devices and RAM, without going through the CPU.

DMA是Direct Memory Access的缩写，顾名思义，就是绕开CPU直接访问memory的意思。在计算机中，相比CPU，memory和外设的速度是非常慢的，因而在memory和memory（或者memory和设备）之间搬运数据，非常浪费CPU的时间，造成CPU无法及时处理一些实时事件。因此，工程师们就设计出来一种专门用来搬运数据的器件----DMA控制器，协助CPU进行数据搬运。

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/eece2154142d30599b822e4af2f8c56a.png)


## DMA的产生：背景

过去几年里，整个计算机产业界，都在尝试不停地提升 `I/O` 设备的速度。把 `HDD` 硬盘换成 `SSD` 硬盘，我们仍然觉得不够快；用 `PCI Express` 接口的 `SSD` 硬盘替代 `SATA` 接口的 `SSD` 硬盘，我们还是觉得不够快。

所以，现在就有了傲腾（`Optane`）这样的技术。但是，无论 `I/O` 速度如何提升，比起 `CPU`，总还是太慢。`SSD` 硬盘的 `IOPS` 可以到 `2` 万、`4` 万，但是我们 `CPU` 的主频有 `2GHz` 以上，也就意味着每秒会有 `20` 亿次的操作。如果我们对于 `I/O` 的操作，都是由 `CPU` 发出对应的指令，然后等待 `I/O` 设备完成操作之后返回，那 `CPU` 有大量的时间其实都是在等待 `I/O` 设备完成操作。

但是，这个 `CPU` 的等待，在很多时候，其实并没有太多的实际意义。我们对于 `I/O` 设备的大量操作，其实都只是把内存里面的数据，传输到 `I/O` 设备而已。在这种情况下，其实 `CPU` 只是在傻等而已。特别是当传输的数据量比较大的时候，比如进行大文件复制，如果所有数据都要经过 `CPU`，实在是有点儿太浪费时间了。因此，计算机工程师们，就发明了 `DMA` 技术，也就是直接内存访问（`Direct Memory Access`）技术，来减少 `CPU` 等待的时间。

## 理解 DMA：协处理器

其实 `DMA` 技术很容易理解，本质上，`DMA` 技术就是我们在主板上放一块独立的芯片。在进行内存和 `I/O` 设备的数据传输的时候，我们不再通过 `CPU` 来控制数据传输，而直接通过 `DMA` 控制器（`DMA Controller`，简称 `DMAC`）。这块芯片，我们可以认为它其实就是一个协处理器（Co-Processor）。

**`DMAC`** **最有价值的地方体现在，当我们要传输的数据特别大、速度特别快，或者传输的数据特别小、速度特别慢的时候。**

比如说，我们用千兆网卡或者硬盘传输大量数据的时候，如果都用 `CPU` 来搬运的话，肯定忙不过来，所以可以选择 `DMAC`。而当数据传输很慢的时候，`DMAC` 可以等数据到齐了，再发送信号，给到 `CPU` 去处理，而不是让 `CPU` 在那里忙等待。

好了，现在你应该明白 `DMAC` 的价值，知道了它适合用在什么情况下。那我们现在回过头来看。我们上面说，`DMAC` 是一块“协处理器芯片”，这是为什么呢？

注意，这里面的“协”字。`DMAC` 是在“协助”`CPU`，完成对应的数据传输工作。在 `DMAC` 控制数据传输的过程中，我们还是需要 `CPU` 的。

除此之外，`DMAC` 其实也是一个特殊的 `I/O` 设备，它和`CPU` 以及其他 `I/O` 设备一样，通过连接到总线来进行实际的数据传输。总线上的设备呢，其实有两种类型。一种我们称之为主设备（`Master`），另外一种，我们称之为从设备（`Slave`）。

想要主动发起数据传输，必须要是一个主设备才可以，`CPU` 就是主设备。而我们从设备（比如硬盘）只能接受数据传输。所以，如果通过 `CPU` 来传输数据，要么是 `CPU` 从 `I/O` 设备读数据，要么是 `CPU` 向 `I/O` 设备写数据。

这个时候你可能要问了，那我们的 `I/O` 设备不能向主设备发起请求么？可以是可以，不过这个发送的不是数据内容，而是控制信号。`I/O` 设备可以告诉 `CPU`，我这里有数据要传输给你，但是实际数据是 `CPU` 拉走的，而不是 `I/O` 设备推给 CPU 的。

![](https://ncn13z89mqjm.feishu.cn/space/api/box/stream/download/asynccode/?code=MTRkZjBhOWMzMzIxZmY2MzAxOGZlMzAzYWI1ZGFkZmVfVGp1MTR6aDRSSG42Q3h5OE44M1pyUldGZlNEb2U2NklfVG9rZW46VHZIUmJzYnVTb2syeTN4dUZKYmN0UE9ibmdoXzE3NTA5MjkxMzE6MTc1MDkzMjczMV9WNA)

不过，`DMAC` 就很有意思了，它既是一个主设备，又是一个从设备。对于 `CPU` 来说，它是一个从设备；对于硬盘这样的 `IO` 设备来说呢，它又变成了一个主设备。那使用 `DMAC` 进行数据传输的过程究竟是什么样的呢？下面我们来具体看看。

1. 首先，`CPU` 还是作为一个主设备，向 `DMAC` 设备发起请求。这个请求，其实就是在 `DMAC` 里面修改配置寄存器。
    
2. `CPU` 修改 `DMAC` 的配置的时候，会告诉 `DMAC` 这样几个信息：
    

- 首先是源地址的初始值以及传输时候的地址增减方式。所谓源地址，就是数据要从哪里传输过来。如果我们要从内存里面写入数据到硬盘上，那么就是要读取的数据在内存里面的地址。如果是从硬盘读取数据到内存里，那就是硬盘的 `I/O` 接口的地址。我们讲过总线的时候说过，`I/O` 的地址可以是一个内存地址，也可以是一个端口地址。而地址的增减方式就是说，数据是从大的地址向小的地址传输，还是从小的地址往大的地址传输。
    
- 其次是目标地址初始值和传输时候的地址增减方式。目标地址自然就是和源地址对应的设备，也就是我们数据传输的目的地。
    
- 第三个自然是要传输的数据长度，也就是我们一共要传输多少数据。
    

1. 设置完这些信息之后，`DMAC` 就会变成一个空闲的状态（`Idle`）。
    
2. 如果我们要从硬盘上往内存里面加载数据，这个时候，硬盘就会向 `DMAC` 发起一个数据传输请求。这个请求并不是通过总线，而是通过一个额外的连线。
    
3. 然后，我们的 `DMAC` 需要再通过一个额外的连线响应这个申请。
    
4. 于是，`DMAC` 这个芯片，就向硬盘的接口发起要总线读的传输请求。数据就从硬盘里面，读到了 `DMAC` 的控制器里面。
    
5. 然后，`DMAC` 再向我们的内存发起总线写的数据传输请求，把数据写入到内存里面。
    
6. `DMAC` 会反复进行上面第 `6`、`7` 步的操作，直到 `DMAC` 的寄存器里面设置的数据长度传输完成。
    
7. 数据传输完成之后，`DMAC` 重新回到第 `3` 步的空闲状态。
    

所以，整个数据传输的过程中，我们不是通过 `CPU` 来搬运数据，而是由 `DMAC` 这个芯片来搬运数据。但是 `CPU` 在这个过程中也是必不可少的。因为传输什么数据，从哪里传输到哪里，其实还是由 `CPU` 来设置的。这也是为什么，`DMAC` 被叫作“协处理器”。

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/04f9712a4573f4e977fa3259c350406a.png)

最早，计算机里是没有 `DMAC` 的，所有数据都是由 `CPU` 来搬运的。随着人们对于数据传输的需求越来越多，先是出现了主板上独立的 `DMAC` 控制器。到了今天，各种 `I/O` 设备越来越多，数据传输的需求越来越复杂，使用的场景各不相同。加之显示器、网卡、硬盘对于数据传输的需求都不一样，所以各个设备里面都有自己的 `DMAC` 芯片了。