
## 1 ç”Ÿæ•ˆæ—¶æœº-really_probe

**æ ¸å¿ƒé—®é¢˜ï¼špinctrlå­ç³»ç»Ÿæ˜¯ä»€ä¹ˆæ—¶å€™å¯¹å¼•è„šè¿›è¡Œå¤ç”¨çš„ï¼Ÿ**

**ç­”æ¡ˆï¼šåœ¨è®¾å¤‡ä¸é©±åŠ¨åŒ¹é…åï¼Œprobeå‡½æ•°æ‰§è¡Œä¹‹å‰ï¼**

åœ¨pinctrlå­ç³»ç»Ÿçš„å®ç°ä¸­ï¼Œå€ŸåŠ©è®¾å¤‡é©±åŠ¨æ¨¡å‹ä¸­çš„`driver_probe_device`æ¥å£ï¼Œå½“deviceä¸driver **matchå**ï¼Œåœ¨`driver_probe_device`->`really_probe`çš„æ¥å£ä¸­ï¼Œåœ¨è°ƒç”¨busçš„probeæ¥å£ä¹‹å‰ï¼Œé€šè¿‡è°ƒç”¨`pinctrl_bind_pins`æ¥å£å®ç°devä¸pinctrlå­ç³»ç»Ÿçš„ç»‘å®šï¼Œå¹¶å®Œæˆpinç›¸å…³çš„å¤ç”¨ä¸é…ç½®æ“ä½œã€‚

è¿›å…¥é©±åŠ¨çš„probeå‡½æ•°ä¹‹å‰å°±å·²ç»ä½¿ç”¨pinctrlå­ç³»ç»Ÿå¯¹å¼•è„šè¿›è¡Œäº†å¤ç”¨ï¼Œåœ¨å‰é¢è®¾å¤‡æ¨¡å‹çš„å­¦ä¹ ä¸­ï¼Œæˆ‘ä»¬å·²ç»çŸ¥é“äº†é©±åŠ¨ä¸­çš„probeå‡½æ•°æ˜¯åœ¨å†…æ ¸æºç ç›®å½•ä¸‹çš„`drivers/base/dd.c`æ–‡ä»¶ä¸­åŠ è½½æ‰§è¡Œçš„ï¼Œç„¶åæ‰¾åˆ°really probeå‡½æ•°ä¸­ä¸probeå‡½æ•°åŠ è½½ç›¸å…³çš„ä»£ç ï¼Œå…·ä½“å†…å®¹å¦‚ä¸‹æ‰€ç¤ºï¼š
```c fold
// drivers/base/dd.c
static int really_probe(struct device *dev, struct device_driver *drv)
{
        int ret = -EPROBE_DEFER;
        int local_trigger_count = atomic_read(&deferred_trigger_count);
        bool test_remove = IS_ENABLED(CONFIG_DEBUG_TEST_DRIVER_REMOVE) &&
                           !drv->suppress_bind_attrs;
        // ... å…¶ä»–å‡†å¤‡å·¥ä½œ ...
        
  re_probe:
        dev->driver = drv;

        /* If using pinctrl, bind pins now before probing */
        // ğŸ”¥ å…³é”®ç‚¹ï¼šåœ¨probeä¹‹å‰è‡ªåŠ¨é…ç½®pinctrl
        ret = pinctrl_bind_pins(dev); // ç»‘å®šè®¾å¤‡çš„å¼•è„š
        if (ret)
                goto pinctrl_bind_failed;
                
        // ğŸ”¥ ç„¶åæ‰è°ƒç”¨é©±åŠ¨çš„probeå‡½æ•°
        if (dev->bus->probe) {
                ret = dev->bus->probe(dev);
                if (ret)
                        goto probe_failed;
        } else if (drv->probe) {
                ret = drv->probe(dev);
                if (ret)
                        goto probe_failed;
        }
        // ... åç»­å¤„ç† ...
}
```
**æ‰§è¡Œé¡ºåºï¼š**
1. è®¾å¤‡ä¸é©±åŠ¨åŒ¹é…æˆåŠŸ
2. è°ƒç”¨`really_probe()`
3. æ‰§è¡Œ`pinctrl_bind_pins(dev)` â† **åœ¨è¿™é‡Œå®Œæˆå¼•è„šé…ç½®**
4. æ‰§è¡Œé©±åŠ¨çš„`probe()`å‡½æ•° â† è¿™æ—¶å¼•è„šå·²ç»é…ç½®å¥½äº†

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/31e5f57731b3c7a82cfef3ae826ebd4c.png)

## 2 å›é¡¾- deviceå’Œdev_pin_info

åœ¨æ·±å…¥åˆ†æ`pinctrl_bind_pins`ä¹‹å‰ï¼Œå…ˆäº†è§£è®¾å¤‡å¼•è„šä¿¡æ¯çš„å­˜å‚¨ç»“æ„ï¼š
```c
// include/linux/device.h
struct device {
    // ... å…¶ä»–æˆå‘˜ ...
#ifdef CONFIG_PINCTRL
    struct dev_pin_info *pins; // è®¾å¤‡çš„å¼•è„šä¿¡æ¯
#endif
    // ... å…¶ä»–æˆå‘˜ ...
};
```

å¦‚æœå®šä¹‰äº†`CONFIG_PINCTRL`ï¼Œé‚£ä¹ˆè®°å½•è®¾å¤‡å¼•è„šä¿¡æ¯çš„ç»“æ„ä½“`struct dev_pin_info *pins`å°±ä¼šè¢«ä½¿èƒ½ï¼š
```c
// include/linux/pinctrl/devinfo.h
struct dev_pin_info {
    struct pinctrl *p;                   // å¼•è„šæ§åˆ¶å™¨å¥æŸ„
    struct pinctrl_state *default_state; // é»˜è®¤çŠ¶æ€æŒ‡é’ˆ
    struct pinctrl_state *init_state;    // åˆå§‹åŒ–çŠ¶æ€æŒ‡é’ˆ
#ifdef CONFIG_PM
    struct pinctrl_state *sleep_state;   // ç¡çœ çŠ¶æ€æŒ‡é’ˆ
    struct pinctrl_state *idle_state;    // ç©ºé—²çŠ¶æ€æŒ‡é’ˆ
#endif
};
```

## 3 pinctrl_bind_pins

```c fold
// drivers/base/pinctrl.c
/**
 * pinctrl_bind_pins() - called by the device core before probe
 * @dev: the device that is just about to probe
 */
int pinctrl_bind_pins(struct device *dev)
{
        int ret;
        
        // æ£€æŸ¥è®¾å¤‡æ˜¯å¦é‡ç”¨äº†èŠ‚ç‚¹
        if (dev->of_node_reused)
                return 0;

        // ğŸ”¥ æ­¥éª¤1ï¼šä¸ºè®¾å¤‡çš„å¼•è„šåˆ†é…å†…å­˜ç©ºé—´
        // dev->pinså°±æ˜¯dev_pin_infoç»“æ„ä½“
        dev->pins = devm_kzalloc(dev, sizeof(*(dev->pins)), GFP_KERNEL);
        if (!dev->pins)
                return -ENOMEM;

        // ğŸ”¥ æ­¥éª¤2ï¼šè·å–è®¾å¤‡çš„pinctrlå¥æŸ„
        dev->pins->p = devm_pinctrl_get(dev);
        if (IS_ERR(dev->pins->p)) {
                dev_dbg(dev, "no pinctrl handle\n");
                ret = PTR_ERR(dev->pins->p);
                goto cleanup_alloc;
        }
        
        // ğŸ”¥ æ­¥éª¤3ï¼šæŸ¥æ‰¾è®¾å¤‡çš„é»˜è®¤pinctrlçŠ¶æ€
        dev->pins->default_state = pinctrl_lookup_state(dev->pins->p,
                                        PINCTRL_STATE_DEFAULT);
        if (IS_ERR(dev->pins->default_state)) {
                dev_dbg(dev, "no default pinctrl state\n");
                ret = 0;
                goto cleanup_get;
        }
        
        // ğŸ”¥ æ­¥éª¤4ï¼šæŸ¥æ‰¾è®¾å¤‡çš„åˆå§‹åŒ–pinctrlçŠ¶æ€
        dev->pins->init_state = pinctrl_lookup_state(dev->pins->p,
                                        PINCTRL_STATE_INIT);
        if (IS_ERR(dev->pins->init_state)) {
                /* ä¸æä¾›æ­¤çŠ¶æ€æ˜¯å®Œå…¨åˆæ³•çš„ */
                dev_dbg(dev, "no init pinctrl state\n");
                
                // é€‰æ‹©é»˜è®¤çš„pinctrlçŠ¶æ€
                ret = pinctrl_select_state(dev->pins->p,
                                           dev->pins->default_state);
        } else {
                // å¦‚æœæœ‰initçŠ¶æ€ï¼Œå…ˆåº”ç”¨initçŠ¶æ€
                ret = pinctrl_select_state(dev->pins->p, dev->pins->init_state);
        }

        if (ret) {
                dev_dbg(dev, "failed to activate initial pinctrl state\n");
                goto cleanup_get;
        }
        
#ifdef CONFIG_PM
        // ğŸ”¥ æ­¥éª¤5ï¼šæŸ¥æ‰¾ç”µæºç®¡ç†ç›¸å…³çš„çŠ¶æ€ï¼ˆå¯é€‰ï¼‰
        /*
         * å¦‚æœå¯ç”¨äº†ç”µæºç®¡ç†ï¼Œæˆ‘ä»¬è¿˜ä¼šå¯»æ‰¾å¯é€‰çš„ç¡çœ å’Œç©ºé—²çš„å¼•è„šçŠ¶æ€
         */
        dev->pins->sleep_state = pinctrl_lookup_state(dev->pins->p,
                                        PINCTRL_STATE_SLEEP);
        if (IS_ERR(dev->pins->sleep_state))
                /* ä¸æä¾›æ­¤çŠ¶æ€æ˜¯å®Œå…¨åˆæ³•çš„ */
                dev_dbg(dev, "no sleep pinctrl state\n");

        dev->pins->idle_state = pinctrl_lookup_state(dev->pins->p,
                                        PINCTRL_STATE_IDLE);
        if (IS_ERR(dev->pins->idle_state))
                /* ä¸æä¾›æ­¤çŠ¶æ€æ˜¯å®Œå…¨åˆæ³•çš„ */
                dev_dbg(dev, "no idle pinctrl state\n");
#endif

        return 0;

        /*
         * If no pinctrl handle or default state was found for this device,
         * let's explicitly free the pin container in the device, there is
         * no point in keeping it around.
         */
cleanup_get:
        devm_pinctrl_put(dev->pins->p);
cleanup_alloc:
        devm_kfree(dev, dev->pins);
        dev->pins = NULL;

        /* Return deferrals */
        if (ret == -EPROBE_DEFER)
                return ret;
        /* Return serious errors */
        if (ret == -EINVAL)
                return ret;
        /* We ignore errors like -ENOENT meaning no pinctrl state */

        return 0;
}
```



**pinctrl_bind_pinsæ‰§è¡Œæµç¨‹ï¼š**
```txt
pinctrl_bind_pins(dev)
    â”œâ”€â”€ 1. åˆ†é… dev->pins å†…å­˜
    â”œâ”€â”€ 2. devm_pinctrl_get(dev) â†’ è·å–pinctrlå¥æŸ„
    â”œâ”€â”€ 3. pinctrl_lookup_state() â†’ æŸ¥æ‰¾"default"çŠ¶æ€
    â”œâ”€â”€ 4. pinctrl_lookup_state() â†’ æŸ¥æ‰¾"init"çŠ¶æ€  
    â”œâ”€â”€ 5. pinctrl_select_state() â†’ åº”ç”¨çŠ¶æ€é…ç½®
    â””â”€â”€ 6. æŸ¥æ‰¾PMç›¸å…³çŠ¶æ€(sleep/idle)
```

## 4 è·å–pinctrlçš„è¿‡ç¨‹

### 4.1 devm_pinctrl_get

```c
// drivers/pinctrl/core.c
/**
 * devm_pinctrl_get() - Resource managed pinctrl_get()
 * @dev: the device to obtain the handle for
 */
struct pinctrl *devm_pinctrl_get(struct device *dev)
{
        struct pinctrl **ptr, *p;
        
        // ä¸ºå­˜å‚¨å¼•è„šæ§åˆ¶å™¨å¥æŸ„çš„æŒ‡é’ˆåˆ†é…å†…å­˜
        ptr = devres_alloc(devm_pinctrl_release, sizeof(*ptr), GFP_KERNEL);
        if (!ptr)
                return ERR_PTR(-ENOMEM);
 
        // è·å–è®¾å¤‡çš„å¼•è„šæ§åˆ¶å™¨å¥æŸ„
        p = pinctrl_get(dev);
        if (!IS_ERR(p)) {
                // å¦‚æœè·å–æˆåŠŸï¼Œå°†å¼•è„šæ§åˆ¶å™¨å¥æŸ„å­˜å‚¨åœ¨æŒ‡é’ˆä¸­
                *ptr = p;
                // å°†æŒ‡é’ˆæ·»åŠ åˆ°è®¾å¤‡èµ„æºä¸­
                devres_add(dev, ptr);
        } else {
                // å¦‚æœè·å–å¤±è´¥ï¼Œé‡Šæ”¾ä¹‹å‰åˆ†é…çš„æŒ‡é’ˆå†…å­˜
                devres_free(ptr);
        }
        
        // è¿”å›å¼•è„šæ§åˆ¶å™¨å¥æŸ„æˆ–é”™è¯¯ç æŒ‡é’ˆ
        return p;
}
```

**devm_pinctrl_getæ‰§è¡Œæµç¨‹ï¼š**
```txt
devm_pinctrl_get(dev)
â”œâ”€â”€ devres_alloc() â†’ åˆ†é…èµ„æºç®¡ç†å†…å­˜
â”œâ”€â”€ pinctrl_get(dev) â†’ è·å–pinctrlå¥æŸ„
â”œâ”€â”€ devres_add() â†’ æ·»åŠ åˆ°è®¾å¤‡èµ„æºç®¡ç†
â””â”€â”€ return pinctrlå¥æŸ„
```

### 4.2 pinctrl_get

```c
// drivers/pinctrl/core.c
/**
 * pinctrl_get() - retrieves the pinctrl handle for a device
 * @dev: the device to obtain the handle for
 */
struct pinctrl *pinctrl_get(struct device *dev)
{
        struct pinctrl *p;
        
        // æ£€æŸ¥è®¾å¤‡æŒ‡é’ˆæ˜¯å¦ä¸ºç©º
        if (WARN_ON(!dev))
                return ERR_PTR(-EINVAL);
 
        /*
         * æŸ¥çœ‹æ˜¯å¦æœ‰å…¶ä»–ç»„ä»¶ï¼ˆå¦‚è®¾å¤‡æ ¸å¿ƒï¼‰å·²ç»è·å–äº†æ­¤è®¾å¤‡çš„å¼•è„šæ§åˆ¶å™¨å¥æŸ„ã€‚
         * åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œè¿”å›å¯¹è¯¥å¥æŸ„çš„å¦ä¸€ä¸ªæŒ‡é’ˆã€‚
         */
        p = find_pinctrl(dev);
        if (p != NULL) {
                dev_dbg(dev, "obtain a copy of previously claimed pinctrl\n");
                kref_get(&p->users);
                return p;
        }
        
        // åˆ›å»ºå¹¶è¿”å›è®¾å¤‡çš„å¼•è„šæ§åˆ¶å™¨å¥æŸ„
        return create_pinctrl(dev);
}
```

**pinctrl_getæ‰§è¡Œæµç¨‹ï¼š**
```txt
pinctrl_get(dev)
    â”œâ”€â”€ find_pinctrl(dev) â†’ æŸ¥æ‰¾å·²å­˜åœ¨çš„å¥æŸ„
    â”œâ”€â”€ if (æ‰¾åˆ°) â†’ kref_get() â†’ å¢åŠ å¼•ç”¨è®¡æ•°
    â””â”€â”€ else â†’ create_pinctrl(dev) â†’ åˆ›å»ºæ–°å¥æŸ„
```

### 4.3 create_pinctrl

```c fold
// drivers/pinctrl/core.c
static struct pinctrl *create_pinctrl(struct device *dev)
{
        struct pinctrl *p;
        const char *devname;
        struct pinctrl_maps *maps_node;
        int i;
        const struct pinctrl_map *map;
        int ret;

        /*
         * ä¸ºæ¯ä¸ªæ˜ å°„åˆ›å»ºçŠ¶æ€cookieæŒæœ‰è€…struct pinctrlã€‚
         * è¿™æ˜¯å½“ä½¿ç”¨pinctrl_get()è¯·æ±‚å¼•è„šæ§åˆ¶å¥æŸ„æ—¶æ¶ˆè´¹è€…å°†è·å¾—çš„å¯¹è±¡ã€‚
         */
        p = kzalloc(sizeof(*p), GFP_KERNEL);
        if (!p)
                return ERR_PTR(-ENOMEM);
                
        p->dev = dev;
        INIT_LIST_HEAD(&p->states);
        INIT_LIST_HEAD(&p->dt_maps);

        // ğŸ”¥ å…³é”®ï¼šä»è®¾å¤‡æ ‘è§£æpinctrlæ˜ å°„
        ret = pinctrl_dt_to_map(p);
        if (ret < 0) {
                kfree(p);
                return ERR_PTR(ret);
        }
        
        devname = dev_name(dev);

        mutex_lock(&pinctrl_maps_mutex);
        /* éå†å¼•è„šæ§åˆ¶æ˜ å°„ä»¥å®šä½æ­£ç¡®çš„æ˜ å°„ */
        for_each_maps(maps_node, i, map) {
                /* æ˜ å°„å¿…é¡»é€‚ç”¨äºæ­¤è®¾å¤‡ */
                if (strcmp(map->dev_name, devname))
                        continue;

                ret = add_setting(p, NULL, map);
                if (ret == -EPROBE_DEFER) {
                        pinctrl_free(p, false);
                        mutex_unlock(&pinctrl_maps_mutex);
                        return ERR_PTR(ret);
                }
        }
        mutex_unlock(&pinctrl_maps_mutex);

        if (ret < 0) {
                /* If some other error than deferral occurred, return here */
                pinctrl_free(p, false);
                return ERR_PTR(ret);
        }

        kref_init(&p->users);

        /* å°†å¼•è„šæ§åˆ¶å¥æŸ„æ·»åŠ åˆ°å…¨å±€åˆ—è¡¨ */
        mutex_lock(&pinctrl_list_mutex);
        list_add_tail(&p->node, &pinctrl_list);
        mutex_unlock(&pinctrl_list_mutex);

        return p;
}
```


**create_pinctrlæ‰§è¡Œæµç¨‹ï¼š**
```txt
create_pinctrl(dev)
    â”œâ”€â”€ kzalloc() â†’ åˆ†é…pinctrlç»“æ„ä½“
    â”œâ”€â”€ åˆå§‹åŒ–é“¾è¡¨å¤´(states, dt_maps)
    â”œâ”€â”€ pinctrl_dt_to_map(p) â†’ è§£æè®¾å¤‡æ ‘æ˜ å°„
    â”œâ”€â”€ for_each_maps() â†’ éå†æ˜ å°„è¡¨
    â”‚   â””â”€â”€ add_setting() â†’ æ·»åŠ è®¾ç½®åˆ°çŠ¶æ€
    â”œâ”€â”€ kref_init() â†’ åˆå§‹åŒ–å¼•ç”¨è®¡æ•°
    â”œâ”€â”€ list_add_tail() â†’ æ·»åŠ åˆ°å…¨å±€é“¾è¡¨
    â””â”€â”€ return pinctrlå¥æŸ„
```

**struct pinctrlç»“æ„ä½“è¯´æ˜ï¼š**

```c
// drivers/pinctrl/core.h
struct pinctrl {
    struct list_head node;      // ç”¨äºå°†å¼•è„šæ§åˆ¶å™¨æ·»åŠ åˆ°å…¨å±€åˆ—è¡¨çš„é“¾è¡¨èŠ‚ç‚¹
    struct device *dev;         // å…³è”çš„è®¾å¤‡
    struct list_head states;    // å­˜å‚¨å¼•è„šé…ç½®çŠ¶æ€çš„é“¾è¡¨
    struct pinctrl_state *state; // å½“å‰åº”ç”¨çš„å¼•è„šé…ç½®çŠ¶æ€
    struct list_head dt_maps;   // å­˜å‚¨è®¾å¤‡æ ‘ä¸­å®šä¹‰çš„å¼•è„šæ˜ å°„ä¿¡æ¯çš„é“¾è¡¨
    struct kref users;          // å¼•è„šæ§åˆ¶å™¨çš„å¼•ç”¨è®¡æ•°
};
```


## 5 è®¾å¤‡æ ‘åˆ°æ˜ å°„çš„è½¬æ¢ï¼špinctrl_dt_to_map

```c fold
// drivers/pinctrl/devicetree.c
int pinctrl_dt_to_map(struct pinctrl *p)
{
        struct device_node *np = p->dev->of_node;
        int state, ret;
        char *propname;
        struct property *prop;
        const char *statename;
        const __be32 *list;
        int size, config;
        phandle phandle;
        struct device_node *np_config;
 
        /* å¦‚æœCONFIG_OFå¯ç”¨ï¼Œä¸”p->devä¸æ˜¯ä»è®¾å¤‡æ ‘å®ä¾‹åŒ–è€Œæ¥ */
        if (!np) {
                if (of_have_populated_dt())
                        dev_dbg(p->dev,
                                "no of_node; not parsing pinctrl DT\n");
                return 0;
        }
 
        /* èŠ‚ç‚¹å†…éƒ¨å­˜å‚¨å±æ€§åç§°çš„æŒ‡é’ˆ */
        of_node_get(np);
 
        /* ğŸ”¥ å¯¹äºæ¯ä¸ªå®šä¹‰çš„çŠ¶æ€ID */
        for (state = 0; ; state++) {
                /* è·å–pinctrl-*å±æ€§ */
                propname = kasprintf(GFP_KERNEL, "pinctrl-%d", state);
                prop = of_find_property(np, propname, &size);
                kfree(propname);
                if (!prop) {
                        if (!state) {
                                ret = -EINVAL;
                                goto err;
                        }
                        break;
                }
                list = prop->value;
                size /= sizeof(*list);
 
                /* åˆ¤æ–­pinctrl-nameså±æ€§æ˜¯å¦å‘½åäº†è¯¥çŠ¶æ€ */
                ret = of_property_read_string_index(np, "pinctrl-names",
                                    state, &statename);
                /*
                 * If not, statename is just the integer state ID. But rather
                 * than dynamically allocate it and have to free it later,
                 * just point part way into the property name for the string.
                 */
                if (ret < 0) {
                        /* strlen("pinctrl-") == 8 */
                        statename = prop->name + 8;
                }
                
                /* ğŸ”¥ å¯¹äºå…¶ä¸­çš„æ¯ä¸ªå¼•ç”¨çš„å¼•è„šé…ç½®èŠ‚ç‚¹ */
                for (config = 0; config < size; config++) {
                        phandle = be32_to_cpup(list++);

                        /* æŸ¥æ‰¾å¼•è„šé…ç½®èŠ‚ç‚¹ */
                        np_config = of_find_node_by_phandle(phandle);
                        if (!np_config) {
                                dev_err(p->dev,
                                        "prop %s index %i invalid phandle\n",
                                        prop->name, config);
                                ret = -EINVAL;
                                goto err;
                        }

                        /* ğŸ”¥ è§£æèŠ‚ç‚¹ */
                        ret = dt_to_map_one_config(p, statename, np_config);
                        of_node_put(np_config);
                        if (ret < 0)
                                goto err;
                }

                /* å¦‚æœåœ¨è®¾å¤‡æ ‘ä¸­æ²¡æœ‰æ¡ç›®ï¼Œåˆ™ç”Ÿæˆä¸€ä¸ªè™šæ‹ŸçŠ¶æ€è¡¨æ¡ç›® */
                if (!size) {
                        ret = dt_remember_dummy_state(p, statename);
                        if (ret < 0)
                                goto err;
                }
        }

        return 0;

err:
        pinctrl_dt_free_maps(p);
        return ret;
}
```


**pinctrl_dt_to_mapæ‰§è¡Œæµç¨‹ï¼š**
```txt
pinctrl_dt_to_map(p)
    â”œâ”€â”€ æ£€æŸ¥è®¾å¤‡æ ‘èŠ‚ç‚¹(of_node)
    â”œâ”€â”€ for (state = 0; ; state++) â†’ éå†æ¯ä¸ªçŠ¶æ€
    â”‚   â”œâ”€â”€ kasprintf("pinctrl-%d") â†’ æ„é€ å±æ€§å
    â”‚   â”œâ”€â”€ of_find_property() â†’ æŸ¥æ‰¾pinctrl-Nå±æ€§
    â”‚   â”œâ”€â”€ of_property_read_string_index() â†’ è¯»å–çŠ¶æ€å
    â”‚   â””â”€â”€ for (config = 0; config < size; config++)
    â”‚       â”œâ”€â”€ be32_to_cpup() â†’ è·å–phandle
    â”‚       â”œâ”€â”€ of_find_node_by_phandle() â†’ æŸ¥æ‰¾é…ç½®èŠ‚ç‚¹
    â”‚       â””â”€â”€ dt_to_map_one_config() â†’ è§£æå•ä¸ªé…ç½®
    â””â”€â”€ return æ˜ å°„ç»“æœ
```

## 6 è®¾å¤‡æ ‘é…ç½®ç¤ºä¾‹

ä»¥é«˜é€šMSMå¹³å°çš„UARTè®¾å¤‡ä¸ºä¾‹ï¼š
```d
/*
 * UART3è®¾å¤‡æ ‘èŠ‚ç‚¹å®šä¹‰ - é«˜é€šMSMå¹³å°é«˜é€ŸUARTæ§åˆ¶å™¨
 * å®šä¹‰äº†BLSP1æ€»çº¿ä¸Šçš„UART3æ§åˆ¶å™¨é…ç½®
 */
blsp1_uart3: uart@78b1000 {
        compatible = "qcom,msm-hsuart-v14";     /* è®¾å¤‡å…¼å®¹æ€§å­—ç¬¦ä¸² */
        reg = <0x78b1000 0x200>,                /* å¯„å­˜å™¨åœ°å€æ˜ å°„ï¼š
                <0x7884000 0x2b000>;             * 0x78b1000: UARTæ§åˆ¶å™¨åŸºåœ°å€
                                                 * 0x7884000: BLSP QUPåŸºåœ°å€ */
        ...
        pinctrl-names = "sleep", "default";     /* å¼•è„šæ§åˆ¶çŠ¶æ€åç§°ï¼š
                                                 * "sleep": ç¡çœ çŠ¶æ€é…ç½®
                                                 * "default": é»˜è®¤å·¥ä½œçŠ¶æ€é…ç½® */
        pinctrl-0 = <&blsp1_uart3_sleep>;       /* çŠ¶æ€0(sleep)å¯¹åº”çš„å¼•è„šé…ç½® */
        pinctrl-1 = <&blsp1_uart3_active>;      /* çŠ¶æ€1(default)å¯¹åº”çš„å¼•è„šé…ç½® */
        ...
        status = "disabled";                    /* è®¾å¤‡çŠ¶æ€ï¼š
                                                 * "disabled": è®¾å¤‡ç¦ç”¨
                                                 * "okay": è®¾å¤‡å¯ç”¨ */
};
```

**è§£æè¿‡ç¨‹ï¼š**
1. `pinctrl_dt_to_map`è§£æ`pinctrl-names`å±æ€§ï¼Œå‘ç°æœ‰"sleep"å’Œ"default"ä¸¤ä¸ªçŠ¶æ€
2. è§£æ`pinctrl-0`å±æ€§ï¼Œè·å–phandleæŒ‡å‘`&blsp1_uart3_sleep`
3. è§£æ`pinctrl-1`å±æ€§ï¼Œè·å–phandleæŒ‡å‘`&blsp1_uart3_active`
4. è°ƒç”¨`dt_to_map_one_config`ä¸ºæ¯ä¸ªçŠ¶æ€åˆ›å»ºç›¸åº”çš„æ˜ å°„

## 7 æ€»ç»“

å¼•è„šé…ç½®è‡ªåŠ¨ç”Ÿæ•ˆæœºåˆ¶çš„æ ¸å¿ƒè¦ç‚¹ï¼š
1. **æ—¶æœºï¼š** åœ¨è®¾å¤‡probeä¹‹å‰ï¼Œé€šè¿‡`pinctrl_bind_pins`è‡ªåŠ¨å®Œæˆ
2. **è¿‡ç¨‹ï¼š**
    - åˆ†é…`dev_pin_info`ç»“æ„ä½“
    - è·å–pinctrlå¥æŸ„
    - è§£æè®¾å¤‡æ ‘é…ç½®
    - åº”ç”¨é»˜è®¤æˆ–åˆå§‹åŒ–çŠ¶æ€
3. **ä¼˜åŠ¿ï¼š**
    - é©±åŠ¨å¼€å‘è€…æ— éœ€æ‰‹åŠ¨å¤„ç†pinctrl
    - å‡å°‘é©±åŠ¨ä»£ç å¤æ‚åº¦
    - ç»Ÿä¸€çš„å¼•è„šé…ç½®ç®¡ç†
4. **è®¾è®¡æ€æƒ³ï¼š**
    - é…ç½®ä¸å®ç°åˆ†ç¦»
    - è‡ªåŠ¨åŒ–ç®¡ç†
    - çŠ¶æ€åŒ–åˆ‡æ¢
**ä¸€å¥è¯æ€»ç»“ï¼š** pinctrlå­ç³»ç»Ÿé€šè¿‡åœ¨è®¾å¤‡probeå‰è‡ªåŠ¨è°ƒç”¨`pinctrl_bind_pins`ï¼Œå®ç°äº†å¼•è„šé…ç½®çš„é€æ˜åŒ–ç®¡ç†ï¼Œè®©é©±åŠ¨å¼€å‘è€…å¯ä»¥ä¸“æ³¨äºæ ¸å¿ƒåŠŸèƒ½å®ç°ã€‚