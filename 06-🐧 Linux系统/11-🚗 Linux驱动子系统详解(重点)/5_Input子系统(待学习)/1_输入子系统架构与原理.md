
## 1 引言：为什么需要输入子系统

计算机的输入设备繁多，有按键、鼠标、键盘、触摸屏、游戏手柄等等。想象一下，如果每种输入设备都需要编写完全不同的驱动程序，应用程序也需要针对每种设备编写不同的代码，那将是多么混乱！

Linux内核为了能够将所有的输入设备进行统一的管理，设计了输入子系统。为上层应用提供了统一的抽象层，各个输入设备的驱动程序只需上报产生的输入事件即可。

> [!tip]+ 理解要点 输入子系统就像一个"翻译中心"：
> 
> - 不管是键盘说"英语"，还是鼠标说"法语"，或触摸屏说"中文"
> - 输入子系统都能翻译成应用程序能理解的"通用语言"（input_event）
> - 应用程序不需要关心具体是什么设备，只需要理解这种通用语言即可

## 2 什么是输入子系统？

在 Linux 中，input 子系统是专门为处理输入类设备而设计的一个子系统或框架。它提供了一套通用的接口和机制，用于驱动开发人员编写和管理输入设备的驱动程序。输入设备包括键盘、鼠标、触摸屏、游戏手柄等，具体示意图如下所示：

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/a08205477535884d99db64b4c40e40d7.png)

使用 input 子系统的主要目的是规范和简化输入设备驱动的开发过程，以提高驱动的通用性和兼容性。它通过将**输入设备的共同功能和处理逻辑提取出来**，编写成通用的代码，将**差异化的代码**留给具体的**设备驱动开发人员**，这种分工合作的方式使得驱动开发人员可以更专注地处理设备特定的细节，从而**大大降低工程师的开发难度**。

### 2.1 输入子系统的优势

使用输入子系统的另一个好处是驱动开发人员**不需要自己实现文件操作集函数**。输入子系统已经提供了一套标准的接口和函数，开发人员只需要按照这些接口进行开发，而无需关心底层的文件操作细节。这样可以大大降低开发的难度和复杂度。

**（1）兼容性**：输入子系统提供了一个统一的框架和接口，使得不同厂家的输入设备都可以按照相同的规范进行驱动开发。无论是键盘、鼠标还是其他输入设备，只要符合输入子系统定义的接口和事件格式，都可以在 Linux 系统中正常工作。这样一来，工程师不需要针对每个厂家的设备编写和维护不同的驱动代码，大大提高了设备的兼容性。

**（2）统一的驱动编程方式**：输入子系统定义了一套通用的驱动编程方式，工程师只需要按照输入子系统的规范进行开发即可。输入设备的驱动模块需要实现相应的接口函数，如初始化函数、事件处理函数等。这些接口函数的实现方式是相同的，不论是键盘驱动还是鼠标驱动，都可以按照统一的方式进行开发。这样一来，工程师可以更加专注于设备特定的细节，而无需关心通用的驱动框架，简化了开发过程。

**（3）统一的应用操作接口**：输入子系统通过提供一组统一的应用操作接口，如 /dev/input/eventX，使得应用程序可以方便地与输入设备进行交互。应用程序可以通过读取这些设备节点，获取输入事件的信息，并进行相应的处理。无论是哪种类型的输入设备，应用程序都可以使用相同的方式进行访问和操作。这样一来，应用程序的开发人员不需要关心底层输入设备的细节，可以更加专注于应用程序的逻辑开发。

## 3 输入子系统的三层架构

Linux为了统一各个输入设备，将输入子系统分为了Drivers(驱动层)、Input Core(输入子系统核心层)、handlers(事件处理层)三部分。

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/3afd8790cf611a14aa4b0e0694ccbaae.png)

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/e4eeda7dba678d28d780cea618cd37fd.png)

Input 子系统可以分为事件处理层、设备驱动层、核心层三层，这三层在输入子系统中有着不同的作用和分工。

### 3.1 设备驱动层（Drivers）

设备驱动层是输入子系统的最底层，负责与硬件设备进行通信和交互。它的主要职责是将硬件设备的操作和功能抽象为统一的接口，以便核心层和事件处理层可以与之交互。

- 主要实现对硬件设备的读写访问，设置中断
- 将硬件产生的事件转为Input Core定义的规范提交给Handlers
- 设备驱动层的代码通常包括硬件的初始化、中断处理、数据传输等操作
- 开发者在这一层编写驱动程序，以适配特定的硬件设备

> [!note]+ 开发提示 Linux源码中已经写好了核心层相关的代码，所以在后续编写输入子系统驱动的时候，核心层的代码是不需要编写的。而事件处理层在Linux中也为我们提供了一个模板，除了一些例如固定设备节点的需求外，一般不需要编写事件处理层的代码。设备驱动层由于要面对不同的硬件，每个硬件的初始化方式又都不同，所以设备驱动层的代码在编写输入子系统驱动的时候是需要填充的。

### 3.2 核心层（Input Core）

核心层的主要功能是作为匹配器位于事件处理层和设备驱动层之间。它起到协调和连接这两个层级的作用，以确保输入设备的事件能够正确地传递给相应的事件处理程序。

- Input Core起到承上启下的作用
- 为Drivers提供了规范及接口
- 通知Handlers对事件进行处理

以下是核心层在输入子系统中的主要功能：

**（1）事件匹配**：核心层负责将输入设备产生的原始输入数据与相应的事件处理程序进行匹配。它会解析原始输入数据，并根据预定义的规则和配置信息，确定应该将输入数据传递给哪个事件处理程序进行处理。

**（2）设备管理和控制**：核心层负责维护输入设备的状态、属性和配置信息，并提供设备的注册、注销和管理功能。它与设备驱动层进行交互，接收来自设备驱动层的输入事件，并将其转化为抽象化的事件表示形式。核心层提供一致的接口，使得上层应用程序可以独立于具体的硬件设备进行操作。

**（3）事件处理和分发**：核心层负责事件的处理和分发，将输入事件传递给对应的事件处理层。它通过事件队列的机制，接收和缓存来自设备驱动层的输入事件，并按照特定的规则将事件分发给对应的事件处理层或应用程序。这样，事件处理层可以通过核心层提供的接口，获取输入事件并进行相应的处理。

**（4）抽象化接口和事件处理机制**：核心层为上层应用程序和事件处理层提供了一组抽象化的接口和事件处理机制。它提供了统一的事件表示形式，使得不同类型的输入设备（如键盘、鼠标、触摸屏等）的事件可以被表示和处理。通过核心层的接口，事件处理层可以注册事件监听器、订阅特定类型的事件，并获取输入设备的状态信息。

### 3.3 事件处理层（Handlers）

事件处理层是输入子系统的最上层，可以处理输入设备产生的事件并将其传递给上层应用程序，并在操作系统中创建设备节点，以便应用程序可以通过设备节点与输入设备进行通信。它接收来自核心层的输入事件，并根据事件的类型和属性进行相应的处理。

- Handlers并不涉及硬件方面的具体操作，是一个纯软件层
- 包含了不同的解决方案，如按键、键盘、鼠标、游戏手柄等
- 为上层应用提供了统一的事件处理机制

> [!tip]+ 数据流向 **硬件事件** → **设备驱动层** → **核心层** → **事件处理层** → **用户空间应用**

## 4 输入事件的抽象

最终所有输入设备的输入信息将被抽象成以下结构体：

```c
// struct input_event结构体(内核源码/include/uapi/linux/input.h)
//输入事件
struct input_event{
    struct timeval time;   //事件产生的时间
    __u16 type;            //输入设备的类型，鼠标、键盘、触摸屏
    __u16 code;            //根据设备类型的不同而含义不同
    __s32 value;           //根据设备类型的不同而含义不同
}
```

- **time**：事件产生的时间
- **type**：输入设备的类型
- **code**：根据设备类型的不同而含义不同，如果设备类型是按键，code表示为按键值(如第几个按键等)
- **value**：根据设备类型的不同而含义不同。如果设备类型是按键，value表示的是松开或者按下

### 4.1 事件类型（type）

输入子系统支持的事件类型定义如下：

```c
// 输入子系统事件类型(内核源码/include/uapi/linux/input-event-codes.h)
#define EV_SYN          0x00  //同步事件
#define EV_KEY          0x01  //用于描述键盘、按钮或其他类似按键的设备
#define EV_REL          0x02  //用于描述相对位置变化，例如鼠标移动
#define EV_ABS          0x03  //用于描述绝对位置变化，例如触摸屏的触点坐标
#define EV_MSC          0x04  //其他事件类型
#define EV_SW           0x05  //用于描述二进制开关类型的设备，例如拨码开关
#define EV_LED          0x11  //LED事件
#define EV_SND          0x12  //声音事件
#define EV_REP          0x14  //重复事件
#define EV_FF           0x15  //力反馈事件
#define EV_PWR          0x16  //电源事件
#define EV_FF_STATUS    0x17  //力反馈状态
#define EV_MAX          0x1f
#define EV_CNT          (EV_MAX+1)
```

上面代码中前几个宏定义较为常用的输入事件类型，介绍如代码后面所示。完整的事件列表介绍可以参考内核源码目录下的"**~/Documentation/input/event-codes.rst**"内核文档。很明显，按键的事件类型应该使用**EV_KEY**。

### 4.2 事件码（code）

以按键事件为例，code表示具体的按键：

```c
// 输入子系统—按键键值(内核源码/include/uapi/linux/input-event-codes.h)
#define KEY_RESERVED     0
#define KEY_ESC          1
#define KEY_1            2
#define KEY_2            3
#define KEY_3            4
#define KEY_4            5
/*-----------以下内容省略-------------*/
```

可以看出"键值"就是一些数字。只要实际设备与按键对应即可。

### 4.3 事件值（value）

对于按键事件：

- value = 0：按键松开
- value = 1：按键按下
- value = 2：按键长按

对于绝对坐标事件（触摸屏）：

- 如果code = ABS_X，则value = X坐标值
- 如果code = ABS_Y，则value = Y坐标值

## 5 输入设备和节点的关系

在输入子系统中，输入设备与设备节点之间有一定的对应关系。以下是判断设备节点与输入设备的方法：

### 5.1 设备名

输入子系统的设备节点可以分为通用设备名和专用设备名。专用设备名通常可以从设备名中直接识别出设备类型，例如"keyboard"（键盘）或"mouse"（鼠标）。而通用设备名则不能直接确定设备类型。如下图所示，event0-event4 属于通用设备名，而 mouse0 和 mouse2 属于专用设备名。

`ls /dev/input`

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/d9bce13d7dec458899cd533f1ae684f9.png)

### 5.2 试探性方法

可以使用"cat"命令打开设备节点文件，然后对物理设备进行操作，观察终端是否有输出。例如，对于键盘设备，你可以运行 "cat /dev/input/eventX"，其中"/dev/input/eventX"是设备节点的路径，然后按下键盘按键，观察终端是否输出相应的字符。通过这种试探性的方法，你可以判断设备节点与具体设备之间的对应关系。

### 5.3 查看输入设备信息

可以使用以下命令查看"/proc/bus/input/devices"文件：

**cat /proc/bus/input/devices**

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/674afc22c7a3691160c6db37135dbafe.png)

该文件记录了当前系统的所有输入设备的信息在该文件中，你可以找到与设备节点相关的信息，例如设备名称、供应商 ID、产品 ID 等。通过对比设备节点的路径和设备信息中的对应字段，你可以确定设备节点与特定输入设备之间的关系，例如可以通过上述打印信息查看到，键盘对应的设备节点为`/dev/input/event1`，如下图所示：

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/fdb740d0eefa94b7669f3bb99180d53e.png)

其他相关内容的解释如下所示：

- **I: Bus=0011 Vendor=0001 Product=0001 Version=ab41**: 这一行显示了设备的总线类型、供应商 ID、产品 ID 和固件版本。在这个例子中，该设备的总线类型为 0011，供应商 ID 为 0001，产品 ID 为 0001，固件版本为 ab41。
    
- **N: Name="AT Translated Set 2 keyboard"**: 这一行显示了设备的名称。在这个例子中，该设备的名称为"AT Translated Set 2 keyboard"。
    
- **P: Phys=isa0060/serio0/input0**: 这一行显示了设备的物理位置。在这个例子中，该设备的物理位置是 isa0060/serio0/input0。
    
- **S: Sysfs=/devices/platform/i8042/serio0/input/input1**: 这一行显示了设备在 sysfs 文件系统中的路径。在这个例子中，该设备的路径是/devices/platform/i8042/serio0/input/input1。
    
- **U: Uniq=**: 这一行显示了设备的唯一标识符。在这个例子中，唯一标识符为空。
    
- **H: Handlers=sysrq kbd event1 leds**: 这一行显示了设备的处理程序。它指示了处理设备输入事件的程序或模块。在这个例子中，设备有 sysrq、kbd、event1 和 leds 这些处理程序，其中 event1 就表示设备节点为/dev/input/event1。
    
- **B: PROP=0**: 这一行显示了设备的属性。在这个例子中，设备的属性值为 0。
    
- **B: EV=120013**: 这一行显示了设备支持的事件类型。在这个例子中，设备支持 EV_SYN、EV_KEY、EV_MSC 和 EV_LED 这些事件类型。
    
- **B: KEY=402000000 3803078f800d001 feffffdfffefffff fffffffffffffffe**: 这一行显示了设备支持的按键。每个按键对应一个位，1 表示按键被按下，0 表示按键未被按下。该行显示了按键的状态，以 16 进制表示。
    
- **B: MSC=10**: 这一行显示了设备支持的杂项事件。在这个例子中，设备支持 MSC_SCAN事件。
    
- **B: LED=7**: 这一行显示了设备支持的 LED 灯。在这个例子中，设备支持 3 个 LED 灯，使用一个 7 位的二进制数表示灯的状态。
    

> [!example]+ 实践技巧 快速确定设备节点的方法：
> 
> 1. 使用 `ls /dev/input/` 查看所有输入设备节点
> 2. 运行 `cat /proc/bus/input/devices` 找到目标设备
> 3. 查看 H: Handlers 行中的 eventX，即为对应的设备节点
> 4. 使用 `sudo cat /dev/input/eventX` 测试设备是否正常工作

## 6 总结

通过本章的学习，我们了解了：

1. **输入子系统的作用**：统一管理各种输入设备，提供标准化接口
2. **三层架构**：
    - 设备驱动层：与硬件交互
    - 核心层：协调和匹配
    - 事件处理层：为应用提供接口
3. **事件抽象**：所有输入都转换为input_event结构体
4. **设备节点**：通过/dev/input/eventX访问输入设备

> [!tip]+ 下一步学习 理解了输入子系统的架构后，下一步可以：
> 
> 1. 学习核心数据结构的详细定义
> 2. 了解如何编写输入设备驱动
> 3. 掌握应用层编程接口的使用