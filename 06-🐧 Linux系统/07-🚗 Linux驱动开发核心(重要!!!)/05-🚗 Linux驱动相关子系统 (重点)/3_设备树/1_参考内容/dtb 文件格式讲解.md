---
文章标题: "[[dtb 文件格式讲解]]"
文章作者: Dakkk
文章概要: |
  本文详细介绍了DTB文件的基本概念、结构组织和解析流程，包括DTC编译工具的使用、文件头信息、四个主要区域、节点和属性信息的存储机制等核心内容。
tags:
  - DTB
  - 设备树
  - DTC编译器
  - 嵌入式开发
  - Linux内核
  - 二进制文件
  - 文件格式
  - 硬件描述
相关文章:
  - "[[../02_设备树（device Tree）的由来]]"
  - "[[10_设备树的简介]]"
  - "[[设备树的规范（dts和dtb）]]"
  - "[[../03_图解Kernel Device Tree(设备树)的使用]]"
  - "[[../05_设备树中时钟描述 (被使用)]]"
文章分类: 🐧 Linux系统
文章路径: 06-🐧 Linux系统/07-🚗 Linux驱动开发核心(重要!!!)/05-🚗 Linux驱动相关子系统 (重点)/3_设备树/1_Linux之设备树详解（训练营）/08_dtb 文件格式讲解.md
文章难度: 中级 🌳
目前阶段: ✅ 已完成
重要性: ⭐⭐⭐⭐ 核心能力
创建时间: 2025-06-10 20:34:00
修改时间: 2025-06-11 15:04:53
---

参考文章：[2 DTB格式](设备树的规范（dts和dtb）.md#2%20DTB格式)

## 1 DTB 文件基本概念

### 1.1 什么是 DTB 文件

在嵌入式开发中，我们经常会遇到两种设备树文件：
- **DTS 文件**：Device Tree Source，设备树源文件，格式为 `.dts`
- **DTSI 文件**：Device Tree Source Include，设备树头文件，格式为 `.dtsi`
- **DTB 文件**：Device Tree Blob，设备树二进制文件，格式为 `.dtb`

> [!info]+ 文件关系简单理解 
> 把 DTS 想象成我们能看懂的"说明书"，而 DTB 就是机器能理解的"指令码"。就像 C 语言源码需要编译成机器码一样，DTS 也需要编译成 DTB 才能被系统使用。

### 1.2 为什么需要 DTB 文件

**DTS 文件的特点**：
- 人类可读的文本格式
- 包含设备硬件信息的描述
- 便于编写和维护

**DTB 文件的特点**：
- 二进制格式，机器可直接识别
- uboot 和 Linux 内核只能识别 DTB 文件
- 占用空间更小，加载速度更快

换句话说，DTS 是给开发者看的，DTB 是给系统用的。

### 1.3 编译工具 DTC

**DTC**：Device Tree Compiler，设备树编译器，用于在 DTS 和 DTB 之间进行转换。

#### 1.3.1 DTC 工具的获取方式

**方式一：使用 Linux 源码中的 DTC** Linux 源码目录下的 `scripts/dtc` 目录包含 DTC 工具的源码。
**方式二：独立安装 DTC** 在 Linux 系统下执行以下命令安装：
```bash
sudo apt-get install device-tree-compiler
```

#### 1.3.2 DTC 工具的使用方法

**将 DTS 编译成 DTB**：
```c
dtc –I dts –O dtb –o xxx.dtb xxx.dts
```

**将 DTB 反编译成 DTS**：
```c
dtc –I dtb –O dts –o xxx.dts xxx.dtb
```

> [!tip]+ 参数说明
> 
> - **-I**：指定输入文件格式（Input format）
> - **-O**：指定输出文件格式（Output format）
> - **-o**：指定输出文件名（Output file）

> [!example]+ 实际应用场景 
> 当我们修改了 DTS 文件后，需要重新编译成 DTB 文件，然后烧录到设备中。反之，当我们想查看设备上实际使用的设备树配置时，可以将 DTB 反编译成 DTS 来分析。

## 2 Device Tree 头信息

### 2.1 使用 fdtdump 查看 DTB 信息

**fdtdump** 工具专门用于 dump（导出）DTB 文件信息，让我们可以方便地查看 DTB 的内部结构。
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/0c4663069f857c9c1d1d308a882105e9.png)

上图显示的就是 **Device Tree 文件头信息**，这些信息存储在 DTB 文件的开头部分，就像文件的"身份证"一样。

### 2.2 头信息的结构体定义

在 Linux 内核中，使用 **struct fdt_header** 结构体来描述这个头信息。这个结构体定义在 `scripts\dtc\libfdt\fdt.h` 文件中：
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/44c1ba8d64089dd743c3740d20c1e1f2.png)

> [!note]+ 头信息的作用 
> 头信息告诉系统这个 DTB 文件的基本属性，包括文件大小、各个区域的位置等，就像目录一样帮助系统快速定位到需要的信息。
## 3 Device Tree文件结构深入解析

### 3.1 四个主要区域

**Device Tree** 文件在内存中的结构分为四个主要区域：
1. **header**：文件头，包含基本信息
2. **fill_area**：填充区域，用 0 填充
3. **dt_struct**：结构数据区，存储节点和属性信息
4. **dt_string**：字符串区，存储所有的字符串

> [!info]+ 区域功能简单理解
> 
> - **header**：就像书的封面，告诉你这本书的基本信息
> - **fill_area**：就像书页之间的空白，用来对齐数据
> - **dt_struct**：就像书的目录和内容，存储实际的设备信息
> - **dt_string**：就像书后面的索引，存储所有用到的名称

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/b8c137a71cd369d381d98b252a336c36.png)

### 3.2 数据结构的组织方式

在 **dt_struct** 区域中，信息是按照特定的结构体组织的：
- **节点信息**：使用 `struct fdt_node_header` 结构体描述
- **属性信息**：使用 `struct fdt_property` 结构体描述
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/c200e5bce1939c9fcdc5ce642853d011.png)

## 4 节点信息结构详解

### 4.1 节点头结构体

**struct fdt_node_header** 用来描述设备树中的每个节点：
- **tag**：标识节点类型的标志位
- **name**：指向节点名称的首地址

### 4.2 标志位（Tag）的含义

**tag** 字段的取值定义了不同的节点类型：
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/668871cb8a400eaed200d9981cafa0c5.png)

**各个标志位的含义**：
- **FDT_BEGIN_NODE**：标识节点的开始
- **FDT_END_NODE**：标识节点的结束
- **FDT_PROP**：标识节点下面的属性开始
- **FDT_END**：标识整个 Device Tree 的结束

> [!example]+ 标志位的实际应用 
> 当系统解析 DTB 文件时，就像读书一样：
> 
> - 遇到 FDT_BEGIN_NODE 就知道"开始读一个新的设备描述"
> - 遇到 FDT_PROP 就知道"开始读这个设备的属性"
> - 遇到 FDT_END_NODE 就知道"这个设备描述结束了"
> - 遇到 FDT_END 就知道"整本书读完了"

## 5 属性信息结构详解

### 5.1 属性结构体

**struct fdt_property** 用来描述节点的属性信息：
- **tag**：标识这是一个属性，取值为 `FDT_PROP`
- **len**：属性值的长度（包括 `'\0'`，单位：字节）
- **nameoff**：属性名称存储位置相对于 `off_dt_strings` 的偏移

### 5.2 属性信息的存储机制

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/ff89d9fcb68a9ee7242f6c1984e3709d.png)

> [!note]+ 存储机制的巧妙设计 
> 属性的名称并不直接存储在属性结构体中，而是通过偏移量指向字符串区域。这样设计的好处是：
> 
> 1. **节省空间**：相同的属性名只需要存储一次
> 2. **提高效率**：通过偏移量快速定位字符串
> 3. **便于管理**：所有字符串集中存储，便于维护

### 5.3 属性值的长度计算

**len 字段** 记录属性值的字节长度，需要注意：

> [!warning]+ 长度计算注意事项
> 
> - 长度包括字符串结尾的 `'\0'` 字符
> - 单位是字节，不是字符数
> - 对于数组类型的属性，长度是整个数组的总字节数

## 6 DTB 文件的解析流程

### 6.1 系统启动时的解析过程

当系统启动时，DTB 文件的解析过程如下：
1. **读取文件头**：获取各个区域的位置和大小信息
2. **验证文件完整性**：检查魔数、版本等信息
3. **解析结构区域**：按照标志位逐个解析节点和属性
4. **建立内存数据结构**：将 DTB 信息转换为内核可用的数据结构

### 6.2 内存中的数据组织

解析完成后，设备树信息在内存中形成树状结构：
- **根节点**：整个设备树的起点
- **子节点**：各个设备和总线
- **属性**：每个节点的具体配置信息

> [!tip]+ 优化设计的优势 
> DTB 文件的这种设计既保证了数据的紧凑性，又保证了解析的效率。通过标志位的引导，系统可以快速跳过不需要的信息，直接定位到目标设备的配置。

> [!abstract]+ 本章总结 DTB 文件格式的核心特点：
> 
> 1. **二进制格式**：机器可直接识别，加载速度快
> 2. **结构化存储**：通过标志位组织数据，解析效率高
> 3. **紧凑设计**：字符串统一存储，节省空间
> 4. **标准化接口**：提供统一的数据结构定义，便于开发
> 
> 理解 DTB 文件格式有助于我们更好地调试设备树问题，优化系统启动性能。

## 7 常见问题解答

> [!question]+ 为什么不直接使用 DTS 文件？ 
> DTS 是文本格式，解析速度慢，占用空间大。而 DTB 是二进制格式，系统可以快速加载和解析，特别适合嵌入式系统对启动速度的要求。

> [!question]+ 如何验证 DTB 文件是否正确？
>  可以使用 `fdtdump` 工具查看 DTB 文件的内容，或者使用 `dtc` 工具将 DTB 反编译成 DTS 文件进行检查。

> [!question]+ DTB 文件损坏会有什么后果？ 
> DTB 文件损坏会导致系统无法正确识别硬件设备，可能出现设备初始化失败、驱动加载错误等问题，严重时会导致系统无法启动。

