
## 1 字符设备驱动程序的三种写法

### 1.1 如何写驱动程序？

写驱动程序就像搭建一座桥梁，连接硬件和应用程序。整个过程可以分为三个步骤：

**第一步：看原理图**

- 确定使用的引脚（就像确定电器插在哪个插座上）
- 看芯片手册，确定如何操作引脚（通常是设置寄存器）

**第二步：编写驱动程序**

驱动程序的核心作用是**封装硬件操作**，给上层应用程序提供标准接口。换句话说，应用程序不需要知道硬件的具体细节，只需要调用标准的函数即可。
- 上层应用需要的标准接口：open、read、write、ioctl
- 驱动程序对应提供：drv_open、drv_read、drv_write、drv_ioctl

具体实现步骤：
1. **分配**结构体 `file_operations`
2. **设置**成员函数：
    - `.open = led_open` → 配置LED引脚为输出模式
    - `.write = led_write` → 根据应用程序传入的值控制LED亮灭
3. **注册**到内核（告诉内核有这个驱动）：
    - 使用 `register_chrdev` 函数注册
    - 使用 `unregister_chrdev` 函数注销
4. **提供**模块的入口和出口函数

**第三步：编写测试程序**
- 测试程序用来验证驱动是否正常工作。

### 1.2 问题：在驱动中如何确定引脚？

这是驱动开发中的一个核心问题。不同的硬件产品可能使用不同的引脚，我们需要一种灵活的方式来指定。

目前有三种主流方法：
1. **传统方法**：在代码里直接写死引脚号
2. **总线设备驱动模型**：
    - `led_drv.c`：实现驱动的核心功能（分配、设置、注册等）
    - `led_dev.c`：专门用来指定引脚资源
3. **设备树方法**：
    - `led_drv.c`：实现驱动的核心功能（保持不变）
    - `xxxx.dts`：使用设备树文件来指定引脚

> [!note]+ 核心区别 三种方法的**驱动核心代码基本相同**，主要区别在于**如何指定硬件资源**。

### 1.3 三种方法的优缺点

让我们通过一个实际例子来理解：假设有两款产品都需要控制LED，产品A使用Pin1，产品B使用Pin2。

**传统方法**

- 实现方式：在代码中直接写死引脚号
- **优点**：实现简单，新手容易理解
- **缺点**：
    - 不易扩展（换个引脚就要改代码）
    - 需要重新编译整个驱动模块

**总线设备驱动模型**

- 实现方式：
    - 驱动和设备都挂在 `platform` 总线上
    - 通过不同的 `led_dev.c` 文件来指定不同产品的引脚
    - `platform_device` 结构体用于描述硬件资源
- **优点**：易于扩展，驱动和硬件资源分离
- **缺点**：
    - 冗余代码较多（每个产品都需要一个dev.c文件）
    - 更换硬件仍需要重新编译

**设备树方法**

- 实现方式：
    - `led_drv.c` 保持不变
    - 通过 `.dts` 文件指定硬件资源
    - DTS编译成DTB文件，内核解析后创建 `platform_device`
- **优点**：
    - 高度灵活，易于扩展
    - 更换硬件只需要更换DTB文件，不需要重新编译内核或驱动
    - 没有冗余的C代码
- **缺点**：相对复杂，需要学习设备树语法

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/44e77d7004fb680b4b354589193ea980.png)

下图展示了三种方法的对比：

![第01节_字符设备驱动程序的三种写法.jpg|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/ecedb27ba24667b7cdc5348f89348032.jpeg)

> [!tip]+ 选择建议
> 
> - 学习阶段：从传统方法开始，理解驱动基本原理
> - 实际项目：优先使用设备树，它是现代Linux驱动的主流方式

## 2 字符设备驱动的传统写法

传统写法是最直观的方式，适合初学者理解驱动的基本结构。

代码实现可以参考以下文章：

- [6 字符设备驱动程序实验(实际应用)](../../03-📊%20字符设备驱动模型/1_字符设备驱动模型基础(Lubancat)/4_📕字符设备驱动.md#6%20字符设备驱动程序实验(实际应用))
- [7 一个驱动支持多个设备](../../03-📊%20字符设备驱动模型/1_字符设备驱动模型基础(Lubancat)/4_📕字符设备驱动.md#7%20一个驱动支持多个设备)
- 重点参考：[4.2.5 LED驱动完整代码](../../03-📊%20字符设备驱动模型/1_字符设备驱动模型基础(Lubancat)/5_字符设备驱动—点亮LED灯实验.md#4.2.5%20LED驱动完整代码)

## 3 字符设备驱动的编译测试

编译和测试是验证驱动是否正常工作的关键步骤。

详细步骤请参考：[4.3 实验准备](../../03-📊%20字符设备驱动模型/1_字符设备驱动模型基础(Lubancat)/5_字符设备驱动—点亮LED灯实验.md#4.3%20实验准备)

> [!tip]+ 实用技巧：
> NFS文件传输 在开发板测试时，可以使用NFS挂载主机目录，避免频繁拷贝文件。具体方法参考：[5_挂载NFS网络文件系统](../../../05-💻%20Linux应用开发与系统编程/3_Linux基础与应用开发实战(Lubancat-RK3568)/4_补充部分/5_挂载NFS网络文件系统.md)

> [!question]+ 为什么应用程序不需要调用close函数？ 
> 当应用程序退出时，Linux操作系统会**自动清理**该程序打开的所有文件描述符。这是操作系统的保护机制，防止资源泄露。

## 4 总线设备驱动模型

总线设备驱动模型是传统方法的改进版，实现了**驱动代码和硬件资源的分离**。

详细实现请参考：[5 平台设备实验（代码讲解）](../../03-📊%20字符设备驱动模型/1_字符设备驱动模型基础(Lubancat)/7_平台设备驱动.md#5%20平台设备实验（代码讲解）)

> [!note]+ 关键理解 
> 在这种模型中，**只需要修改 `platform_device` 的 `resource` 资源**，`platform_driver` 保持不变。这就实现了"一个驱动支持多种硬件"的目标。

### 4.1 复习match机制

Platform总线的匹配机制决定了设备和驱动如何"找到彼此"。详细内容参考：[4.1 注册和匹配方式](../../03-📊%20字符设备驱动模型/1_字符设备驱动模型基础(Lubancat)/7_平台设备驱动.md#4.1%20注册和匹配方式)

主要有两种匹配方式：

**方式1：id_table匹配**
- 匹配 `platform_device` 的 `name` 字段
- 与 `platform_driver` 的 `id_table` 中的 `name` 字段进行比较
- 优势：一个驱动可以支持多个设备（通过id_table数组）

**方式2：name匹配**
- 匹配 `platform_device` 的 `name` 字段
- 与 `platform_driver` 的 `driver.name` 字段进行比较
- 这是最简单的匹配方式

## 5 使用设备树时对应的驱动编程

设备树是现代Linux驱动开发的主流方式，让我们看看它与总线设备驱动模型有什么不同。

> [!abstract]+ 核心区别
> 
> - **总线设备驱动模型**：硬件资源在 `platform_device` 的 `resource` 字段中
> - **设备树模型**：硬件资源在设备树文件中描述

设备树的工作流程：

1. 在 `.dts` 文件中构造设备节点，描述硬件资源
2. DTS编译成DTB文件
3. DTB传给内核
4. 内核解析为 `device_node` 结构体
5. 最终转换为 `platform_device` 结构体
6. 驱动通过OF函数获取硬件资源

### 5.1 简单了解一下设备树的match机制

设备树的匹配机制是通过 **compatible** 属性实现的。

![image.png|500|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/be69defd26927e2f530b526030def493.png)

匹配过程的核心是 `platform_driver` 结构体中的 `of_match_table`：

![image.png|500|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/1db6ac5f1e0d7a30946158cd7e69b184.png)

具体的匹配结构：

![image.png|500|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/a3bf6a21d87b0463d5bb0e73ce8d3c4e.png)

`of_device_id` 结构体的定义：

![image.png|500|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/f52fea746052987b8bd8fef8d47b8426.png)

> [!info]+ 匹配原理
> 
> - `compatible` 字段用于和设备树中的 `compatible` 属性进行比较
> - 如果匹配成功，说明这个驱动可以支持这个设备
> - 一个驱动可以通过多个 `compatible` 字符串支持多种设备

### 5.2 如何获取设备树的资源呢？

当设备和驱动匹配成功后，我们需要从设备树中读取硬件资源信息。

在 `platform_device` 结构体中，有一个 `device` 成员，其中包含了 `of_node` 属性：

![image.png|500|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/f9861bf4e092f04cea960eb12f38e844.png)

> [!success]+ 获取设备树节点的路径 
> 在probe函数中，通过以下链路获取匹配的设备树节点： `platform_device → device → of_node`
> 
> 然后使用OF函数（如 `of_property_read_u32`）读取节点属性。

## 6 只想使用设备树不想深入研究的办法

如果你不想深入研究设备树的原理，这里有一些实用的方法。不过要注意，这种方式就像"知其然而不知其所以然"，遇到问题时可能会比较被动。

> [!tip]+ 实用建议 
> 一个优秀的驱动程序会尽量在代码中确定大部分资源，只把**必须由用户指定的资源**（如引脚号、中断号）留给设备树。

### 6.1 如何编写设备树节点？

当你需要为某个驱动编写设备树节点时，可以通过以下途径获取格式信息：

**1. 查看内核文档**

内核自带了大量的设备树绑定文档：`Documentation/devicetree/bindings/`

![image.png|200|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/255acccc5bbcd04154a1a9bb9d3b7c2d.png)

例如，查看 `Documentation/devicetree/bindings/arm/samsung/exynos-chipid.txt`：

![image.png|500|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/928360379551c74ea4dc06a557fa8a57.png)

这个文档告诉我们，使用 `exynos-chipid` 驱动时必须提供什么样的设备树节点。

**2. 驱动源码对应关系**

文档目录和驱动源码是**一一对应**的关系：
![image.png|500|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/ceba35f5cfa18193088943cd8d765c25.png)

在 `内核源码/drivers` 目录下可以找到对应的驱动程序。

**3. 其他获取信息的途径**

- 参考同类型开发板的设备树文件
- 网上搜索相关驱动的使用示例
- 查看驱动作者提供的文档或README
- 实在没办法时，只能研究驱动源码了

> [!warning]+ 注意事项 
> 如果使用第三方驱动，设备树节点的格式完全依赖于驱动作者的设计。希望他们的文档写得足够详细！

> [!abstract]+ 本章总结 
> 设备树是现代Linux驱动开发的重要技术，它实现了硬件描述与驱动代码的分离。虽然学习曲线较陡，但掌握后会让驱动开发变得更加灵活和高效。建议从简单的LED驱动开始，逐步理解设备树的工作原理。