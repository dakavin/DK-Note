
在开始学习Linux驱动开发之前，我们需要掌握一个极其重要的基础概念：**中断**。可以说，不理解中断就无法真正理解现代操作系统的工作原理。

简单来说，**中断**就像是硬件设备给CPU发送的"紧急通知"，告诉CPU"我这里有重要事情需要立即处理"。这个机制让计算机能够高效地处理多个任务，而不是傻傻中断编程实践地等待某个设备完成工作。

> [!note]+ 重要笔记 
> 中断是现代计算机系统最核心的机制之一，几乎所有的设备驱动都离不开中断处理。掌握中断概念是学习驱动开发的必备基础。

## 1 中断基本概念

### 1.1 什么是中断

**中断**是指CPU正常运行期间，由**外部（硬件中断）** 或**内部（软中断）** 事件引起的一种机制。

CPU会停止当前正在执行的程序，并转而执行触发该中断的**中断处理程序（自定义）**。处理完中断处理程序后，CPU会返回到中断发生的地方，继续执行被中断的程序。

换句话说，中断机制允许CPU在实时响应外部或内部事件的同时，保持对其他任务的处理能力。

### 1.2 生活化理解中断

可以想象这样一幅画面：你正在烹饪一顿美味的晚餐，准备了各种食材，点燃了炉灶，开始了幸福的烹饪过程。突然，你的手机响起，有人打来了一个紧急电话，打破了你正常的烹饪流程。这时候你需要立刻停止手中的工作，迅速接起电话，与对方进行交流。在接完电话之后，再回到厨房继续之前的烹饪流程。

> [!example]+ 示例 在这个例子中：
> 
> - **你** = CPU（处理器）
> - **烹饪** = 正在执行的程序
> - **电话铃声** = 中断信号
> - **接电话** = 中断处理程序
> - **回到厨房继续烹饪** = 恢复原程序执行

这就是一个在实际生活中的中断案例，中断的概念流程图如下所示：

![中断概念流程图|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/86b8e06ad89bbc2e501e50eb0a2ef7e7.png)

### 1.3 中断的分类

**硬件中断**：
- 由外部硬件设备产生
- 比如键盘、鼠标点击、网卡接收数据
- 通过硬件信号线通知CPU

**软件中断**：
- 由软件程序触发
- 比如系统调用、异常处理
- 通过特定指令会触发

> [!tip]+ 重要提示 
> 在驱动开发中，我们`主要关注硬件中断`，因为大部分设备都是通过硬件中断来通知CPU处理事件的

## 2 中断的重要性和应用

### 2.1 中断的重要性

在上面的烹饪场景中，CPU作为唯一具有处理能力的主体，我们一次只能专注于一个任务，可以等待水烧开、看电视等等。然而，当我们专心致志地完成一项任务时，常常会有紧迫或不紧迫的其他事情突然出现，需要我们关注和处理。

有些情况甚至要求我们立即停下手头的工作来应对。只有在处理完这些中断事件之后，我们才能回到先前的任务。

### 2.2 中断机制的优势

中断机制赋予了我们处理意外情况的能力，而且如果我们能充分利用这个机制，就能够同时完成多个任务。

让我们继续用烧水的例子来说明：无论我们是否在厨房，煤气灶都会将水烧开。我们只需要在水烧开后及时关掉煤气。为了避免在厨房等待的时间，而**水烧开时产生的声音就是中断信号**，提醒我们炉子上的水已经烧开。这样，我们就可以在等待的时间里做其他事情，比如看电视。当水壶烧开发出声音之后，它会打断当前的任务，提醒水已经烧开，这时只需要前往厨房关掉煤气即可。

> [!example]+ 示例 
> **没有中断机制**：CPU必须不停地检查设备状态（轮询），浪费大量时间 **有中断机制**：CPU可以做其他工作，设备完成时主动通知CPU

### 2.3 计算机系统中的中断应用

类似地，计算机系统中也使用中断机制来应对各种外部事件：

**键盘输入**：在键盘输入时，会发送一个中断信号给CPU，以便及时响应用户的操作。这样，CPU就不必一直轮询键盘的状态，而可以专注于其他任务。

**网络通信**：网卡接收到数据包时，通过中断通知CPU立即处理，而不是让CPU不断检查是否有新数据。

**硬盘操作**：硬盘读写完成后，通过中断通知CPU数据已准备好，避免CPU空等。

> [!success]+ 成功或完成 
> 中断机制使我们能够有条不紊地同时处理多个任务，从而提高了并发处理能力和系统的资源利用率。

## 3 异常与中断的关系

### 3.1 基本概念澄清

在学习具体的异常分类之前，我们需要先理解一个重要概念：**在ARM64体系结构中，中断是异常的一个子集**

换句话说，异常是一个更大的概念，包含了：
- **同步异常**：由正在执行的指令引起的
- **异步异常**：与当前执行的指令无关，包括我们熟悉的中断

> [!tip]+ 重要提示 
> 这就像"水果"和"苹果"的关系一样，异常是总概念，中断是其中的一种特殊情况。

### 3.2 为什么要分类异常

**目的**：
- 不同类型的异常需要不同的处理方式
- 帮助CPU快速定位处理程序
- 提高系统响应率和稳定性

**处理的差异**：
- 同步异常通常需要修复问题后继续执行
- 异步异常（中断）处理完后直接返回
- 错误类异常可能需要终止程序运行

## 4 ARM64异常级别管理

ARM64处理器采用分层特权管理机制，定义了4个异常级别（Exception Levels，EL），从EL0到EL3。这种设计就像政府的权力分级一样，级别越高，访问权限越大，能处理的事务越重要。

**EL0（用户级别）**：最低权限级别，用于`普通应用程序`执行。就像普通员工只能处理日常业务，不能访问公司机密信息。

**EL1（内核级别）**：用于`操作系统内核`执行。拥有管理硬件资源的权限，就像部门经理可以调配部门资源。

**EL2（Hypervisor级别）**：用于虚拟化环境中的监管程序。可以管理多个虚拟机，就像总经理可以管理多个部门。

**EL3（Secure Monitor级别）**：最高权限级别，用于安全相关操作。就像董事长拥有最高决策权，可以处理最机密的安全事务。

> [!note]+ 权限分级的意义
> 
> 这种层次结构确保了系统的安全性和稳定性，防止低权限程序意外或恶意访问高权限资源，就像公司的权限管理制度保护重要信息一样。

## 5 异常的详细分类

### 5.1 同步异常

同步异常是程序执行指令时直接产生的异常，具有可预测性和精确性。主要包括以下类型：

**系统调用异常**：程序需要内核服务时主动触发的异常。不同异常级别使用不同的指令：

- **EL0**使用`svc`（Supervisor Call）指令陷入异常级别1
- **EL1**使用`hvc`（Hypervisor Call）指令陷入异常级别2
- **EL2**使用`smc`（Secure Monitor Call）指令陷入异常级别3

> [!example]+ 示例 当用户程序调用`open()`函数打开文件时，最终会通过`svc`指令触发系统调用异常，从用户态切换到内核态。

**内存访问异常**：

- **数据中止**：发生时机是访问数据时的页错误异常，常见原因是虚拟地址没有映射到物理地址，或者没有写权限，典型场景是访问未分配的内存，写入只读区域
- **指令中止**：发生时机是取指令时的页错误异常，常见原因是虚拟地址没有映射到物理地址，或者没有执行权限，典型场景是跳转到无效地址，执行数据区域的内容

> [!warning]+ 警告或注意 
> 这类异常在驱动开发中很常见，通常是由于指针错误或内存管理问题导致的。

**其他同步异常**：
- **对齐异常**：`栈指针对齐`要求栈指针必须按照特定字节对齐，`指令地址对齐`要求指令地址通常需要4字节对齐
- **未定义指令**：CPU遇到无法识别的指令，可能是代码损坏或跳转到错误地址
- **调试异常**：断点触发的异常，用于程序调试和性能分析

### 5.2 异步异常

**异步异常**：不是由正在执行的指令生成的，和正在执行的指令没有关联。

**普通中断（IRQ）**：
- **名称**：normal priority interrupt，IRQ
- **性质**：普通优先级的中断
- **用途**：大部分外设使用的中断类型

> [!example]+ 示例 
> 网卡接收到数据包、键盘按键、定时器超时等都是通过IRQ中断通知CPU的。

**快速中断（FIQ）**：

- **名称**：fast interrupt，FIQ
- **性质**：高优先级的中断
- **优势**：响应速度更快，优先级更高

> [!tip]+ 重要提示 
> FIQ通常用于对时间要求极其严格的场合，比如实时控制系统。在一般的Linux系统中，FIQ使用较少。

**系统错误（SError）**：

- **名称**：System Error，SError
- **触发原因**：由硬件错误触发的异常
- **典型场景**：最常见的是把脏数据从缓存行写回内存时触发异步的数据中止异常

> [!danger]+ 危险或错误 
> SError通常表示严重的硬件问题，如内存错误、总线错误等，可能导致系统崩溃。

### 5.3 同步异常与异步异常对比

|特性|同步异常|异步异常|
|---|---|---|
|**触发来源**|当前指令执行流程引发|外部事件触发|
|**与指令关联**|与指令执行直接相关|与指令执行无关|
|**触发时机**|精确触发，在指令执行过程中检测到<br>问题时触发|不确定时间触发，受外部硬件信号驱动|
|**常见应用场景**|内存保护、系统调用、调试|外设中断、实时事件处理、<br>硬件错误检测|

换句话说，同步异常就像员工主动请假（可预期的行为），而异步异常就像突发的火灾警报（不可预期的外部事件）

## 6 异常向量表机制

### 6.1 异常向量表的作用

当异常发生的时候，处理器需要执行异常对应的处理程序。**存储异常处理程序的内存位置称为异常向量**，通常把所有异常向量存放在一张表中，称为 **异常向量表**。

简单来说，异常向量表就像一个"电话簿"，当发生不同类型的异常时，CPU会在这个"电话簿"找对应的处理程序地址

> [!note]+ 重要笔记 
> 异常向量表是ARM64处理器异常处理的核心机制，它定义了每种异常类型对应的处理程序入口地址。

### 6.2 向量表结构演进

ARM架构在向量表设计上经历了重要变化：
- **ARMv7架构**：每个表项仅4字节，只能存放一条跳转指令，功能相对简单。
- **ARMv8架构**：每个表项扩展到128字节，可以存放32条指令，大大增强了处理能力。

> [!tip]+ 技术细节
> 
> 虽然ARMv8支持64位架构，但每条指令的位宽仍然是32位，这保证了指令集的一致性和效率。

### 6.3 ARM64异常向量表结构

让我们来看看Linux内核中实际的异常向量表定义，位于`arch/arm64/kernel/entry.S`文件中：
```c
/*
 * 异常向量表
 */
     .pushsection ".entry.text", "ax"
     .align     11
ENTRY(vectors)
     #具备 SP0类型的异常向量表描述的当前EL
     kernel_ventry     1, sync_invalid              // EL1t模式下的同步异常
     kernel_ventry     1, irq_invalid               // EL1t模式下的IRQ
     kernel_ventry     1, fiq_invalid               // EL1t模式下的FIQ
     kernel_ventry     1, error_invalid             // EL1t模式下的系统错误
     #具备SPx类型的异常向量表的描述的当前EL
     kernel_ventry     1, sync                      // EL1h模式下的同步异常
     kernel_ventry     1, irq                       // EL1h模式下的IRQ
     kernel_ventry     1, fiq_invalid               // EL1h模式下的FIQ
     kernel_ventry     1, error                     // EL1h模式下的系统错误
     #使用AArch64类型的异常向量表的低EL
     kernel_ventry     0, sync                     // 处于64位EL0下的同步异常
     kernel_ventry     0, irq                      // 处于64位的EL0下的IRQ
     kernel_ventry     0, fiq_invalid              // 处于64位的EL0下的FIQ
     kernel_ventry     0, error                    // 处于64位的EL0下的系统错误
     # 使用AArch32类型的异常向量表的低EL
     kernel_ventry     0, sync_compat, 32          // 处于32位的EL0下的同步异常
     kernel_ventry     0, irq_compat, 32           // 处于32位的EL0下的IRQ
     kernel_ventry     0, fiq_invalid_compat, 32   // 处于32位的EL0的FIQ
     kernel_ventry     0, error_compat, 32         // 处于32位的EL0下的系统错误
END(vectors)
```

- **段声明**：`.pushsection ".entry.text", "ax"`将代码放入专门的可执行段中，确保向量表被正确加载到内存
- **对齐要求**：`.align 11`确保向量表按2^11=2048字节对齐，这是ARM64架构的硬件要求
- **向量表分组**：整个向量表被分为4组，每组4个表项，对应不同的执行状态：
    - EL1t模式：内核级别使用SP_EL0栈指针（很少使用）
    - EL1h模式：内核级别使用SP_EL1栈指针（常用模式）
    - 64位EL0模式：用户态64位应用程序
    - 32位EL0模式：用户态32位应用程序（兼容模式）
- **异常类型**：每组包含4种异常类型（sync、irq、fiq、error），对应前面介绍的异常分类

> [!tip]+ 重要提示 
> 向量表中的`invalid`条目表示该异常类型在当前配置下不应该发生，如果发生了会触发panic。

### 6.4 kernel_ventry宏实现

`kernel_ventry`是实现向量表的核心宏，让我们深入了解其工作原理：

```c
 .macro kernel_ventry, el, label, regsize = 64
 .align 7
 sub  sp, sp, #S_FRAME_SIZE
 b    el\()\el\()_\label
 .endm
```

- `el`：异常级别参数（0或1），表示异常来源的级别
- `label`：处理函数标签，如sync、irq等，指定具体的异常类型
- `regsize`：寄存器大小，默认64位，兼容32位模式时为32

**工作流程详解**：
1. **对齐处理**：`.align 7`确保每个向量表项按128字节（2^7）对齐，满足ARM64硬件要求。
2. **栈帧分配**：`sub sp, sp, #S_FRAME_SIZE`为异常处理分配栈空间。这里的`S_FRAME_SIZE`是一个预定义常量，定义了保存所有CPU寄存器所需的空间大小。换句话说，就是为异常处理"预留座位"。
3. **动态跳转**：`b el\()\el\()_\label`通过宏参数动态生成跳转目标。例如，当`el=1`、`label=irq`时，生成的跳转目标是`el1_irq`，即内核态IRQ处理函数。

**统一入口设计**：这种设计让所有异常都有统一的入口流程，先分配栈空间保存上下文，然后跳转到专门的处理函数。

> [!example]+ 宏展开示例
> 
> 当定义`kernel_ventry 1, irq`时，宏会展开为：
> 
> ```asm
> .align 7
> sub sp, sp, #S_FRAME_SIZE
> b el1_irq
> ```
> 
> 这样就创建了一个内核态IRQ异常的入口点。

### 6.5 异常处理流程

**硬件自动操作**：

- 保存当前程序状态寄存器
- 跳转到异常向量表对应位置

**软件处理**：

- 保存寄存器状态到栈
- 执行具体的异常处理程序
- 恢复寄存器状态
- 返回到异常发生点

> [!example]+ 示例 当发生IRQ中断时，如果当前在用户态（EL0），CPU会查找向量表中"IRQ 64-bit EL0"对应的处理程序`irq`，然后跳转执行
> 
> ![异常处理示例|300](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/63a26c516f2cbd60fd32b3cd0764b52a.png)

## 7 中断的上下半部机制

### 7.1 设计思想

中断子系统中有一个重要的设计机制，那就是 **Top-half(上半部)** 和 **Bottom-half(下半部)**

这个设计的核心实现是：将紧急的工作放置在Top-half中来处理，而将耗时的工作放在Bottom-half中来处理，确保Top-half能尽快处理完成

简单来说，就像医院的急诊科：
- **上半部**：快速诊断，确定病情，给出紧急处理
- **下半部**：详细治疗，康复护理等耗时工作

或者说，一个键盘按下按键时会尝试中断
- **上半部**：处理中断，消除中断
- **下半部**：获取按键值

### 7.2 对比串行处理和并行处理

先看看没有下半部机制时会发生什么，**无下半部中断（串行处理）**：

![串行处理问题|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/3b6cf4d94188880663bad511e485b03c.png)

> [!warning]+ 警告或注意 
> 上图显示了串行处理的问题：每个中断必须完全处理完毕后才能处理下一个中断，可能导致中断丢失。

**有下半部中断（并行处理）**：

![并行处理优势|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/e905c8ac28f851a12384442f0d71338d.png)

> [!success]+ 成功或完成 
> 上图展示了并行处理的优势：上半部快速处理后立即开放中断，下半部可以与其他中断并行执行。

### 7.3 为什么需要上下半部机制

**ARM处理器的中断特性**：
- ARM处理器在进行中断处理时，处理器进入异常模式切换，此时会将`中断进行关闭`
- `处理完成后再将中断打开`

**不分上下半部的问题**：
- 如果中断不分，那么意味着只有等上一个中断完成处理后才会打开中断
- 下一个中断才能得到处理
- 当某个中断处理时间较长时，很有可能就导致其他中断丢失而无法响应

> [!danger]+ 危险或错误 
> 这个问题显然是难以接受的，比如典型的时钟中断，作为系统的脉搏，它的响应就需要得到保障。

### 7.4 工作原理

**优势说明**：
- 中断分成上下半部处理可以提高中断的响应能力
- 在上半部处理完成后便将中断打开（通常上半部处理越快越好）
- 这样就可以响应其他中断了，等到中断退出的时候再进行下半部的处理

**实现机制**： 中断的**Bottom-half机制**，包括了：
- **softirq**：软中断机制
- **tasklet**：基于softirq实现的任务机制
- **workqueue**：工作队列机制
- **中断线程化处理**：将中断处理程序运行在内核线程中

> [!note]+ 重要笔记 
> 其中tasklet又是基于softirq来实现的。这些机制我们在后续章节中会详细学习。

**上半部特点**： 中断上半部是中断服务程序的第一部分，它主要处理一些紧急且需要快速响应的任务。中断上半部的特点是执行时间较短，旨在尽快完成对中断的处理。这些任务可能包括保存寄存器状态、更新计数器等，以便在中断处理完成后能够正确地返回到中断前的执行位置。

## 8 示例：应用层读取按键的四种方式

当我们在应用层需要读取按键状态时，有四种不同的实现方式。这**四种方法展示了不同的中断处理思路**，从简单的轮询到高效的异步通知。

### 8.1 查询方式

![查询方式图解|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/1684afce97614e07c3f1d6976fbf79f2.png)

驱动程序中构造、注册一个 file_operations 结构体，里面提供有对应的 open,read 函数。APP 调用 open 时，导致驱动中对应的 open 函数被调用，在里面配置 GPIO 为输入引脚。APP 调用 read 时，导致驱动中对应的 read 函数被调用，它读取寄存器，把引脚状态直接返回给 APP。

### 8.2 休眠-唤醒方式

![休眠唤醒方式|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/f24f1cb49b76b2688e55e21d19575eff.png)

这种方式使用`中断机制`，当没有按键事件时应用程序进入休眠状态，当按键被按下时，硬件产生中断，中断处理程序唤醒等待的应用程序。

### 8.3 poll 方式

![poll方式|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/a6f07e643ca2f41920e143ea4b72199e.png)

poll方式允许应用程序同时监控多个文件描述符，当其中任何一个就绪时返回。这种方式在需要处理多个输入源时特别有用。

### 8.4 异步通知方式

![异步通知方式|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/15d10ff3de6a75f4b793c4728e4172cf.png)

异步通知方式使用信号机制，当按键事件发生时，驱动程序向应用程序发送信号，应用程序通过信号处理函数来响应按键事件。

> [!note]+ 重要笔记 
> 第2、3、4种方法，都涉及中断服务程序。中断，就像小孩醒了会哭闹一样，中断不经意间到来，它会做某些事情：唤醒APP、向APP发信号。所以，在按键驱动程序中，中断是核心。

## 9 总结

通过这个基础章节的学习，我们建立了对中断的全面认识：

> [!abstract]+ 摘要或总结
> 
> **核心概念掌握**：
> 
> - 理解了中断的基本定义和工作原理
> - 掌握了中断在计算机系统中的重要作用
> - 了解了异常与中断的关系以及ARM64异常级别管理
> - 学习了同步异常和异步异常的分类和特点
> - 认识了异常向量表机制和内核实现细节
> - 理解了上下半部机制的设计思想和必要性
> - 了解了应用层处理按键事件的不同方式

中断机制是现代计算机系统高效运行的基础，它让CPU能够智能地响应各种事件，而不是盲目地等待。在接下来的章节中，我们将深入学习中断的硬件原理、Linux中断框架，以及如何在驱动程序中正确使用中断。

> [!question]+ 常见问题 
> **Q**: 为什么不能让中断处理程序执行太长时间？ 
> **A**: 因为在中断处理期间，系统通常会禁用其他中断，如果处理时间过长，会导致其他重要中断无法及时响应，影响系统的实时性和稳定性。这就是为什么需要上下半部机制的原因。