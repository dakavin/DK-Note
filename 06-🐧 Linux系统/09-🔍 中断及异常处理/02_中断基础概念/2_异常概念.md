
现在我们需要了解一个重要概念：**异常**。很多初学者容易混淆中断和异常，今天就先来彻底搞清除它们的关系和区别。

简单来说，**异常**是CPU在执行过程中遇到的"异常情况"，需要特殊处理。而中断其实是异常的一种特殊类型。理解异常机制对于掌握Linux内核的底层工作原理至关重要。

> [!note]+ 重要笔记 
> 在ARM64体系结构中，中断被归类为异步异常。掌握异常分类有助于我们更好地理解整个中断处理体系。

## 1 异常与中断的关系

### 1.1 基本概念澄清

在学习具体的异常分类之前，我们需要先理解一个重要概念：**在ARM64体系结构中，中断是异常的一个子集**

换句话说，异常是一个更大的概念，包含了：
- **同步异常**：由正在执行的指令引起的
- **异步异常**：与当前执行的指令无关，包括我们熟悉的中断

> [!tip]+ 重要提示 
> 这就像"水果"和"苹果"的关系一样，异常是总概念，中断是其中的一种特殊情况。

### 1.2 为什么要分类异常

**目的**：
- 不同类型的异常需要不同的处理方式
- 帮助CPU快速定位处理程序
- 提高系统响应率和稳定性

**处理的差异**
- 同步异常通常需要修复问题后继续执行
- 异步异常（中断）处理完后直接返回
- 错误类异常可能需要终止程序运行

## 2 异常级别管理

ARM64处理器采用分层特权管理机制，定义了4个异常级别（Exception Levels，EL），从EL0到EL3。这种设计就像政府的权力分级一样，级别越高，访问权限越大，能处理的事务越重要。

**EL0（用户级别）**：
- 最低权限级别，用于`普通应用程序`执行。
- 就像普通员工只能处理日常业务，不能访问公司机密信息。

**EL1（内核级别）**：
- 用于`操作系统内核`执行。拥有管理硬件资源的权限
- 就像部门经理可以调配部门资源。

**EL2（Hypervisor级别）**：
- 用于虚拟化环境中的监管程序。
- 可以管理多个虚拟机，就像总经理可以管理多个部门。

**EL3（Secure Monitor级别）**：
- 最高权限级别，用于安全相关操作。
- 就像董事长拥有最高决策权，可以处理最机密的安全事务。

> [!note]+ 权限分级的意义
> 
> 这种层次结构确保了系统的安全性和稳定性，防止低权限程序意外或恶意访问高权限资源，就像公司的权限管理制度保护重要信息一样。

## 3 异常的详细分类

在ARM64体系结构中，异常被分为两大类：同步异常和异步异常。理解这两种异常的区别对于掌握中断处理至关重要。

### 3.1 同步异常

同步异常是程序执行指令时直接产生的异常，具有可预测性和精确性。主要包括以下类型：

**1、系统调用异常**：程序需要内核服务时主动触发的异常。不同异常级别使用不同的指令：
- **EL0**使用`svc`（Supervisor Call）指令陷入异常级别1
- **EL1**使用`hvc`（Hypervisor Call）指令陷入异常级别2
- **EL2**使用`smc`（Secure Monitor Call）指令陷入异常级别3

> [!example]+ 示例 
> 当用户程序调用`open()`函数打开文件时，最终会通过`svc`指令触发系统调用异常，从用户态切换到内核态。

**2、内存访问异常**
- **数据中止**：
	- **发生时机**：访问数据时的页错误异常
	- **常见原因**：虚拟地址没有映射到物理地址，或者没有写权限
	- **典型场景**：访问未分配的内存，写入只读区域
- **指令中止**：
	- **发生时机**：取指令时的也错误异常
	- **常见原因**：虚拟地址没有映射到物理地址，或者没有执行权限
	- **典型场景**：跳转到无效地址，执行数据区域的内容

> [!warning]+ 警告或注意 
> 这类异常在驱动开发中很常见，通常是由于指针错误或内存管理问题导致的。

**3、其他同步异常**
- **对齐异常**
	- **栈指针对齐**：栈指针必须按照特定字节对齐
	- **指令地址对齐**：指令地址通常需要4字节对齐
- **未定义指令**
	- CPU遇到无法识别的指令
	- 可能是代码损坏或跳转到错误地址
- **调试异常**
	- 断点触发的异常
	- 用于程序调试和性能分析

### 3.2 异步异常

**异步异常**：不是由正在执行的指令生成的，和正在执行的指令没有关联。例如 [1.3 中断的分类](1_中断概念.md#1.3%20中断的分类)

**1、普通中断（IRQ）**
- **名称**：normal priority interrupt，IRQ
- **性质**：普通优先级的中断
- **用途**：大部分外设使用的终端类型

> [!example]+ 示例 
> 网卡接收到数据包、键盘按键、定时器超时等都是通过IRQ中断通知CPU的。

**2、快速中断（FIQ）**
- **名称**：fast interrupt，FIQ
- **性质**：高优先级的中断
- **优势**：响应速度更快，优先级更高

> [!tip]+ 重要提示 
> FIQ通常用于对时间要求极其严格的场合，比如实时控制系统。在一般的Linux系统中，FIQ使用较少。

**3、系统错误（SError）**
- **名称**：System Error，SError
- **触发原因**：由硬件错误触发的异常
- **典型场景**：最常见的是把脏数据从缓存行写回内存时触发异步的数据中止异常

> [!danger]+ 危险或错误 
> SError通常表示严重的硬件问题，如内存错误、总线错误等，可能导致系统崩溃。

### 3.3 同步异常与异步异常对比

| 特性         | 同步异常                      | 异步异常                   |
| ---------- | ------------------------- | ---------------------- |
| **触发来源**   | 当前指令执行流程引发                | 外部事件触发                 |
| **与指令关联**  | 与指令执行直接相关                 | 与指令执行无关                |
| **触发时机**   | 精确触发，在指令执行过程中检测到<br>问题时触发 | 不确定时间触发，受外部硬件信号驱动      |
| **常见应用场景** | 内存保护、系统调用、调试              | 外设中断、实时事件处理、<br>硬件错误检测 |

换句话说，同步异常就像员工主动请假（可预期的行为），而异步异常就像突发的火灾警报（不可预期的外部事件）

## 4 异常向量表机制

### 4.1 异常向量表的作用

当异常发生的时候，处理器需要执行异常对应的处理程序。**存储异常处理程序的内存位置称为异常向量**，通常把所有异常向量存放在一张表中，称为 **异常向量表**

简单来说，异常向量表就像一个“电话簿”，当发生不同类型的异常是，CPU会在这个“电话簿”找对应的处理程序地址。

> [!note]+ 重要笔记 
> 异常向量表是ARM64处理器异常处理的核心机制，它定义了每种异常类型对应的处理程序入口地址。

### 4.2 向量表结构演进

ARM架构在向量表设计上经历了重要变化：
- **ARMv7架构**：每个表项仅4字节，只能存放一条跳转指令，功能相对简单。
- **ARMv8架构**：每个表项扩展到128字节，可以存放32条指令，大大增强了处理能力。

> [!tip]+ 技术细节
> 
> 虽然ARMv8支持64位架构，但每条指令的位宽仍然是32位，这保证了指令集的一致性和效率。

### 4.3 ARM64异常向量表结构

让我们来看看Linux内核中实际的异常向量表定义，位于`arch/arm64/kernel/entry.S`文件中：

```c
/*
 * 异常向量表
 */
     .pushsection ".entry.text", "ax"
     .align     11
ENTRY(vectors)
     #具备 SP0类型的异常向量表描述的当前EL
     kernel_ventry     1, sync_invalid              // EL1t模式下的同步异常
     kernel_ventry     1, irq_invalid               // EL1t模式下的IRQ
     kernel_ventry     1, fiq_invalid               // EL1t模式下的FIQ
     kernel_ventry     1, error_invalid             // EL1t模式下的系统错误
     #具备SPx类型的异常向量表的描述的当前EL
     kernel_ventry     1, sync                      // EL1h模式下的同步异常
     kernel_ventry     1, irq                       // EL1h模式下的IRQ
     kernel_ventry     1, fiq_invalid               // EL1h模式下的FIQ
     kernel_ventry     1, error                     // EL1h模式下的系统错误
     #使用AArch64类型的异常向量表的低EL
     kernel_ventry     0, sync                     // 处于64位EL0下的同步异常
     kernel_ventry     0, irq                      // 处于64位的EL0下的IRQ
     kernel_ventry     0, fiq_invalid              // 处于64位的EL0下的FIQ
     kernel_ventry     0, error                    // 处于64位的EL0下的系统错误
     # 使用AArch32类型的异常向量表的低EL
     kernel_ventry     0, sync_compat, 32          // 处于32位的EL0下的同步异常
     kernel_ventry     0, irq_compat, 32           // 处于32位的EL0下的IRQ
     kernel_ventry     0, fiq_invalid_compat, 32   // 处于32位的EL0的FIQ
     kernel_ventry     0, error_compat, 32         // 处于32位的EL0下的系统错误
END(vectors)
```
- **段声明**：`.pushsection ".entry.text", "ax"`将代码放入专门的可执行段中，确保向量表被正确加载到内存
- **对齐要求**：`.align 11`确保向量表按2^11=2048字节对齐，这是ARM64架构的硬件要求
- **向量表分组**：整个向量表被分为4组，每组4个表项，对应不同的执行状态：
	- EL1t模式：内核级别使用SP_EL0栈指针（很少使用）
	- EL1h模式：内核级别使用SP_EL1栈指针（常用模式）
	- 64为EL0模式：用户态64位应用程序
	- 32位EL0模式：用户态32位应用程序（兼容模式）
- **异常类型**：每组包含4种异常类型（sync、irq、fiq、error），对应前面介绍的异常分类

> [!tip]+ 重要提示 
> 向量表中的`invalid`条目表示该异常类型在当前配置下不应该发生，如果发生了会触发panic。

### 4.4 kernel_ventry宏实现

`kernel_ventry`是实现向量表的核心宏，让我们深入了解其工作原理：
```c
 .macro kernel_ventry, el, label, regsize = 64
 .align 7
 sub  sp, sp, #S_FRAME_SIZE
 b    el\()\el\()_\label
 .endm
```
- `el`：异常级别参数（0或1），表示异常来源的级别
- `label`：处理函数标签，如sync、irq等，指定具体的异常类型
- `regsize`：寄存器大小，默认64位，兼容32位模式时为32

**工作流程详解**：
1. **对齐处理**：`.align 7`确保每个向量表项按128字节（2^7）对齐，满足ARM64硬件要求。
2. **栈帧分配**：`sub sp, sp, #S_FRAME_SIZE`为异常处理分配栈空间。这里的`S_FRAME_SIZE`是一个预定义常量，定义了保存所有CPU寄存器所需的空间大小。换句话说，就是为异常处理"预留座位"。
- **动态跳转**：`b el\()\el\()_\label`通过宏参数动态生成跳转目标。例如，当`el=1`、`label=irq`时，生成的跳转目标是`el1_irq`，即内核态IRQ处理函数。

**统一入口设计**：
- 这种设计让所有异常都有统一的入口流程
- 先分配栈空间保存上下文，然后跳转到专门的处理函数。

> [!example]+ 宏展开示例
> 
> 当定义`kernel_ventry 1, irq`时，宏会展开为：
> 
> ```asm
> .align 7
> sub sp, sp, #S_FRAME_SIZE
> b el1_irq
> ```
> 
> 这样就创建了一个内核态IRQ异常的入口点。

### 4.5 异常处理流程

1. **硬件自动操作**
	- 保存当前程序状态寄存器
	- 跳转到异常向量表对应位置
2. **软件处理**
	- 保存寄存器状态到栈
	- 执行具体的异常处理程序
	- 恢复寄存器状态
	- 返回到异常发生点

> [!example]+ 示例 
> 当发生IRQ中断时，如果当前在用户态（EL0），CPU会查找向量表中"IRQ 64-bit EL0"对应的处理程序`irq`，然后跳转执行
> ![image.png|300](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/63a26c516f2cbd60fd32b3cd0764b52a.png)

## 5 总结

通过这个章节的学习，我们深入理解了异常处理机制：

> [!abstract]+ 摘要或总结
> **核心概念掌握**
> - 理解异常和中断的层次关系：中断是异步异常的一种
> - 掌握同步异常和异步异常的区别和典型应用场景
> - 了解ARM64架构的异常向量表的组织结构和工作原理
> - 认识不同异常类型的处理特点和重要性

异常处理机制是ARM64处理器的核心特性，它为Linux内核提供了统一的异常和中断处理框架。理解这个机制有助于我们后续学习Linux中断框架时建立正确的底层概念。

> [!question]+ 常见问题 
> **Q**: 为什么要区分同步异常和异步异常？ 
> **A**: 因为它们的处理方式完全不同。同步异常通常需要修复问题后重新执行触发异常的指令，而异步异常（如中断）处理完后直接返回到被中断的位置继续执行。
