
在上一章学习了中断的基本概念后，现在让我们深入了解ARM架构下的异常和中断体系。ARM处理器作为嵌入式系统的主流架构，其异常处理机制是理解Linux内核中断系统的基础。

## 1 异常与中断的关系

在学习具体的异常分类之前，我们需要先理解一个重要概念：**在ARM64体系结构中，中断是异常的一个子集**。

换句话说，异常是一个更大的概念，就像"水果"和"苹果"的关系一样，异常是总概念，中断是其中的一种特殊情况。

**异常（Exception）** 包含了：
- **同步异常**：由正在执行的指令引起的
- **异步异常**：与当前执行的指令无关，包括我们熟悉的中断

> [!tip]+ 重要提示 
> **这种分类方式是ARM架构的特点**。在x86等其他架构中，中断和异常可能是并列的概念。理解这种差异对于跨平台开发很重要。

**概念层次关系**
```txt
异常（Exception）
├── 同步异常（Synchronous Exception）
│   ├── 系统调用
│   ├── 数据中止
│   ├── 指令中止
│   └── 其他同步异常
└── 异步异常（Asynchronous Exception）
    ├── IRQ（普通中断）
    ├── FIQ（快速中断）
    └── SError（系统错误）
```

这种层次关系帮助我们理解ARM处理器如何统一处理各种异常情况。

## 2 ARM64异常级别管理

ARM64处理器采用分层特权管理机制，定义了4个异常级别（Exception Levels，EL），从EL0到EL3。这种设计就像政府的权力分级一样，级别越高，访问权限越大，能处理的事务越重要。

**EL0（用户级别）**：
- 最低权限级别
- 用于`普通应用程序`执行
- 不能直接访问硬件资源
- 类比：普通员工只能处理日常业务，不能访问公司机密信息

**EL1（内核级别）**：
- 用于`操作系统内核执行`
- 拥有管理硬件资源的权限
- 可以访问系统寄存器
- 类比：部门经理可以调配部门资源

**EL2（Hypervisor级别）**：
- 用于`虚拟化环境中的监管程序`
- 可以管理多个虚拟机
- 控制EL1的行为
- 类比：总经理可以管理多个部门

**EL3（Secure Monitor级别）**：
- 最高权限级别
- 用于安全相关操作
- 管理安全状态切换
- 类比：董事长拥有最高决策权，可以处理最机密的安全事务

**异常级别切换**
```txt
EL0 (用户空间)
 ↓ 系统调用/异常
EL1 (内核空间)
 ↓ 虚拟化陷入
EL2 (Hypervisor)
 ↓ 安全监控调用
EL3 (Secure Monitor)
```


> [!note]+ 权限分级的意义 
> 这种层次结构确保了系统的安全性和稳定性，防止低权限程序意外或恶意访问高权限资源，就像公司的权限管理制度保护重要信息一样。

## 3 异常的详细分类

异常分类不是为了增加复杂性，而是为了更好地管理和处理不同类型的系统事件。主要目的包括：
- **不同类型的异常需要不同的处理方式**
- **帮助CPU快速定位处理程序**
- **提高系统响应率和稳定性**

就像医院的急诊科会根据病情轻重缓急进行分诊一样，处理器也需要根据异常类型采取不同的处理策略。

> [!example]+ 示例 
> 当程序访问非法内存地址时，会产生同步异常（数据中止），系统需要判断是否可以通过分配内存来修复；而当键盘产生中断时，系统只需要读取按键数据并返回继续执行。

### 3.1 同步异常

同步异常是程序执行指令时直接产生的异常，具有可预测性和精确性。让我们详细了解各种类型：

**1、系统调用异常**：`程序需要内核服务时主动触发的异常`。不同异常级别使用不同的指令：
- **EL0**使用`svc`（Supervisor Call）指令陷入异常级别1
- **EL1**使用`hvc`（Hypervisor Call）指令陷入异常级别2
- **EL2**使用`smc`（Secure Monitor Call）指令陷入异常级别3

> [!example]+ 示例 
> 当用户程序调用`open()`函数打开文件时，最终会通过`svc`指令触发系统调用异常，从用户态切换到内核态。
> 
> ```c
> // 用户空间
> int fd = open("/dev/gpio", O_RDWR);
> // ↓ 触发svc指令
> // 内核空间处理open系统调用
> ```

**2、内存访问异常**：`最常见的同步异常类型`
- **数据中止**：发生时机是访问数据时的页错误异常，常见原因是虚拟地址没有映射到物理地址，或者没有写权限，典型场景是访问未分配的内存，写入只读区域和空指针解引用
- **指令中止**：发生时机是取指令时的页错误异常，常见原因是虚拟地址没有映射到物理地址，或者没有执行权限，典型场景是跳转到无效地址，执行数据区域的内容和返回地址被破坏

> [!warning]+ 警告或注意 
> 这类异常在驱动开发中很常见，通常是由于指针错误或内存管理问题导致的。正确处理这些异常对系统稳定性至关重要。

**3、其他同步异常**：
- **对齐异常**：`栈指针对齐`要求栈指针必须按照特定字节对齐（通常16字节），`指令地址对齐`要求指令地址通常需要4字节对齐
- **未定义指令**：CPU遇到无法识别的指令，可能是代码损坏或跳转到错误地址，用于软件仿真某些指令
- **调试异常**：断点触发的异常，单步执行产生的异常，用于程序调试和性能分析

### 3.2 异步异常

异步异常不是由正在执行的指令生成的，和正在执行的指令没有关联。这就像你正在工作时突然有人敲门，这个事件与你当前的工作内容无关。

**普通中断（IRQ）**：
- **名称**：normal priority interrupt，IRQ
- **性质**：普通优先级的中断
- **用途**：大部分外设使用的中断类型

> [!example]+ 示例 
> 网卡接收到数据包、键盘按键、定时器超时等都是通过IRQ中断通知CPU的。这是最常用的中断类型。

**快速中断（FIQ）**：

- **名称**：fast interrupt，FIQ
- **性质**：高优先级的中断
- **优势**：响应速度更快，优先级更高，有专用的寄存器组

> [!tip]+ 重要提示 
> FIQ通常用于对时间要求极其严格的场合，比如实时控制系统。在一般的Linux系统中，FIQ使用较少，大部分中断都使用IRQ。

**系统错误（SError）**：
- **名称**：System Error，SError
- **触发原因**：由硬件错误触发的异常
- **典型场景**：最常见的是把脏数据从缓存行写回内存时触发异步的数据中止异常，如内存ECC错误、总线传输错误和缓存一致性错误

> [!danger]+ 危险或错误 
> SError通常表示严重的硬件问题，如内存错误、总线错误等，可能导致系统崩溃。

### 5.3 同步异常与异步异常对比

理解同步和异步异常的区别对于编写稳定的系统软件非常重要：

|特性|同步异常|异步异常|
|---|---|---|
|**触发来源**|当前指令执行流程引发|外部事件触发|
|**与指令关联**|与指令执行直接相关|与指令执行无关|
|**触发时机**|精确触发，在指令执行过程中检测到<br>问题时触发|不确定时间触发，受外部硬件信号驱动|
|**常见应用场景**|内存保护、系统调用、调试|外设中断、实时事件处理、<br>硬件错误检测|

换句话说，同步异常就像员工主动请假（可预期的行为），而异步异常就像突发的火灾警报（不可预期的外部事件）

## 4 异常向量表机制

### 4.1 异常向量表的作用

当异常发生的时候，处理器需要执行异常对应的处理程序。**存储异常处理程序的内存位置称为异常向量**，通常把所有异常向量存放在一张表中，称为**异常向量表**。

简单来说，异常向量表就像一个"电话簿"，当发生不同类型的异常时，CPU会在这个"电话簿"找对应的处理程序地址。

> [!note]+ 重要笔记 
> 异常向量表是ARM64处理器异常处理的核心机制，它定义了每种异常类型对应的处理程序入口地址。

### 4.2 向量表结构演进

ARM架构在向量表设计上经历了重要变化：
- **ARMv7架构**：每个表项仅4字节，只能存放一条跳转指令，功能相对简单，需要额外的跳转表。
- **ARMv8架构**：每个表项扩展到128字节，可以存放32条指令，可以完成简单的处理，大大增强了处理能力。

> [!tip]+ 技术细节 
> 虽然ARMv8支持64位架构，但每条指令的位宽仍然是32位，这保证了指令集的一致性和效率。128字节可以容纳32条指令，足够完成基本的上下文保存和跳转。

### 4.3 ARM64异常向量表结构

让我们来看看Linux内核中实际的异常向量表定义。异常向量表按照固定的顺序组织，每种异常都有对应的入口：
```c
/*
 * 异常向量表 - arch/arm64/kernel/entry.S
 */
    .pushsection ".entry.text", "ax"
    .align  11           // 2^11 = 2048字节对齐
ENTRY(vectors)
     #具备 SP0类型的异常向量表描述的当前EL
     kernel_ventry     1, sync_invalid              // EL1t模式下的同步异常
     kernel_ventry     1, irq_invalid               // EL1t模式下的IRQ
     kernel_ventry     1, fiq_invalid               // EL1t模式下的FIQ
     kernel_ventry     1, error_invalid             // EL1t模式下的系统错误
     #具备SPx类型的异常向量表的描述的当前EL
     kernel_ventry     1, sync                      // EL1h模式下的同步异常
     kernel_ventry     1, irq                       // EL1h模式下的IRQ
     kernel_ventry     1, fiq_invalid               // EL1h模式下的FIQ
     kernel_ventry     1, error                     // EL1h模式下的系统错误
     #使用AArch64类型的异常向量表的低EL
     kernel_ventry     0, sync                     // 处于64位EL0下的同步异常
     kernel_ventry     0, irq                      // 处于64位的EL0下的IRQ
     kernel_ventry     0, fiq_invalid              // 处于64位的EL0下的FIQ
     kernel_ventry     0, error                    // 处于64位的EL0下的系统错误
     # 使用AArch32类型的异常向量表的低EL
     kernel_ventry     0, sync_compat, 32          // 处于32位的EL0下的同步异常
     kernel_ventry     0, irq_compat, 32           // 处于32位的EL0下的IRQ
     kernel_ventry     0, fiq_invalid_compat, 32   // 处于32位的EL0的FIQ
     kernel_ventry     0, error_compat, 32         // 处于32位的EL0下的系统错误
END(vectors)
```
- **段声明和对齐**：
	- `.pushsection ".entry.text", "ax"`：将代码放入专门的可执行段，确保向量表被正确加载到内存
	- `.align 11`：确保向量表按2048字节对齐，这是ARM64架构的硬件要求
- **向量表分组**：整个向量表被分为4组，每组4个表项，对应不同的执行状态：
	1. **EL1t模式**：内核级别使用SP_EL0栈指针（很少使用）
	2. **EL1h模式**：内核级别使用SP_EL1栈指针（常用模式）
	3. **64位EL0模式**：用户态64位应用程序
	4. **32位EL0模式**：用户态32位应用程序（兼容模式）
- **异常类型**：每组包含4种异常类型（sync、irq、fiq、error），对应前面介绍的异常分类

> [!tip]+ 重要提示 
> 向量表中的`invalid`条目表示该异常类型在当前配置下不应该发生，如果发生了会触发panic。这是一种防御性编程策略。

### 4.4 kernel_ventry宏实现

`kernel_ventry`是实现向量表的核心宏，让我们深入了解其工作原理：
```c
.macro kernel_ventry, el, label, regsize = 64
    .align 7                    // 128字节对齐
    sub sp, sp, #S_FRAME_SIZE   // 分配栈空间
    b   el\()\el\()_\label      // 跳转到处理函数
.endm
```
- `el`：异常级别参数（0或1），表示异常来源的级别
- `label`：处理函数标签，如sync、irq等
- `regsize`：寄存器大小，默认64位，32位兼容模式时为32

**工作流程详解**：
1. **对齐处理**：
    - `.align 7`确保每个向量表项按128字节对齐
    - 满足ARM64硬件要求
    - 每个异常入口有固定的地址偏移
2. **栈帧分配**：
    - `sub sp, sp, #S_FRAME_SIZE`为异常处理分配栈空间
    - `S_FRAME_SIZE`定义了保存所有CPU寄存器所需的空间
    - 为异常处理"预留座位"
3. **动态跳转**：
    - `b el\()\el\()_\label`通过宏参数动态生成跳转目标
    - 例如：el=1, label=irq → 生成 `b el1_irq`
    - 实现了代码复用

> [!example]+ 宏展开示例 当定义`kernel_ventry 1, irq`时，宏会展开为：
> 
> ```asm
> .align 7
> sub sp, sp, #S_FRAME_SIZE
> b el1_irq
> ```
> 
> 这样就创建了一个内核态IRQ异常的入口点。

### 4.5 异常处理流程

让我们通过一个完整的例子来理解异常处理的流程：

#### 4.5.1 硬件自动操作

当异常发生时，ARM64硬件会自动执行以下操作：
1. **保存返回地址**到ELR_ELx寄存器
2. **保存处理器状态**到SPSR_ELx寄存器
3. **设置异常级别**
4. **选择栈指针**
5. **跳转到异常向量表**对应位置

#### 4.5.2 软件处理流程

```txt
异常发生
    ↓
硬件自动保存状态
    ↓
跳转到异常向量表
    ↓
执行kernel_ventry
    ↓
保存寄存器到栈
    ↓
调用C语言处理函数
    ↓
处理具体异常
    ↓
恢复寄存器状态
    ↓
异常返回（eret指令）
```

> [!example]+ 示例 当发生IRQ中断时，如果当前在用户态（EL0），CPU会：
> 
> 1. 保存用户程序的PC到ELR_EL1
> 2. 保存PSTATE到SPSR_EL1
> 3. 切换到EL1
> 4. 查找向量表中"IRQ from lower EL"对应的入口
> 5. 跳转到`el0_irq`处理函数
>    ![异常处理示例|300](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/63a26c516f2cbd60fd32b3cd0764b52a.png)

## 5 ARM异常处理时序

为了更好地理解异常处理的硬件时序，让我们看看异常从触发到处理完成的详细过程：

### 5.1 异常处理时序图

```txt
时钟周期:  1    2    3    4    5    6    7    8    9   10
         ─┬────┬────┬────┬────┬────┬────┬────┬────┬────┬─
执行指令  │ A  │ B  │ C  │    │    │Vec │ D  │ E  │ F  │
         ─┴────┴────┴────┴────┴────┴────┴────┴────┴────┴─
异常信号  ────────────╱──────────────────────────────────
                     异常
状态保存          │<─保存─>│
                         │<─跳转─>│
                                │<─处理─>│
                                       │<恢复>│

A,B,C: 正常指令执行
Vec: 异常向量表入口
D,E,F: 异常处理指令
```

### 5.2 关键时序点

1. **异常检测**（周期3）：
    - 硬件检测到异常条件
    - 完成当前指令执行
2. **状态保存**（周期4）：
    - 保存PC到ELR寄存器
    - 保存状态到SPSR寄存器
    - 切换异常级别
3. **向量跳转**（周期5）：
    - 计算异常向量地址
    - 跳转到向量表入口
4. **异常处理**（周期6-8）：
    - 执行异常处理代码
    - 保存/恢复上下文
5. **异常返回**（周期9）：
    - 执行eret指令
    - 恢复处理器状态

> [!note]+ 性能考虑 
> 整个异常处理过程需要多个时钟周期，这就是为什么中断处理要尽可能快的原因。每个额外的指令都会增加中断延迟。

## 6 实践案例：处理数据中止异常

让我们通过一个实际的例子来理解异常处理：

```c
// 用户空间代码
int main() {
    int *ptr = NULL;
    *ptr = 42;  // 空指针解引用，触发数据中止异常
    return 0;
}
```

**异常处理流程**：

1. **异常触发**：
    - CPU尝试访问地址0
    - MMU检测到无效访问
    - 触发同步数据中止异常
2. **硬件响应**：
    - 保存故障地址到FAR_EL1
    - 保存异常原因到ESR_EL1
    - 跳转到异常向量表
3. **软件处理**：
    ```c
    // 内核中的处理函数
    static void do_page_fault(unsigned long addr, 
                            unsigned int esr,
                            struct pt_regs *regs) {
        // 检查是否可以处理
        if (addr < PAGE_SIZE && !user_mode(regs)) {
            // 内核空指针，触发panic
            die("Kernel NULL pointer dereference", regs, esr);
        }
        // 用户空间错误，发送SIGSEGV信号
        force_sig_fault(SIGSEGV, SEGV_MAPERR, addr);
    }
    ```
    

## 7 小结

通过本章的学习，我们深入理解了ARM架构下的异常和中断体系：

> [!abstract]+ 总结 
> **核心要点**：
> 
> - ARM64中，中断是异常的子集，异常包括同步和异步两大类
> - 4个异常级别提供了完善的权限管理机制
> - 同步异常与指令执行相关，异步异常由外部事件触发
> - 异常向量表是异常处理的核心，提供了统一的入口机制
> - 每个异常入口有128字节空间，可以完成基本处理
> - 硬件和软件协作完成异常的快速处理

理解ARM异常体系是掌握Linux中断处理的基础。异常向量表就像是CPU的"调度中心"，确保各种异常都能得到正确及时的处理。

> [!question]+ 思考题
> 
> 1. 为什么ARM要把中断归类为异常的一种？这种设计有什么优势？
> 2. 在什么情况下会用到FIQ而不是IRQ？
> 3. 异常向量表为什么要严格对齐？不对齐会有什么后果？

在下一章中，我们将学习Linux如何在ARM异常机制的基础上构建完整的中断子系统架构。