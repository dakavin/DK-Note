
之前我们在[3 中断控制与资源管理](5_中断相关API.md#3%20中断控制与资源管理)中学习了简单的中断控制，现在我们需要学习一个实际开发中经常遇到的问题：**如何控制中断的启用和禁用？**

简单来说，**中断控制**就像是给设备装上"开关"，我们可以选择性地关闭某些中断，或者在特定时刻暂时关闭所有中断。这个机制让我们能够精确控制系统的响应行为，确保关键代码不被打断。

> [!note]+ 重要笔记
> 
> 中断控制是系统编程的重要技能，正确使用这些接口能够保证代码执行的原子性，避免竞态条件，但使用不当也可能导致系统响应延迟或死锁。

## 1 全局中断控制机制

### 1.1 中断禁用的基本概念

**软件可以禁止中断**，使处理器不响应所有中断请求，但是**不可屏蔽中断（Non Maskable Interrupt，NMI）** 是个例外。

换句话说，就像给房间安装了总闸开关一样，我们可以一次性关闭所有电器，但是紧急安全设备（如烟雾报警器）仍然会工作。NMI就是那个"烟雾报警器"，即使关闭了总开关，它依然能够工作。

> [!warning]+ 警告或注意
> 
> 禁用中断是一个强大但危险的操作，使用时必须谨慎，确保禁用时间尽可能短，否则会影响系统的实时性和稳定性。

### 1.2 中断禁用接口详解

**禁止中断的接口**
- `local_irq_save(flags)`：首先把中断状态保存在参数flags中，然后禁止中断
- `local_irq_disable()`：直接禁止本处理器的中断

> [!tip]+ 重要提示
> 
> 这两个接口只能禁止**本处理器**的中断，不能禁止其他处理器的中断。在多核系统中，每个处理器都有独立的中断控制

**ARM64架构的具体实现**：让我们看看ARM64架构是如何实现中断禁用的：
```c
// local_irq_disable() -> raw_local_irq_disable() -> arch_local_irq_disable()

// arch/arm64/include/asm/irqflags.h
static inline void arch_local_irq_disable(void)
{
    asm volatile(
        "msr    daifset, #2    // arch_local_irq_disable"
        :
        :
        : "memory");
}
```

**代码说明**：这段汇编代码的作用是把处理器状态的**中断掩码位设置成1**，从此以后处理器不会响应中断请求。`daifset`指令用于设置处理器状态寄存器中的特定位

### 1.3 中断启用接口详解

**开启中断的接口**：
- **local_irq_enable()**：直接开启本处理器的中断
- **local_irq_restore(flags)**：恢复本处理器的中断状态

> [!warning]+ 警告或注意
> 
> **local_irq_disable()**和**local_irq_enable()**不能嵌套使用，但**local_irq_save(flags)**和**local_irq_restore(flags)**可以嵌套使用。

**ARM64架构开启中断的实现**：
```c
// local_irq_enable() -> raw_local_irq_enable() -> arch_local_irq_enable()

// arch/arm64/include/asm/irqflags.h
static inline void arch_local_irq_enable(void)
{
    asm volatile(
        "msr    daifclr, #2    // arch_local_irq_enable"
        :
        :
        : "memory");
}
```

**代码说明**：这段代码把处理器状态的**中断掩码位设置成0**，重新启用中断响应。`daifclr`指令用于清除处理器状态寄存器中的特定位。

### 1.4 嵌套使用的重要性

为什么推荐使用save/restore组合呢？让我们通过一个实际场景来理解：

> [!example]+ 示例
> 
> **函数A**调用`local_irq_disable()`关闭中断，然后调用**函数B** **函数B**也需要关闭中断，于是也调用`local_irq_disable()` **函数B**执行完毕，调用`local_irq_enable()`开启中断 此时**函数A**还没执行完，但中断已经被提前开启了，这可能导致竞态条件
> 
> 如果使用save/restore组合，每个函数都会记住进入时的中断状态，退出时恢复到正确的状态。

## 2 单个中断控制机制

### 2.1 单个中断控制的概念

除了全局中断控制，**软件还可以禁止某个外围设备的中断**，这时中断控制器不会把该设备发送的中断转发给处理器。

简单来说，这就像给每个电器单独安装开关，我们可以选择性地关闭某些设备，而让其他设备正常工作。这种精细化控制在实际开发中非常有用。

### 2.2 单个中断禁用函数

```c
void disable_irq(unsigned int irq);
```
- **irq**：Linux中断号，通过之前学习的方法获得
- **作用**：禁用指定的中断源，该中断不再被转发给处理器

**使用场景**：
- 临时关闭某个设备的中断响应
- 在设备初始化或配置期间避免中断干扰
- 调试时隔离特定的中断源

> [!warning]+ 警告或注意
> 
> disable_irq函数要等到当前正在执行的中断处理函数执行完才返回，因此使用者需要保证不会产生新的中断，并且确保所有已经开始执行的中断处理程序已经全部退出。

在某些情况下，我们不想等待当前中断处理完成，可以使用另外一个中断禁止函数：
```c
void disable_irq_nosync(unsigned int irq)
```

**disable_irq_nosync**函数调用以后立即返回，不会等待当前中断处理程序执行完毕。

### 2.3 单个中断启用函数

```c
void enable_irq(unsigned int irq);
```
- **irq**：Linux中断号
- **作用**：启用指定的中断源，恢复中断转发

### 2.4 GIC控制器的硬件实现

对于**ARM64架构的GIC控制器**，中断的启用和禁用是通过操作特定寄存器实现的：
- **启用中断**：设置分发器的寄存器**GICD_ISENABLERn**（Interrupt Set-Enable Register）
- **禁用中断**：设置分发器的寄存器**GICD_ICENABLERn**（Interrupt Clear-Enable Register）

> [!tip]+ 重要提示
> 
> 假设某个外围设备的硬件中断号是n，当这个外围设备发送中断给分发器时，只有在分发器上开启了硬件中断n，分发器才会把硬件中断n转发给处理器。

**工作流程**：
1. 外设产生中断信号发送给GIC分发器
2. 分发器检查对应的GICD_ISENABLERn寄存器位
3. 如果该位为1，则转发中断给目标处理器
4. 如果该位为0，则忽略该中断信号

### 2.5 实际应用示例

```c
// 临时禁用串口中断进行配置
disable_irq(uart_irq);

// 配置串口硬件寄存器
configure_uart_registers();

// 重新启用串口中断
enable_irq(uart_irq);
```

**代码说明**：在配置硬件寄存器期间，我们临时禁用相关中断，避免配置过程中的意外中断干扰，配置完成后再重新启用。

> [!warning]+ 警告或注意
> 
> 使用disable_irq/enable_irq时要确保配对使用，避免忘记重新启用中断导致设备失去响应能力。

## 3 总结

通过这个章节的学习，我们掌握了中断控制的核心技术：

> [!abstract]+ 摘要或总结
> 
> **核心技能掌握**：
> 
> - 理解了全局中断控制和单个中断控制的区别和应用场景
> - 掌握了正确的中断禁用和启用接口使用方法
> - 学会了嵌套中断控制的安全实践方法
> - 了解了ARM64架构的底层实现机制和GIC控制器原理
> - 认识了中断控制在实际开发中的重要作用

中断控制是系统编程的基础技能，正确使用这些接口能够确保代码的原子性和系统的稳定性。在下一章节中，我们将学习中断处理的具体实现，了解当中断发生时系统内部的详细处理流程。

> [!question]+ 常见问题
> 
> **Q**: 什么时候应该使用全局中断禁用，什么时候使用单个中断禁用？ 
> **A**: 全局中断禁用适用于保护非常短的临界区代码，而单个中断禁用适用于特定设备的维护或调试。一般原则是能用单个中断控制就不用全局控制，以减少对系统整体响应性的影响。
