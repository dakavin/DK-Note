
åœ¨å­¦ä¹ äº†æ€»çº¿å’Œè®¾å¤‡çš„å·¥ä½œåŸç†åï¼Œç°åœ¨è®©æˆ‘ä»¬æ·±å…¥äº†è§£è®¾å¤‡æ¨¡å‹çš„å¦ä¸€ä¸ªé‡è¦ç»„æˆéƒ¨åˆ†ï¼š**è®¾å¤‡é©±åŠ¨**ã€‚é©±åŠ¨ç¨‹åºæ˜¯è¿æ¥ç¡¬ä»¶è®¾å¤‡ä¸æ“ä½œç³»ç»Ÿçš„æ¡¥æ¢ï¼Œè´Ÿè´£æ§åˆ¶å’Œç®¡ç†è®¾å¤‡çš„å…·ä½“æ“ä½œã€‚

ç®€å•æ¥è¯´ï¼Œ**è®¾å¤‡é©±åŠ¨**å°±æ˜¯å‘Šè¯‰å†…æ ¸"å¦‚ä½•ä¸ç‰¹å®šç¡¬ä»¶è®¾å¤‡å¯¹è¯"çš„ç¨‹åºï¼Œå®ƒå®šä¹‰äº†è®¾å¤‡çš„æ“ä½œæ–¹æ³•å’Œç®¡ç†ç­–ç•¥ã€‚

> [!note]+ å­¦ä¹ é‡ç‚¹ 
> æœ¬ç« å°†æ·±å…¥åˆ†æé©±åŠ¨çš„ç»“æ„ä½“å®šä¹‰ã€æ³¨å†Œæµç¨‹ã€åŒ¹é…æœºåˆ¶ï¼Œå¹¶é€šè¿‡å®é™…ç¼–ç¨‹æŒæ¡é©±åŠ¨çš„å¼€å‘å’Œè°ƒè¯•æŠ€å·§ã€‚

## 1 è®¾å¤‡é©±åŠ¨çš„æ ¸å¿ƒæ¦‚å¿µ

### 1.1 é©±åŠ¨åœ¨è®¾å¤‡æ¨¡å‹ä¸­çš„ä½œç”¨

**è®¾å¤‡é©±åŠ¨**æ˜¯è®¾å¤‡æ¨¡å‹ä¸­çš„è½¯ä»¶ç»„ä»¶ï¼Œç”¨äºæ§åˆ¶å’Œç®¡ç†è®¾å¤‡çš„æ“ä½œã€‚æ¯ä¸ªè®¾å¤‡éƒ½éœ€è¦ç›¸åº”çš„é©±åŠ¨ç¨‹åºæ¥ä¸æ“ä½œç³»ç»Ÿè¿›è¡Œäº¤äº’å’Œé€šä¿¡ã€‚

**ä¸»è¦èŒè´£**ï¼š
- **è®¾å¤‡åˆå§‹åŒ–**ï¼šprobeå‡½æ•°ä¸­åˆå§‹åŒ–è®¾å¤‡ç¡¬ä»¶
- **è®¾å¤‡æ§åˆ¶**ï¼šæä¾›è®¾å¤‡æ“ä½œæ¥å£
- **èµ„æºç®¡ç†**ï¼šç®¡ç†è®¾å¤‡ä½¿ç”¨çš„å†…å­˜ã€ä¸­æ–­ç­‰èµ„æº
- **ç”µæºç®¡ç†**ï¼šå¤„ç†è®¾å¤‡çš„ç”µæºçŠ¶æ€è½¬æ¢
- **äº‹ä»¶å¤„ç†**ï¼šå“åº”è®¾å¤‡äº§ç”Ÿçš„ä¸­æ–­å’Œäº‹ä»¶

**é©±åŠ¨ä¸è®¾å¤‡çš„å…³ç³»**ï¼š
- ä¸€ä¸ªé©±åŠ¨å¯ä»¥æ”¯æŒå¤šä¸ªç›¸åŒç±»å‹çš„è®¾å¤‡
- ä¸€ä¸ªè®¾å¤‡åªèƒ½ç»‘å®šä¸€ä¸ªé©±åŠ¨
- é©±åŠ¨å’Œè®¾å¤‡é€šè¿‡æ€»çº¿è¿›è¡ŒåŒ¹é…å’Œç»‘å®š

> [!tip]+ è®¾è®¡ç†å¿µ 
> é©±åŠ¨ç¨‹åºå°†å…·ä½“çš„ç¡¬ä»¶æ“ä½œæŠ½è±¡ä¸ºç»Ÿä¸€çš„è½¯ä»¶æ¥å£ï¼Œä½¿å¾—ä¸Šå±‚åº”ç”¨ç¨‹åºå¯ä»¥é€šè¿‡æ ‡å‡†çš„ç³»ç»Ÿè°ƒç”¨æ¥è®¿é—®å„ç§ä¸åŒçš„ç¡¬ä»¶è®¾å¤‡ã€‚

## 2 device_driverç»“æ„ä½“è¯¦è§£

### 2.1 ç»“æ„ä½“å®šä¹‰

é©±åŠ¨åœ¨å†…æ ¸ä¸­é€šè¿‡`device_driver`ç»“æ„ä½“æ¥è¡¨ç¤ºï¼Œå®šä¹‰åœ¨`include/linux/device.h`å¤´æ–‡ä»¶ä¸­ï¼š
```c
struct device_driver {
    const char              *name;         // é©±åŠ¨åç§°
    struct bus_type         *bus;          // æ‰€å±æ€»çº¿
    struct module           *owner;        // æ‹¥æœ‰è¯¥é©±åŠ¨çš„æ¨¡å—
    const char              *mod_name;     // æ¨¡å—åç§°
    
    // è®¾å¤‡åŒ¹é…å’Œæ¢æµ‹
    bool suppress_bind_attrs;               // ç¦ç”¨ç»‘å®šå±æ€§
    enum probe_type probe_type;             // æ¢æµ‹ç±»å‹
    
    // è®¾å¤‡åŒ¹é…è¡¨
    const struct of_device_id       *of_match_table;    // è®¾å¤‡æ ‘åŒ¹é…è¡¨
    const struct acpi_device_id     *acpi_match_table;  // ACPIåŒ¹é…è¡¨
    
    // å±æ€§ç»„
    const struct attribute_group    **groups;           // é©±åŠ¨å±æ€§ç»„
    
    // æ ¸å¿ƒå›è°ƒå‡½æ•°
    int (*probe) (struct device *dev);                  // æ¢æµ‹å‡½æ•°
    int (*remove) (struct device *dev);                 // ç§»é™¤å‡½æ•°
    void (*shutdown) (struct device *dev);              // å…³æœºå‡½æ•°
    int (*suspend) (struct device *dev, pm_message_t state);  // æŒ‚èµ·å‡½æ•°
    int (*resume) (struct device *dev);                 // æ¢å¤å‡½æ•°
    
    // ç”µæºç®¡ç†
    const struct dev_pm_ops         *pm;                // ç”µæºç®¡ç†æ“ä½œ
    void (*coredump) (struct device *dev);              // æ ¸å¿ƒè½¬å‚¨å‡½æ•°
    
    // ç§æœ‰æ•°æ®
    struct driver_private           *p;                  // é©±åŠ¨ç§æœ‰æ•°æ®
};
```
- `name`ï¼šé©±åŠ¨çš„åç§°ï¼Œç”¨äºä¸è®¾å¤‡åŒ¹é…
- `bus`ï¼šé©±åŠ¨æ‰€å±çš„æ€»çº¿ç±»å‹
- `probe`ï¼šè®¾å¤‡æ¢æµ‹å’Œåˆå§‹åŒ–å‡½æ•°
- `remove`ï¼šè®¾å¤‡ç§»é™¤å’Œæ¸…ç†å‡½æ•°

> [!important]+ ğŸ”‘ å…³é”®ç†è§£ï¼šprobeå‡½æ•°
> - **æ™®é€šå‡½æ•°ä»mainå‡½æ•°å¼€å§‹æ‰§è¡Œï¼Œè€Œå†…æ ¸é©±åŠ¨ç¨‹åºä»probeå‡½æ•°å¼€å§‹æ‰§è¡Œï¼**
> - probeå‡½æ•°å°±æ˜¯é©±åŠ¨ç¨‹åºçš„â€œå…¥å£ç‚¹â€


**driver_privateç§æœ‰æ•°æ®**ï¼š
```c
struct driver_private {
    struct kobject kobj;                    // é©±åŠ¨çš„kobjectè¡¨ç¤º
    struct klist klist_devices;            // è¯¥é©±åŠ¨ç®¡ç†çš„è®¾å¤‡é“¾è¡¨
    struct klist_node knode_bus;           // åœ¨æ€»çº¿é©±åŠ¨é“¾è¡¨ä¸­çš„èŠ‚ç‚¹
    struct module_kobject *mkobj;           // å…³è”çš„æ¨¡å—kobject
    struct device_driver *driver;          // å›æŒ‡é©±åŠ¨ç»“æ„ä½“
};
```

> [!info]+ è®¾è®¡ç‰¹ç‚¹ 
> driver_privateå°è£…äº†é©±åŠ¨çš„æ‰€æœ‰ç§æœ‰æ•°æ®ï¼ŒåŒ…æ‹¬kobjectè¡¨ç¤ºã€è®¾å¤‡é“¾è¡¨ã€æ€»çº¿å…³ç³»ç­‰ï¼Œä½“ç°äº†è‰¯å¥½çš„æ•°æ®å°è£…è®¾è®¡ã€‚

### 2.3 é©±åŠ¨çš„kobjectå±‚æ¬¡ç»“æ„

æ¯ä¸ªé©±åŠ¨åœ¨ç³»ç»Ÿä¸­éƒ½æœ‰å¯¹åº”çš„kobjectè¡¨ç¤ºï¼š
```txt
device_driver
    +----------------------------------+
    |name                              |
    |bus                               |
    |owner                             |
    |probe                             |
    |remove                            |
    |shutdown                          |
    |suspend                           |
    |resume                            |
    |                                  |
    +----------------------------------+
    |p                                 |
    |    (struct driver_private*)      |
    |    +-----------------------------+
    |    |driver                       |
    |    |    (struct device_driver*)  |
    |    |kobj                         |
    |    |    +------------------------+
    |    |    |name                    | = device_driver->name
    |    |    |kset                    | = device_driver->bus->p->drivers_kset
    |    |    |ktype                   | = driver_ktype
    |    |    +------------------------+
    |    |klist_devices                |
    |    |                             |
    +----+-----------------------------+
```

è¿™ç§è®¾è®¡ä½¿å¾—æ¯ä¸ªé©±åŠ¨åœ¨sysfsä¸­éƒ½æœ‰å¯¹åº”çš„ç›®å½•å’Œå±æ€§æ–‡ä»¶ã€‚

## 3 é©±åŠ¨æ³¨å†Œæµç¨‹æ·±åº¦è§£æ

### 3.1 driver_registerå‡½æ•°åˆ†æ

**driver_registerå‡½æ•°çš„æ ¸å¿ƒå®ç°**ï¼š
```c fold
int driver_register(struct device_driver *drv)
{
    int ret;
    struct device_driver *other;

    // ç¬¬ä¸€æ­¥ï¼šæ£€æŸ¥æ€»çº¿æ˜¯å¦å·²åˆå§‹åŒ–
    if (!drv->bus->p) {
        pr_err("Driver '%s' was unable to register with bus_type '%s' because the bus was not initialized.\n",
               drv->name, drv->bus->name);
        return -EINVAL;
    }

    // ç¬¬äºŒæ­¥ï¼šæ£€æŸ¥é©±åŠ¨ç¨‹åºçš„æ–¹æ³•æ˜¯å¦éœ€è¦æ›´æ–°
    if ((drv->bus->probe && drv->probe) ||
        (drv->bus->remove && drv->remove) ||
        (drv->bus->shutdown && drv->shutdown))
        printk(KERN_WARNING "Driver '%s' needs updating - please use "
               "bus_type methods\n", drv->name);

    // ç¬¬ä¸‰æ­¥ï¼šæ£€æŸ¥é©±åŠ¨ç¨‹åºæ˜¯å¦å·²è¢«æ³¨å†Œ
    other = driver_find(drv->name, drv->bus);
    if (other) {
        printk(KERN_ERR "Error: Driver '%s' is already registered, "
               "aborting...\n", drv->name);
        return -EBUSY;
    }

    // ç¬¬å››æ­¥ï¼šå°†é©±åŠ¨ç¨‹åºæ·»åŠ åˆ°æ€»çº¿
    ret = bus_add_driver(drv);
    if (ret)
        return ret;
        
    // ç¬¬äº”æ­¥ï¼šæ·»åŠ é©±åŠ¨ç¨‹åºçš„ç»„å±æ€§
    ret = driver_add_groups(drv, drv->groups);
    if (ret) {
        bus_remove_driver(drv);
        return ret;
    }
    
    // ç¬¬å…­æ­¥ï¼šå‘é€å†…æ ¸å¯¹è±¡äº‹ä»¶ï¼Œé€šçŸ¥é©±åŠ¨ç¨‹åºæ·»åŠ æˆåŠŸ
    kobject_uevent(&drv->p->kobj, KOBJ_ADD);

    return ret;
}
EXPORT_SYMBOL_GPL(driver_register);
```

### 3.2 bus_add_driverè¯¦ç»†åˆ†æ

é©±åŠ¨æ³¨å†Œçš„æ ¸å¿ƒå·¥ä½œåœ¨`bus_add_driver`å‡½æ•°ä¸­å®Œæˆï¼š
```c fold
int bus_add_driver(struct device_driver *drv)
{
    struct bus_type *bus;
    struct driver_private *priv;
    int error = 0;

    // è·å–æ€»çº¿å¯¹è±¡
    bus = bus_get(drv->bus);
    if (!bus)
        return -EINVAL;

    pr_debug("bus: '%s': add driver %s\n", bus->name, drv->name);
    
    // ç¬¬ä¸€æ­¥ï¼šåˆ†é…å¹¶åˆå§‹åŒ–é©±åŠ¨ç¨‹åºç§æœ‰æ•°æ®
    priv = kzalloc(sizeof(*priv), GFP_KERNEL);
    if (!priv) {
        error = -ENOMEM;
        goto out_put_bus;
    }
    
    // åˆå§‹åŒ–è®¾å¤‡é“¾è¡¨å’Œå…³è”å…³ç³»
    klist_init(&priv->klist_devices, NULL, NULL);
    priv->driver = drv;
    drv->p = priv;
    priv->kobj.kset = bus->p->drivers_kset;

    // ç¬¬äºŒæ­¥ï¼šåˆå§‹åŒ–å¹¶æ·»åŠ é©±åŠ¨ç¨‹åºçš„å†…æ ¸å¯¹è±¡
    error = kobject_init_and_add(&priv->kobj, &driver_ktype, NULL,
                                 "%s", drv->name);
    if (error)
        goto out_unregister;

    // ç¬¬ä¸‰æ­¥ï¼šå°†é©±åŠ¨ç¨‹åºæ·»åŠ åˆ°æ€»çº¿çš„é©±åŠ¨ç¨‹åºåˆ—è¡¨
    klist_add_tail(&priv->knode_bus, &bus->p->klist_drivers);
    
    // ç¬¬å››æ­¥ï¼šè‡ªåŠ¨æ¢æµ‹è®¾å¤‡ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    if (drv->bus->p->drivers_autoprobe) {  // é»˜è®¤ä¸º1
        error = driver_attach(drv);
        if (error)
            goto out_unregister;
    }

    // ç¬¬äº”æ­¥ï¼šå°†é©±åŠ¨ç¨‹åºæ·»åŠ åˆ°æ¨¡å—
    module_add_driver(drv->owner, drv);

    // ç¬¬å…­æ­¥ï¼šåˆ›å»ºé©±åŠ¨ç¨‹åºçš„ueventå±æ€§æ–‡ä»¶
    error = driver_create_file(drv, &driver_attr_uevent);
    if (error) {
        printk(KERN_ERR "%s: uevent attr (%s) failed\n",
               __func__, drv->name);
    }
    
    // ç¬¬ä¸ƒæ­¥ï¼šæ·»åŠ é©±åŠ¨ç¨‹åºçš„ç»„å±æ€§
    error = driver_add_groups(drv, bus->drv_groups);
    if (error) {
        printk(KERN_ERR "%s: driver_create_groups(%s) failed\n",
               __func__, drv->name);
    }

    // ç¬¬å…«æ­¥ï¼šæ·»åŠ ç»‘å®šå±æ€§æ–‡ä»¶ï¼ˆå¦‚æœä¸ç¦æ­¢ï¼‰
    if (!drv->suppress_bind_attrs) {
        error = add_bind_files(drv);
        if (error) {
            printk(KERN_ERR "%s: add_bind_files(%s) failed\n",
                   __func__, drv->name);
        }
    }

    return 0;

out_unregister:
    kobject_put(&priv->kobj);
    drv->p = NULL;
out_put_bus:
    bus_put(bus);
    return error;
}
```

> [!tip]+ å…³é”®æ­¥éª¤ 
> é©±åŠ¨æ³¨å†Œçš„å…³é”®åœ¨äºåˆ›å»ºsysfsç›®å½•ã€åˆå§‹åŒ–è®¾å¤‡é“¾è¡¨ã€æ·»åŠ åˆ°æ€»çº¿ç®¡ç†ä»¥åŠè‡ªåŠ¨æ¢æµ‹è®¾å¤‡ã€‚

## 4 è®¾å¤‡æ¢æµ‹å’ŒåŒ¹é…æœºåˆ¶

ç»è¿‡å‰é¢çš„åˆ†æï¼Œæˆ‘ä»¬çŸ¥é“åœ¨æ³¨å†Œé©±åŠ¨çš„æ—¶å€™æœ‰å¦‚ä¸‹å‡½æ•°è°ƒç”¨è·¯å¾„
```c
driver_register -> bus_add_driver -> driver_attach
```

### 4.1 driver_attachæµç¨‹

å½“é©±åŠ¨æ³¨å†Œæ—¶ï¼Œä¼šè‡ªåŠ¨è°ƒç”¨`driver_attach`å‡½æ•°æ¥æ¢æµ‹å’ŒåŒ¹é…è®¾å¤‡ï¼š

```c
int driver_attach(struct device_driver *drv)
{
    return bus_for_each_dev(drv->bus, NULL, drv, __driver_attach);
}
EXPORT_SYMBOL_GPL(driver_attach);
```

### 4.2 bus_for_each_devå®ç°

```c
int bus_for_each_dev(struct bus_type *bus, struct device *start,
                     void *data, int (*fn)(struct device *, void *))
{
    struct klist_iter i;
    struct device *dev;
    int error = 0;

    // æ£€æŸ¥æ€»çº¿å¯¹è±¡æ˜¯å¦å­˜åœ¨
    if (!bus || !bus->p)
        return -EINVAL;

    // åˆå§‹åŒ–è®¾å¤‡åˆ—è¡¨è¿­ä»£å™¨
    klist_iter_init_node(&bus->p->klist_devices, &i,
                         (start ? &start->p->knode_bus : NULL));
    
    // éå†è®¾å¤‡åˆ—è¡¨å¹¶æ‰§è¡ŒæŒ‡å®šçš„å‡½æ•°
    while (!error && (dev = next_device(&i)))
        error = fn(dev, data);  // è°ƒç”¨__driver_attach
        
    // é€€å‡ºè®¾å¤‡åˆ—è¡¨è¿­ä»£å™¨
    klist_iter_exit(&i);
    return error;
}
EXPORT_SYMBOL_GPL(bus_for_each_dev);
```

### 4.3 `__driver_attach`æ ¸å¿ƒé€»è¾‘

```c fold
static int __driver_attach(struct device *dev, void *data)
{
    struct device_driver *drv = data;
    int ret;

    // ç¬¬ä¸€æ­¥ï¼šå°è¯•å°†é©±åŠ¨ç¨‹åºç»‘å®šåˆ°è®¾å¤‡ä¸Š
    ret = driver_match_device(drv, dev);
    if (ret == 0) {
        return 0;  // æ²¡æœ‰åŒ¹é…
    } else if (ret == -EPROBE_DEFER) {
        dev_dbg(dev, "Device match requests probe deferral\n");
        driver_deferred_probe_add(dev);  // å»¶è¿Ÿæ¢æµ‹
    } else if (ret < 0) {
        dev_dbg(dev, "Bus failed to match device: %d", ret);
        return ret;  // åŒ¹é…å¤±è´¥
    }
    // ret > 0 è¡¨ç¤ºåŒ¹é…æˆåŠŸ

    // ç¬¬äºŒæ­¥ï¼šæ£€æŸ¥æ˜¯å¦æ”¯æŒå¼‚æ­¥æ¢æµ‹
    if (driver_allows_async_probing(drv)) {
        // å¼‚æ­¥æ¢æµ‹
        dev_dbg(dev, "probing driver %s asynchronously\n", drv->name);
        device_lock(dev);
        if (!dev->driver) {
            get_device(dev);
            dev->p->async_driver = drv;
            async_schedule(__driver_attach_async_helper, dev);
        }
        device_unlock(dev);
        return 0;
    }

    // ç¬¬ä¸‰æ­¥ï¼šåŒæ­¥æ¢æµ‹è®¾å¤‡å¹¶ç»‘å®šé©±åŠ¨ç¨‹åº
    device_driver_attach(drv, dev);

    return 0;
}
```

### 4.4 driver_match_deviceåŒ¹é…æ£€æŸ¥

```c
static inline int driver_match_device(struct device_driver *drv,
                                     struct device *dev)
{
    return drv->bus->match ? drv->bus->match(dev, drv) : 1;
}
```

è¿™ä¸ªå‡½æ•°è°ƒç”¨æ€»çº¿çš„matchå‡½æ•°æ¥åˆ¤æ–­è®¾å¤‡å’Œé©±åŠ¨æ˜¯å¦åŒ¹é…ã€‚

## 5 è®¾å¤‡é©±åŠ¨å®è·µ

### 5.1 è‡ªå®šä¹‰é©±åŠ¨å®ç°

è®©æˆ‘ä»¬åœ¨å‰é¢åˆ›å»ºçš„è‡ªå®šä¹‰æ€»çº¿ä¸Šæ³¨å†Œä¸€ä¸ªé©±åŠ¨ï¼š

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/device.h>
#include <linux/sysfs.h>

// å¼•ç”¨å¤–éƒ¨å®šä¹‰çš„æ€»çº¿
extern struct bus_type mybus;

// é©±åŠ¨çš„ç§æœ‰æ•°æ®
struct mydrv_data {
    int status;
    int config;
    char name[32];
};

// å…¨å±€é©±åŠ¨æ•°æ®
static struct mydrv_data mydrv_data = {
    .status = 1,
    .config = 0,
    .name = "DKCustomDriver",
};

// é©±åŠ¨çš„removeå‡½æ•°
static int mydrv_remove(struct device *dev){
        printk(KERN_INFO "mydriver: ç§»é™¤è®¾å¤‡ [%s]\n", dev_name(dev));
    
    // åœ¨è¿™é‡Œè¿›è¡Œè®¾å¤‡ç›¸å…³çš„æ¸…ç†å·¥ä½œ
    // ä¾‹å¦‚ï¼šé‡Šæ”¾ä¸­æ–­ã€åœæ­¢DMAã€é‡Šæ”¾I/Oç«¯å£ç­‰
    
    return 0;
}

// é©±åŠ¨çš„probeå‡½æ•°
static int mydrv_probe(struct device *dev){ 
    printk(KERN_INFO "mydriver: æ¢æµ‹åˆ°è®¾å¤‡ [%s]\n", dev_name(dev));
    
    // åœ¨è¿™é‡Œè¿›è¡Œè®¾å¤‡åˆå§‹åŒ–å·¥ä½œ
    // ä¾‹å¦‚ï¼šç”³è¯·ä¸­æ–­ã€åˆå§‹åŒ–ç¡¬ä»¶ã€åˆ›å»ºè®¾å¤‡æ–‡ä»¶ç­‰
    
    // å°†é©±åŠ¨æ•°æ®å…³è”åˆ°è®¾å¤‡
    dev_set_drvdata(dev, &mydrv_data);
    
    printk(KERN_INFO "mydriver: è®¾å¤‡ [%s] åˆå§‹åŒ–å®Œæˆ\n", dev_name(dev));
    
    return 0;  // è¿”å›0è¡¨ç¤ºæˆåŠŸ
}

// é©±åŠ¨çš„shutdownå‡½æ•°
static void mydrv_shutdown(struct device *dev)
{
    printk(KERN_INFO "mydriver: å…³é—­è®¾å¤‡ [%s]\n", dev_name(dev));
    
    // åœ¨ç³»ç»Ÿå…³æœºæ—¶çš„æ¸…ç†å·¥ä½œ
}

// é©±åŠ¨çš„suspendå‡½æ•°
static int mydrv_suspend(struct device *dev, pm_message_t state)
{
    printk(KERN_INFO "mydriver: æŒ‚èµ·è®¾å¤‡ [%s]\n", dev_name(dev));
    
    // ä¿å­˜è®¾å¤‡çŠ¶æ€ï¼Œå‡†å¤‡è¿›å…¥ä½åŠŸè€—æ¨¡å¼
    
    return 0;
}

// é©±åŠ¨çš„resumeå‡½æ•°
static int mydrv_resume(struct device *dev)
{
    printk(KERN_INFO "mydriver: æ¢å¤è®¾å¤‡ [%s]\n", dev_name(dev));
    
    // æ¢å¤è®¾å¤‡çŠ¶æ€ï¼Œä»ä½åŠŸè€—æ¨¡å¼å”¤é†’
    
    return 0;
}

//å®šä¹‰è®¾å¤‡é©±åŠ¨ç»“æ„ä½“
struct device_driver mydrv = {
    .name     = "mydev",           // é©±åŠ¨åç§°ï¼ˆç”¨äºåŒ¹é…ï¼‰
    .bus      = &mybus,               // æ‰€å±æ€»çº¿
    .owner    = THIS_MODULE,          // æ‹¥æœ‰è¯¥é©±åŠ¨çš„æ¨¡å—
    .probe    = mydrv_probe,       // æ¢æµ‹å‡½æ•°
    .remove   = mydrv_remove,      // ç§»é™¤å‡½æ•°
    .shutdown = mydrv_shutdown,    // å…³æœºå‡½æ•°
    .suspend  = mydrv_suspend,     // æŒ‚èµ·å‡½æ•°
    .resume   = mydrv_resume,      // æ¢å¤å‡½æ•°
};

// æ¨¡å—åˆå§‹åŒ–å‡½æ•°
static int __init mydrv_init(void)
{
    int ret;
    
    printk(KERN_INFO "mydrv: å¼€å§‹æ³¨å†Œé©±åŠ¨ç¨‹åº\n");
    
    // æ³¨å†Œé©±åŠ¨
    ret = driver_register(&mydrv);
    if (ret) {
        printk(KERN_ERR "mydrv: é©±åŠ¨æ³¨å†Œå¤±è´¥ï¼Œé”™è¯¯ç  %d\n", ret);
        return ret;
    }
    
    printk(KERN_INFO "mydrv: é©±åŠ¨æ³¨å†ŒæˆåŠŸ\n");
    printk(KERN_INFO "mydrv: å¯æŸ¥çœ‹ /sys/bus/mybus/drivers/mydevice/\n");
    
    return 0;
}

// æ¨¡å—é€€å‡ºå‡½æ•°
static void __exit mydrv_exit(void)
{
    printk(KERN_INFO "mydrv: å¼€å§‹æ³¨é”€é©±åŠ¨ç¨‹åº\n");
    
    // æ³¨é”€é©±åŠ¨
    driver_unregister(&mydrv);
    
    printk(KERN_INFO "mydrv: é©±åŠ¨æ³¨é”€å®Œæˆ\n");
}

module_init(mydrv_init);
module_exit(mydrv_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Linux Driver Developer");
MODULE_DESCRIPTION("è‡ªå®šä¹‰æ€»çº¿é©±åŠ¨æ¼”ç¤º");
MODULE_VERSION("1.0");
```

### 5.2 æµ‹è¯•é©±åŠ¨æ³¨å†Œ

ç¼–è¯‘å¹¶æµ‹è¯•é©±åŠ¨æ³¨å†Œè¿‡ç¨‹ï¼š

```bash
# é¦–å…ˆåŠ è½½æ€»çº¿æ¨¡å—
insmod bus.ko

# ç„¶ååŠ è½½è®¾å¤‡æ¨¡å—
insmod device.ko

# æœ€ååŠ è½½é©±åŠ¨æ¨¡å—
insmod driver.ko
```

**æŸ¥çœ‹æ³¨å†Œç»“æœ**ï¼š
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/418d801153aa711623e77121380589e3.png)

```bash
# æŸ¥çœ‹æ€»çº¿ä¸‹çš„é©±åŠ¨ç›®å½•
ls -la /sys/bus/mybus/drivers/

# æŸ¥çœ‹é©±åŠ¨çš„è¯¦ç»†ä¿¡æ¯
ls -la /sys/bus/mybus/drivers/mydevice/

# æŸ¥çœ‹é©±åŠ¨çš„å±æ€§
cat /sys/bus/mybus/drivers/mydevice/uevent
```

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/8d1bf836012f95c0961457a4314351a9.png)

**é¢„æœŸç›®å½•ç»“æ„**ï¼š
```txt
/sys/bus/mybus/drivers/mydevice/
â”œâ”€â”€ bind              # æ‰‹åŠ¨ç»‘å®šè®¾å¤‡
â”œâ”€â”€ unbind            # æ‰‹åŠ¨è§£ç»‘è®¾å¤‡
â”œâ”€â”€ uevent            # äº‹ä»¶æ–‡ä»¶
â””â”€â”€ module -> /sys/module/mydriver  # æŒ‡å‘æ¨¡å—çš„ç¬¦å·é“¾æ¥
```


> [!success]+ æ³¨å†ŒæˆåŠŸ 
> é©±åŠ¨æˆåŠŸæ³¨å†Œåˆ°æ€»çº¿ä¸Šï¼Œå¹¶åœ¨sysfsä¸­åˆ›å»ºäº†ç›¸åº”çš„ç›®å½•å’Œå±æ€§æ–‡ä»¶ã€‚

## 6 é©±åŠ¨å±æ€§æ–‡ä»¶å®ç°

### 6.1 driver_attributeç»“æ„ä½“

ä¸ºäº†æ‰©å±•é©±åŠ¨åŠŸèƒ½ï¼Œæˆ‘ä»¬å¯ä»¥ä¸ºé©±åŠ¨æ·»åŠ è‡ªå®šä¹‰å±æ€§æ–‡ä»¶ï¼š

```c
struct driver_attribute {
    struct attribute        attr;           // åŸºæœ¬å±æ€§
    ssize_t (*show)(struct device_driver *driver, char *buf);
    ssize_t (*store)(struct device_driver *driver, const char *buf, size_t count);
};

// ä¾¿æ·å®å®šä¹‰
#define DRIVER_ATTR(_name, _mode, _show, _store) \
    struct driver_attribute driver_attr_##_name = __ATTR(_name, _mode, _show, _store)
```

### 6.2 å¸¦å±æ€§æ–‡ä»¶çš„é©±åŠ¨å®ç°

```c
#include <linux/module.h>
#include <linux/init.h>
#include <linux/device.h>
#include <linux/sysfs.h>

extern struct bus_type mybus;

// é©±åŠ¨çŠ¶æ€æ•°æ®
static int driver_status = 1;
static int driver_debug_level = 2;
static char driver_version[32] = "1.0.0";

// statuså±æ€§çš„showå‡½æ•°
static ssize_t status_show(struct device_driver *driver, char *buf)
{
    return sprintf(buf, "%s\n", driver_status ? "active" : "inactive");
}

// statuså±æ€§çš„storeå‡½æ•°
static ssize_t status_store(struct device_driver *driver, const char *buf, size_t count)
{
    int value;
    
    if (sscanf(buf, "%d", &value) != 1) {
        return -EINVAL;
    }
    
    driver_status = (value != 0) ? 1 : 0;
    printk(KERN_INFO "mydriver: çŠ¶æ€è®¾ç½®ä¸º %s\n", 
           driver_status ? "active" : "inactive");
    
    return count;
}

// debug_levelå±æ€§çš„showå‡½æ•°
static ssize_t debug_level_show(struct device_driver *driver, char *buf)
{
    return sprintf(buf, "%d\n", driver_debug_level);
}

// debug_levelå±æ€§çš„storeå‡½æ•°
static ssize_t debug_level_store(struct device_driver *driver, const char *buf, size_t count)
{
    int value;
    
    if (sscanf(buf, "%d", &value) != 1 || value < 0 || value > 5) {
        return -EINVAL;
    }
    
    driver_debug_level = value;
    printk(KERN_INFO "mydriver: è°ƒè¯•çº§åˆ«è®¾ç½®ä¸º %d\n", driver_debug_level);
    
    return count;
}

// versionå±æ€§çš„showå‡½æ•°
static ssize_t version_show(struct device_driver *driver, char *buf)
{
    return sprintf(buf, "%s\n", driver_version);
}

// å®šä¹‰é©±åŠ¨å±æ€§
static DRIVER_ATTR(status, 0644, status_show, status_store);
static DRIVER_ATTR(debug_level, 0644, debug_level_show, debug_level_store);
static DRIVER_ATTR(version, 0444, version_show, NULL);

// é©±åŠ¨å›è°ƒå‡½æ•°
static int mydriver_remove(struct device *dev)
{
    printk(KERN_INFO "mydriver: ç§»é™¤è®¾å¤‡ [%s]\n", dev_name(dev));
    return 0;
}

static int mydriver_probe(struct device *dev)
{
    printk(KERN_INFO "mydriver: æ¢æµ‹è®¾å¤‡ [%s] (è°ƒè¯•çº§åˆ«: %d)\n", 
           dev_name(dev), driver_debug_level);
    
    if (!driver_status) {
        printk(KERN_WARNING "mydriver: é©±åŠ¨å¤„äºéæ´»åŠ¨çŠ¶æ€ï¼Œæ‹’ç»æ¢æµ‹\n");
        return -ENODEV;
    }
    
    return 0;
}

// å®šä¹‰è®¾å¤‡é©±åŠ¨
struct device_driver mydriver = {
    .name   = "mydevice",
    .bus    = &mybus,
    .owner  = THIS_MODULE,
    .probe  = mydriver_probe,
    .remove = mydriver_remove,
};

// æ¨¡å—åˆå§‹åŒ–
static int __init mydriver_init(void)
{
    int ret;
    
    printk(KERN_INFO "mydriver: æ³¨å†Œå¸¦å±æ€§çš„é©±åŠ¨ç¨‹åº\n");
    
    // æ³¨å†Œé©±åŠ¨
    ret = driver_register(&mydriver);
    if (ret) {
        printk(KERN_ERR "mydriver: é©±åŠ¨æ³¨å†Œå¤±è´¥\n");
        return ret;
    }
    
    // åˆ›å»ºstatuså±æ€§æ–‡ä»¶
    ret = driver_create_file(&mydriver, &driver_attr_status);
    if (ret) {
        printk(KERN_ERR "mydriver: åˆ›å»ºstatuså±æ€§å¤±è´¥\n");
        goto fail_status;
    }
    
    // åˆ›å»ºdebug_levelå±æ€§æ–‡ä»¶
    ret = driver_create_file(&mydriver, &driver_attr_debug_level);
    if (ret) {
        printk(KERN_ERR "mydriver: åˆ›å»ºdebug_levelå±æ€§å¤±è´¥\n");
        goto fail_debug;
    }
    
    // åˆ›å»ºversionå±æ€§æ–‡ä»¶
    ret = driver_create_file(&mydriver, &driver_attr_version);
    if (ret) {
        printk(KERN_ERR "mydriver: åˆ›å»ºversionå±æ€§å¤±è´¥\n");
        goto fail_version;
    }
    
    printk(KERN_INFO "mydriver: é©±åŠ¨åŠå±æ€§åˆ›å»ºæˆåŠŸ\n");
    return 0;

fail_version:
    driver_remove_file(&mydriver, &driver_attr_debug_level);
fail_debug:
    driver_remove_file(&mydriver, &driver_attr_status);
fail_status:
    driver_unregister(&mydriver);
    return ret;
}

// æ¨¡å—é€€å‡º
static void __exit mydriver_exit(void)
{
    printk(KERN_INFO "mydriver: æ¸…ç†é©±åŠ¨èµ„æº\n");
    
    // ç§»é™¤å±æ€§æ–‡ä»¶
    driver_remove_file(&mydriver, &driver_attr_version);
    driver_remove_file(&mydriver, &driver_attr_debug_level);
    driver_remove_file(&mydriver, &driver_attr_status);
    
    // æ³¨é”€é©±åŠ¨
    driver_unregister(&mydriver);
    
    printk(KERN_INFO "mydriver: æ¸…ç†å®Œæˆ\n");
}

module_init(mydriver_init);
module_exit(mydriver_exit);

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("å¸¦å±æ€§æ–‡ä»¶çš„é©±åŠ¨æ¼”ç¤º");
```

### 6.3 æµ‹è¯•å±æ€§æ–‡ä»¶åŠŸèƒ½

```bash
# æŸ¥çœ‹é©±åŠ¨å±æ€§æ–‡ä»¶
ls -la /sys/bus/mybus/drivers/mydevice/

# è¯»å–å±æ€§å€¼
cat /sys/bus/mybus/drivers/mydevice/status        # è¾“å‡º: active
cat /sys/bus/mybus/drivers/mydevice/debug_level   # è¾“å‡º: 2  
cat /sys/bus/mybus/drivers/mydevice/version       # è¾“å‡º: 1.0.0

# ä¿®æ”¹å±æ€§å€¼
echo 0 > /sys/bus/mybus/drivers/mydevice/status
cat /sys/bus/mybus/drivers/mydevice/status        # è¾“å‡º: inactive

echo 4 > /sys/bus/mybus/drivers/mydevice/debug_level
cat /sys/bus/mybus/drivers/mydevice/debug_level   # è¾“å‡º: 4

# å°è¯•å†™å…¥åªè¯»å±æ€§ï¼ˆä¼šå¤±è´¥ï¼‰
echo "2.0.0" > /sys/bus/mybus/drivers/mydevice/version  # Permission denied
```

**æœ€ç»ˆç›®å½•ç»“æ„**ï¼š

```txt
/sys/bus/mybus/drivers/mydevice/
â”œâ”€â”€ bind              # æ‰‹åŠ¨ç»‘å®š
â”œâ”€â”€ unbind            # æ‰‹åŠ¨è§£ç»‘
â”œâ”€â”€ uevent            # äº‹ä»¶æ–‡ä»¶
â”œâ”€â”€ module -> /sys/module/mydriver
â”œâ”€â”€ status            # è‡ªå®šä¹‰ï¼šé©±åŠ¨çŠ¶æ€
â”œâ”€â”€ debug_level       # è‡ªå®šä¹‰ï¼šè°ƒè¯•çº§åˆ«
â””â”€â”€ version           # è‡ªå®šä¹‰ï¼šç‰ˆæœ¬ä¿¡æ¯ï¼ˆåªè¯»ï¼‰
```

> [!success]+ åŠŸèƒ½å®Œå–„ 
> é€šè¿‡æ·»åŠ å±æ€§æ–‡ä»¶ï¼Œæˆ‘ä»¬å®ç°äº†å¯¹é©±åŠ¨çŠ¶æ€çš„åŠ¨æ€é…ç½®å’Œç›‘æ§ï¼Œå¤§å¤§å¢å¼ºäº†é©±åŠ¨çš„å¯ç»´æŠ¤æ€§ã€‚

## 7 é«˜çº§é©±åŠ¨ç‰¹æ€§

### 7.1 ç”µæºç®¡ç†

ç°ä»£é©±åŠ¨ç¨‹åºéœ€è¦æ”¯æŒç”µæºç®¡ç†ï¼š
```c
// é«˜çº§ç”µæºç®¡ç†æ“ä½œ
static const struct dev_pm_ops mydriver_pm_ops = {
    .suspend        = mydriver_suspend,
    .resume         = mydriver_resume,
    .freeze         = mydriver_freeze,
    .thaw           = mydriver_thaw,
    .poweroff       = mydriver_poweroff,
    .restore        = mydriver_restore,
    .runtime_suspend = mydriver_runtime_suspend,
    .runtime_resume  = mydriver_runtime_resume,
    .runtime_idle    = mydriver_runtime_idle,
};

struct device_driver mydriver = {
    .name = "mydevice",
    .bus  = &mybus,
    .pm   = &mydriver_pm_ops,  // ç”µæºç®¡ç†æ“ä½œ
    // ...
};
```

### 7.2 è®¾å¤‡æ ‘åŒ¹é…

å¯¹äºæ”¯æŒè®¾å¤‡æ ‘çš„å¹³å°ï¼š
```c
// è®¾å¤‡æ ‘åŒ¹é…è¡¨
static const struct of_device_id mydriver_of_match[] = {
    { .compatible = "vendor,mydevice-v1", },
    { .compatible = "vendor,mydevice-v2", },
    { /* ç»“æŸæ ‡å¿— */ }
};
MODULE_DEVICE_TABLE(of, mydriver_of_match);

struct device_driver mydriver = {
    .name           = "mydevice",
    .of_match_table = mydriver_of_match,
    // ...
};
```

### 7.3 å¼‚æ­¥æ¢æµ‹

å¯¹äºåˆå§‹åŒ–è€—æ—¶çš„è®¾å¤‡ï¼š
```c
struct device_driver mydriver = {
    .name       = "mydevice",
    .probe_type = PROBE_PREFER_ASYNCHRONOUS,  // å¼‚æ­¥æ¢æµ‹
    // ...
};
```

## 8 è°ƒè¯•å’Œæ•…éšœæ’é™¤

### 8.1 å¸¸ç”¨è°ƒè¯•æŠ€æœ¯

```bash
# æŸ¥çœ‹é©±åŠ¨ä¿¡æ¯
cat /sys/bus/mybus/drivers/mydevice/uevent

# æŸ¥çœ‹é©±åŠ¨ç®¡ç†çš„è®¾å¤‡
ls -l /sys/bus/mybus/drivers/mydevice/

# æ‰‹åŠ¨ç»‘å®šè®¾å¤‡åˆ°é©±åŠ¨
echo "device_name" > /sys/bus/mybus/drivers/mydevice/bind

# æ‰‹åŠ¨è§£ç»‘è®¾å¤‡
echo "device_name" > /sys/bus/mybus/drivers/mydevice/unbind

# ç›‘æ§é©±åŠ¨äº‹ä»¶
udevadm monitor --subsystem-match=mybus
```

### 8.2 å†…æ ¸è°ƒè¯•é€‰é¡¹

```bash
# å¼€å¯é©±åŠ¨è°ƒè¯•ä¿¡æ¯
echo 'file drivers/base/dd.c +p' > /sys/kernel/debug/dynamic_debug/control

# æŸ¥çœ‹é©±åŠ¨ç»‘å®šè¿‡ç¨‹
dmesg | grep -E "(probe|bind|attach)"

# æ£€æŸ¥æ¨¡å—ä¾èµ–
lsmod | grep mydriver
cat /sys/module/mydriver/refcnt
```

### 8.3 å¸¸è§é—®é¢˜è§£å†³

**é—®é¢˜1ï¼šprobeå‡½æ•°æœªè¢«è°ƒç”¨**
- æ£€æŸ¥æ€»çº¿çš„matchå‡½æ•°æ˜¯å¦æ­£ç¡®å®ç°
- ç¡®è®¤è®¾å¤‡åç§°ä¸é©±åŠ¨åç§°æ˜¯å¦åŒ¹é…
- æŸ¥çœ‹drivers_autoprobeæ˜¯å¦å¯ç”¨

**é—®é¢˜2ï¼šé©±åŠ¨æ³¨å†Œå¤±è´¥**
- æ£€æŸ¥æ€»çº¿æ˜¯å¦å·²ç»æ³¨å†Œ
- ç¡®è®¤é©±åŠ¨åç§°æ²¡æœ‰é‡å¤
- æŸ¥çœ‹å†…æ ¸æ—¥å¿—ä¸­çš„é”™è¯¯ä¿¡æ¯

**é—®é¢˜3ï¼šå±æ€§æ–‡ä»¶æ— æ³•åˆ›å»º**
- æ£€æŸ¥show/storeå‡½æ•°æ˜¯å¦æ­£ç¡®å®ç°
- ç¡®è®¤æ–‡ä»¶æƒé™è®¾ç½®æ˜¯å¦åˆç†
- éªŒè¯kobjectæ˜¯å¦æ­£ç¡®åˆå§‹åŒ–

> [!abstract]+ ç« èŠ‚æ€»ç»“ 
> é€šè¿‡æœ¬ç« çš„æ·±å…¥å­¦ä¹ ï¼Œæˆ‘ä»¬å…¨é¢æŒæ¡äº†è®¾å¤‡é©±åŠ¨çš„æ ¸å¿ƒçŸ¥è¯†ï¼š
> 
> - **é©±åŠ¨ç»“æ„ä½“**ï¼šæ·±å…¥ç†è§£äº†device_driverçš„å®Œæ•´å®šä¹‰
> - **æ³¨å†Œæµç¨‹**ï¼šè¯¦ç»†åˆ†æäº†driver_registerçš„å®ç°è¿‡ç¨‹
> - **åŒ¹é…æœºåˆ¶**ï¼šæŒæ¡äº†é©±åŠ¨ä¸è®¾å¤‡çš„åŒ¹é…å’Œæ¢æµ‹æµç¨‹
> - **å®è·µåº”ç”¨**ï¼šæˆåŠŸåˆ›å»ºäº†è‡ªå®šä¹‰é©±åŠ¨å’Œå±æ€§æ–‡ä»¶
> - **é«˜çº§ç‰¹æ€§**ï¼šäº†è§£äº†ç”µæºç®¡ç†ã€è®¾å¤‡æ ‘åŒ¹é…ç­‰é«˜çº§åŠŸèƒ½
> - **è°ƒè¯•æŠ€å·§**ï¼šå­¦ä¼šäº†é©±åŠ¨å¼€å‘ä¸­çš„è°ƒè¯•å’Œé—®é¢˜æ’æŸ¥æ–¹æ³•

è‡³æ­¤ï¼Œæˆ‘ä»¬å·²ç»å®Œæˆäº†Linuxè®¾å¤‡æ¨¡å‹ä¸‰å¤§æ ¸å¿ƒç»„ä»¶ï¼ˆæ€»çº¿ã€é©±åŠ¨ã€è®¾å¤‡ï¼‰çš„å®Œæ•´å­¦ä¹ ã€‚è¿™äº›çŸ¥è¯†ä¸ºæˆ‘ä»¬è¿›ä¸€æ­¥å­¦ä¹ å…·ä½“çš„é©±åŠ¨å¼€å‘æŠ€æœ¯å¥ å®šäº†åšå®çš„åŸºç¡€ï¼

