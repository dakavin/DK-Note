---
文章标题: "[[02_设备树（device Tree）的由来]]"
文章作者: Dakkk
文章概要: |
  介绍设备树的定义、历史由来（Linus对ARM代码的不满）、组成部分（DTS/DTSI/DTB/DTC）、文件存放位置及编译方法，解决传统硬件描述方式的维护难题。
tags:
  - 设备树
  - Device Tree
  - ARM
  - Linux内核
  - 硬件描述
  - 嵌入式系统
  - DTS
  - DTB
相关文章:
  - "[[03_图解Kernel Device Tree(设备树)的使用]]"
  - "[[参考内容/dtb 文件格式讲解]]"
  - "[[参考内容/设备树的规范（dts和dtb）]]"
  - "[[04_设备树中CPU描述 (不需要改)]]"
  - "[[10_设备树的简介]]"
文章分类: 🐧 Linux系统
文章路径: 06-🐧 Linux系统/07-🚗 Linux驱动开发核心(重要!!!)/05-🚗 Linux驱动相关子系统 (重点)/3_设备树/1_Linux之设备树详解（训练营）/01_设备树（device Tree）的由来.md
文章难度: 中级 🌳
目前阶段: ✅ 已完成
重要性: ⭐⭐⭐⭐ 核心能力
创建时间: 2025-06-10 20:34:00
修改时间: 2025-06-10 22:26:22
---

## 1 什么是设备树？

**设备树（Device Tree）** 是一种硬件描述机制，用于在嵌入式系统和操作系统中描述硬件设备的特性、连接关系和配置信息。

> [!note]+ 关键笔记
> 简单来说，设备树就像是一张"硬件说明书"，告诉操作系统你的板子上有什么硬件，这些硬件在哪里，如何连接的
> 

它提供了一种**与平台无关**的方式来描述硬件，使得内核与硬件之间的耦合度降低，提高了系统的**可移植性**和**可维护性**。

> [!example]+ 传统方式 vs 设备树方式
> 在设备树出现之前，我们使用 `platform_device 结构体` 来描述硬件设备：
> - 每个 `platform_device 结构` 表示一个特定的硬件设备
> - 通过注册到平台总线上来使得内核能够与该设备进行通信和交互
> - 该结构包含设备的名称、资源（如内存地址、中断号等）、设备驱动程序等信息

**问题在于**：这种方式导致大量平台相关的配置代码，杂乱而重复，维护困难。

## 2 设备树的由来

### 2.1 Linus 的愤怒时刻

随着时间的推移，Linux 内核中的 ARM 部分存在着大量的平台相关配置代码，这些代码通常是杂乱而重复的，导致了维护的困难和工作量的增加。

> [!warning]+ 历史转折点 
> 在 **2011 年 3 月 17 日**，Linux 的创始人 **Linus Torvalds** 在 ARM Linux 邮件列表中发表了一封帖子，他表达了对 ARM 架构配置方式的不满，并宣称：
> 
> **"Gaah. Guys, this whole ARM thing is a fucking pain in the ass"**

这引起了广泛的讨论和反思。ARM 社区中的开发者们开始认识到，传统的平台相关配置方式已经变得不可持续，需要一种更加先进和可扩展的方法来解决这个问题。

下图是 `Linus` 认为的垃圾代码（不可复用）目录：
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/04/a0f9dbcdc1b6a153d30dde315a407980.png)

### 2.2 设备树的诞生

为了应对这一挑战，ARM 社区开始探索新的硬件描述机制，并逐渐形成了设备树的概念。

> [!abstract]+ 设备树的核心优势
> 
> 1. **结构化的数据格式**：通过描述设备节点、属性和连接关系等信息
>     
> 2. **平台无关性**：硬件的描述与具体的平台无关
>     
> 3. **代码复用**：允许多个平台共享相同的设备树描述
>     
> 4. **可视化和可读性**：方便开发者理解和调试硬件
>     

设备树不仅在 ARM 架构上得到了广泛应用，也被扩展到其他架构和平台上，成为了嵌入式系统和 Linux 内核中描述硬件的**标准方式**。

## 3 设备树的组成

当我们谈论设备树时，通常会涉及到四个关键术语：**DTS**、**DTSI**、**DTB** 和 **DTC**

### 3.1 四个组成部分详解

#### 3.1.1 DTS（Device Tree Source）

> [!note]+ DTS 文件特点
> 
> - **作用**：设备树的源文件，人类可读的文本文件
> - **扩展名**：`.dts`
> - **内容**：采用类似于文本的语法来描述硬件设备的结构、属性和连接关系
> - **编写者**：通常由开发人员手动编写

#### 3.1.2 DTSI（Device Tree Source Include）

> [!tip]+ DTSI 的作用类似于 C 语言中的头文件
> 
> - **作用**：设备树源文件的包含文件，定义可复用的设备树片段
>     
> - **扩展名**：`.dtsi`
>     
> - **优势**：可以在多个 DTS 文件中包含和共享，提高可复用性和可维护性
>     

#### 3.1.3 DTC（Device Tree Compiler）

> [!example]+ DTC 编译器特点
> 
> - **作用**：设备树的编译器，类似于 GCC 对 C 语言的作用
>     
> - **功能**：将文本格式的设备树源代码转换为二进制格式
>     
> - **类型**：命令行工具
>     

#### 3.1.4 DTB（Device Tree Blob）

> [!note]+ DTB 二进制文件
> 
> - **作用**：设备树的二进制表现形式
>     
> - **扩展名**：`.dtb`
>     
> - **用途**：被操作系统加载和解析，包含设备树的所有结构、属性和连接信息
>     

### 3.2 四者之间的关系

**换句话说**，它们的关系就像一个完整的工作流程：

> [!abstract]+ 设备树工作流程
> 
> 1. **编写阶段**：开发人员使用文本编辑器编写 DTS 和 DTSI 文件
> 2. **包含阶段**：DTSI 文件可以在多个 DTS 文件中包含和共享
> 3. **编译阶段**：使用 DTC 编译器将 DTS 和 DTSI 文件编译成二进制的 DTB 文件
> 4. **运行阶段**：操作系统在启动过程中加载和解析 DTB 文件

![image.png|200](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/bc23e66bf50cf6363c16fc905649120d.png)

### 3.3 实际应用场景

**板卡所使用的dtb文件**：
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/04/f00aaafd3febf2549b3bbcbf47b65b66.png)

**SDK中的dtb文件**：
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/4c30ea2b0a58accc4d85e4b1dbd4c378.png)

**SDK中的dts文件**：
- 路径：`kernel/arch/arm64/boot/dts/rockchip/rk3568-lubancat-2-v2.dts`
  ![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/4aa4848f04c213eab71c57160e295328.png)
通过ag来检索，包含dtsi的文件有哪些
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/deee7b591985a2f00b5cbe0d8bdce9ac.png)

## 4 设备树文件的存放位置

>[!tip]+ 不同架构的设备树文件位置 
>根据你的硬件架构，设备树文件存放在不同的目录中：

**ARM 32位体系结构**：
- **路径**：`arch/arm/boot/dts/`
- **说明**：该目录是 ARM 32位设备树源文件的根目录

**ARM64 体系结构**：
- **路径**：`arch/arm64/boot/dts/` 及其子目录
- **说明**：该目录是 ARM64 设备树源文件的根目录，包含针对不同 ARM64 平台和设备的子目录

> [!note]+ 目录组织规则 
> 在 ARM64 的子目录中，会按照以下方式进行组织和分类：
> 
> - **硬件平台**：不同的芯片平台
>     
> - **设备类型**：不同类型的设备
>     
> - **制造商**：按芯片厂商分类（如 Qualcomm、NVIDIA、Samsung）
>     

**我们的实例**：由于本手册使用的 SoC 是瑞芯微的 **rk3568**，所以匹配的设备树目录是：
- `arch/arm64/boot/dts/rockchip`

**SDK 中包含的硬件配置和设备类型**：
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/04/e7c89a5c7243128c18ed2812505e1eb1.png)

## 5 设备树的编译

设备树的编译是将设备树源文件（`.dts` 文件）转换为二进制的设备树表示形式（`.dtb` 文件）的过程

> [!note]+ DTC 编译器位置 
> 在 Linux 内核源码中，**DTC（Device Tree Compiler）** 的源代码和相关工具存放在：`scripts/dtc/`    如下图
> ![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/06/01886b82d717b015ba09de8d58bcdf84.png)

> [!warning]+ 注意事项
> 在编译完源码之后，dtc 设备树编译器会默认生成。如果没有生成相应的 dtc 可执行文件，可以查看在内核默认配置文件中 `CONFIG_DTC` 是否使能。

### 5.1 编译

> [!example]+ 编译命令
> 在 Linux 环境中，使用以下命令将设备树源文件编译为二进制设备树文件：
> ```shell
> dtc -I dts -O dtb -o output.dtb input.dts
> ```
- `-I dts`：指定输入格式为 dts（设备树源文件）
- `-O dtb`：指定输出格式为 dtb（设备树二进制文件）
- `-o output.dtb`：指定输出文件名
- `input.dts`：输入的设备树源文件

**简单来说**，这个命令就是把人类可读的设备树文件转换成机器可读的二进制文件

### 5.2 反编译

有时候我们需要查看已编译的 dtb 文件内容，这时就需要反编译

> [!example]+ 反编译命令
> 在 Linux 环境中，使用以下命令将二进制设备树文件反编译为设备树源文件：
> ```shell
> dtc -I dtb -O dts -o output.dts input.dtb
> ```
- `-I dtb`：指定输入格式为 dtb（设备树二进制文件）
- `-O dts`：指定输出格式为 dts（设备树源文件）
- `-o output.dts`：指定输出文件名
- `input.dtb`：输入的二进制设备树文件

**换句话说**，反编译就是把机器可读的二进制文件转换回人类可读的文本文件。

### 5.3 实战演练

下面来进行一下实际的设备树编译和反编译的演示

首先创建一个名为 test.dts 的设备树文件， 文件内容如下所示：
```dts
/dts-v1/;        //指定设备树的版本
/                //根节点
{                // 空的根节点内容

};
```

> [!warning]+ 注意
> 这个示例并没有描述任何具体的硬件设备或连接关系，它只是一个最基本的设备树框架

> [!question]+ 常见问题
> **Q**: 为什么要从这么简单的例子开始？
> **A**: 因为理解设备树的基本结构比理解复杂的硬件描述更重要。掌握了基础语法，后面添加具体的硬件描述就容易多了。

**简单测试**
```shell
# 编译测试
dtc -I dts -O dtb -o test.dtb test.dts
# 反编译测试
dtc -I dtb -O dts -o test_output.dts test.dtb
# 查看结果
cat test_output.dts
```
- 通过这个简单的测试，你可以验证设备树编译器是否正常工作，同时熟悉设备树的基本编译流程

## 6 总结

> [!abstract]+ 本章要点总结
> 
> 1. **设备树的本质**：是一种硬件描述机制，解决了传统平台相关代码的维护难题
>     
> 2. **四个关键组件**：DTS（源文件）、DTSI（包含文件）、DTB（二进制文件）、DTC（编译器）
>     
> 3. **工作流程**：编写 → 包含 → 编译 → 运行
>     
> 4. **文件位置**：根据架构不同，存放在 `arch/arm/boot/dts/` 或 `arch/arm64/boot/dts/` 目录
>     
> 5. **编译命令**：使用 `dtc` 命令进行编译和反编译
>     

设备树的引入为嵌入式 Linux 开发带来了革命性的变化，使得硬件描述更加标准化和可维护。掌握设备树的基本概念和编译方法，是进行嵌入式 Linux 开发的必备技能。