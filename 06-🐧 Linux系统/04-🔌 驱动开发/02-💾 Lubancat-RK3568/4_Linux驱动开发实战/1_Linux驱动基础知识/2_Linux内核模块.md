
**在Linux系统中，设备驱动会以内核模块的形式出现，学习Linux内核模块编程是驱动开发的先决条件**。第一次接触Linux内核模块，我们将围绕着“Linux内核模块是什么”，“Linux内核模块的工作原理”以及 “我们该怎么使用Linux内核模块”这样的思路一起走进Linux内核世界

Linux内核模块的介绍大致分为四个部分：
1. 内核模块的概念：
	- 是什么？
	- 为什么要引入？
2. 内核模块的原理：
	- 内核模块在内核中的加载、卸载过程
	- 深入剖析内核模块如何导出符号
3. hellomodule实验：
	- 理解内核模块的代码框架和原理
	- 写一个自己的模块，以及模块的使用方法
4. 内核模块传参与符号共享实验：
	- 理解内核模块的传参模式、符号共享
	- 验证内核模块的运行机制

本章主要介绍前面两部分，后两部分在后一章讲解
## 1 概念
### 1.1 内核📕

**内核**
- 是`一个操作系统的核心`
- 是基于硬件的第一层软件扩充，提供操作系统的最基本的功能
- 是操作系统工作的基础，决定着整个操作系统的性能和稳定性

内核按照体系结构分为： 
- **微内核(Micro Kernel)** 
	- 内核*只提供*操作系统核心功能，如实现进程管理、存储器管理、进程间通信、I/O设备管理等
	- 其它的应用层IPC、文件系统功能、设备驱动模块 则不被包含到内核功能中，属于*微内核之外的模块*。对于这些模块的修改不会影响核心功能
	- 具有动态扩展性强的优点。Windows操作系统、华为的鸿蒙操作系统就属于这类微内核架构
- **宏内核(Monolithic Kernel)** 
	- 将上述包括微内核以及微内核之外的应用层IPC、文件系统功能、设备驱动模块都编译成一个整体
	- 优点是执行效率非常高
	- 缺点是修改、增加内核某个功能时，需要重新编译内核
	- `Linux操作系统正是采用了宏内核结构，对于缺点的改进，所以引入了内核模块机制`
- **混合内核(Hybrid Kernel)** 等。

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/8e3812efa745ea08e7c54c0f46580315.png)

### 1.2 内核模块机制引入

#### 1.2.1 引入原因

Linux是一个跨平台的操作系统，支持众多的设备，在**Linux内核源码中有超过50%的代码都与设备驱动相关**。Linux为宏内核架构，如果开启所有的功能，内核就会变得十分臃肿。

内核模块就是实现了某个功能的一段内核代码，**在内核运行过程，可以加载这部分代码到内核中， 从而`动态地增加了内核的功能`**。

基于这种特性，我们进行设备驱动开发时，以内核模块的形式编写设备驱动， 只需要编译相关的驱动代码即可，无需对整个内核进行编译。
#### 1.2.2 引入好处

内核模块的引入不仅**提高了系统的灵活性**，对于开发人员来说更是**提供了极大的方便**。
- `设备驱动的开发过程`：随意将正在测试的驱动程序添加到内核中或者从内核中移除， 每次修改内核模块的代码不需要重新启动内核
- 开发板上：当需要加载内核模块的时候，可以通过挂载NFS服务器， 将存放在其他设备中的内核模块，加载到开发板上
- 某些特定场合：可以按照需要加载/卸载系统的内核模块，从而更好的为当前环境提供服
#### 1.2.3 内核模块的定义和特点

**内核模块的具体的定义**
- 全称Loadable Kernel Module(LKM)， 是一种在内核运行时加载一组目标代码来实现某个特定功能的机制
- 模块是具有独立功能的程序，它可以被单独编译，但不能独立运行， 在运行时它被链接到内核作为内核的一部分在内核空间运行，这与运行在用户空间的进程是不一样的
- 模块由一组函数和数据结构组成，用来实现一种文件系统、一个驱动程序和其他内核上层功能

**内核模块的特点**
- ***模块本身不被编译入内核映像，这控制了内核的大小***
- ***模块一旦被加载，它就和内核中的其它部分完全一样***
## 2 工作机制

编写的内核模块，经过编译，最终形成.ko为后缀的ELF文件。我们可以使用file命令来查看它
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/61085dbe65099a61c5d5de4704da510d.png)

**那么这样的文件是如何被内核一步一步拿到并且很好的工作的呢？**
- 先学习一下ELF文件格式，了解ko究竟是怎么回事
- 再看内核源码，探究内核模块加载/卸载，以及符号导出的经过
### 2.1 详细加载/卸载过程
#### 2.1.1 ko文件的文件格式

`KO文件（Kernel Object）`是Linux内核模块的标准文件格式，其本质是一个符合`ELF（Executable and Linking Format）`标准的可重定位目标文件`（Relocatable Object File）`
- 这类文件**包含了代码和数据**，可以被用来链接成可执行文件或共享目标文件，静态链接库也可以归为这一类。

ELF 文件格式的可能布局如下图：
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/38e244fd230321f2487759bd6fa2616d.png)

**1. ELF头部（ELF Header）**：位于文件起始位置，描述整个ELF文件的基本信息
- e_type：标识文件类型为ET_REL（可重定位文件）
- e_machine：指定目标架构（如x86、ARM）
- e_shoff：指向节区头部表（Section Header Table）的偏移量
- e_shnum：节区头部表中的条目数量
- e_shentsize：每个节区头部表项的字节大小
- e_flags：处理器相关标志（通常与内核模块无关）
通过`readelf -h <ko_file>`可查看ELF头部信息
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/19342f00d50f5af1965b396878c891e8.png)

---

**2. 程序头部表（Program Header Table）**
- 对于可重定位目标文件（如KO文件），程序头部表通常为空或无效，因为它主要用于可执行文件或共享库（如.so）
- 内核模块加载时，由内核的模块加载器解析节区头部表，而非程序头部表

---

**3. 节区头部表（Section Header Table）**：节区头部表是KO文件的核心结构，定义了各个节区（Section）的属性。通过`readelf -S <ko_file>`可查看详细信息。以下是与内核模块密切相关的关键节区：
**(1) 代码与数据节区**
- `.text`：模块的主要执行代码（如init_module和exit_module函数）
- `.data`：已初始化的全局变量
- `.rodata`：只读数据（如字符串常量）
- `.bss`：未初始化的全局变量（实际不占文件空间）
**(2) 模块元信息节区**
- `.modinfo`：存储模块的元信息（如作者、许可证、依赖模块等），通过`modinfo <ko_file>`可查看![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/944c5a2ccfba29b8e7d17ac966b35abd.png)
**(3) 符号与重定位节区**📕📕
- `.symtab`：符号表，记录模块中定义的函数/变量（如导出符号）及引用的外部符号（如内核API）
- 📕📕`.strtab`：字符串表，存储符号名称、节区名称等字符串
- 📕📕`.rel.*.text/.data`：重定位表（如.rel.text），记录代码或数据中需要修正的地址偏移，供内核加载时动态重定位
**(4) 版本校验节区**
- `__versions`：内核版本校验信息，确保模块兼容当前内核的符号版本（CRC校验值）。若版本不匹配，加载将失败
**(5) 模块生命周期节区**
- `.init.text`：模块初始化代码（如module_init宏定义的函数）
- `.exit.text`：模块卸载代码（如module_exit宏定义的函数）
- 加载时，内核会执行.init.text中的代码；卸载时执行.exit.text中的代码
**(6) 模块结构体节区**
- `.gnu.linkonce.this_module`：存储struct module结构体实例，描述模块的元信息（如模块名、导出符号表等）

---

**4.KO文件的特殊机制**
**动态重定位：**
- 内核加载模块时，根据重定位表（`.rel.*`）修正代码和数据中的地址（如调用内核API的地址）
- 依赖EXPORT_SYMBOL导出的内核符号表完成符号解析
**版本控制：**
- 通过__versions节区校验符号的CRC值，防止模块与不兼容的内核版本一起运行
**依赖管理：**
- .modinfo中的depends=字段声明依赖的其他模块，内核按需自动加载依赖项

---

查看KO文件结构，使用readelf工具分析
```shell
# 查看ELF头部
readelf -h example.ko
# 查看节区头部表
readelf -S example.ko
# 查看符号表
readelf -s example.ko
# 查看重定位表
readelf -r example.ko
```
#### 2.1.2 内核模块加载过程

前面我们了解了ko内核模块文件的一些格式内容后，可以知道 **内核模块其实就是一段结果特殊加工的代码**，即内核可以利用加工留在内核模块的信息，对内核模块进行利用（内核模块的加载过程）

**详细加载流程总结**
- 用户空间到内核空间：模块从用户空间通过系统调用进入内核空间
- 临时缓冲区：在内核的vmalloc区建立模块的临时副本
- ELF解析：解析模块的ELF格式，识别各个节区
- 节区分类：将节区分为init和core两类
- 最终内存分配：为模块的core和init段分配最终运行的内存
- 数据搬迁：将模块从临时缓冲区移动到最终位置
- 重定位：修正所有内部和外部引用地址
- 初始化：执行模块初始化代码
- 清理：释放init段和不再需要的资源

---

**具体操作如下：**

**1. 用户空间操作** ：终端执行i`nsmod module.ko`命令时，首先会发生以下操作：
- 内核模块文件(.ko)通过文件系统被*读取到用户空间的一块内存*中
- 用户空间程序准备调用系统调用`sys_init_module()`

**2. 系统调用入口**：`sys_init_module()`是内核模块加载的入口点，它执行以下操作：
- `权限检查`：通过`may_init_module()`检查当前进程是否有权限加载模块
- `内存分配`：在`vmalloc区`分配与.ko文件大小相同的内存空间
- `数据拷贝`：将用户空间的模块数据*拷贝到内核空间的这块内存中*，info->hdr 直接指向此空间首地址，也就是ko的elf header ![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/1d26547e78c5761f2cf300289aec7c6b.png)
- 相关函数及所在位置：`内核源码/kernel/module.c` ![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/0aa55c0bd71e47eb0c5423137455c2e1.png)
**3.  核心加载过程 - load_module()**：主要分为两个关键步骤
- `setup_load_info()`
	- **解析ELF头**：读取模块的ELF(Executable and Linkable Format)头部信息
	- **重定位节区头**：将每个section的地址修改为当前模块镜像在内存中的地址
		- section的地址 = e_shstrndx获取到节区头部字符串表的标号（对应section在ELF文件中的偏移） + ELF文件起始地址
	- **获取字符串表**：通过ELF头中的索引(e_shstrndx)找到节区名称字符串表的位置
- `layout_and_allocate()`
	- **节区分类**：将所有节区(section)分为两大类：
		- init段：包含模块初始化代码和数据，加载完成后会被释放
		- core段：包含模块运行时的核心代码和数据，会一直保留
	- **布局和分配**：为这两类节区在最终的运行地址空间分配内存
	- **模块搬运move_module()**：将模块数据从临时缓冲区(vmalloc区)移动到最终的运行位置

**4. 地址重定位**
- 符号解析：解决模块对外部符号的引用（如调用内核函数）
- 地址修正：调整模块内部的所有地址引用，指向正确的位置

**5. 初始化和清理**
- 执行init函数：调用模块的初始化函数（如module_init()宏定义的函数）
- 释放init段：初始化完成后，init段占用的内存会被释放，只保留core段

---

**内存管理要点**：在整个加载过程中，内存管理非常关键：
- vmalloc区：用于临时存储模块镜像，加载完成后这部分内存会被释放
- modules区：模块最终运行的内存区域，core段会长期驻留在这里
- init段：在初始化完成后会被释放，不会长期占用内存

这样设计的好处是最大限度地节省了内核内存的使用，特别是对于不再需要的初始化代码和数据能够及时释放
#### 2.1.3 内核模块卸载过程

卸载过程相对简单，当用户输入 `rmmod module_name`命令后，系统会通过系统调用`sys_delete_module()`实现，具体过程如下：
- 从用户空间传入需要卸载的模块名称
- 根据名称找到要卸载的模块指针
- 确保要卸载的模块没有被其他模块依赖
- 找到模块本身的exit函数实现卸载

**sys_delete_module()函数定位**
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/99b62c42df740f2b20c52fc7856491d2.png)

**内核模块卸载过程详解**

**1. 用户空间操作**  
当用户执行`rmmod module_name`命令时：  
- 通过系统调用接口调用`sys_delete_module()`  
- 将要卸载的模块名称从用户空间传递到内核空间  

**2. 权限与状态检查**  
在`sys_delete_module()`中首先进行多项安全检查：  
```c
// 权限检查
if (!capable(CAP_SYS_MODULE) || modules_disabled)
    return -EPERM;

// 获取模块名称  
if (strncpy_from_user(name, name_user, MODULE_NAME_LEN-1) < 0)
    return -EFAULT;
```
- **能力检查**：确认调用进程有`CAP_SYS_MODULE`权限  
- **模块状态检查**：确认内核没有禁用模块加载/卸载功能  
- **名称验证**：安全地复制模块名称到内核空间  

**3. 模块查找与验证**  
```c
// 获取模块互斥锁
mutex_lock_interruptible(&module_mutex);

// 查找模块
mod = find_module(name);
if (!mod) {
    ret = -ENOENT;  // 模块不存在
    goto out;
}
```
- **互斥锁保护**：防止并发修改模块列表  
- **模块查找**：通过名称在内核模块列表中找到对应模块结构体  

**4. 依赖关系检查**  
```c
if (!list_empty(&mod->source_list)) {
    ret = -EWOULDBLOCK;  // 存在依赖模块
    goto out;
}
```
- **依赖检测**：检查是否有其他模块依赖当前模块  
- **错误处理**：如果存在依赖则拒绝卸载(除非强制卸载)  

**5. 模块状态验证**  
```c
if (mod->state != MODULE_STATE_LIVE) {
    ret = -EBUSY;  // 模块不处于活跃状态
    goto out;
}
```
- **状态检查**：确认模块处于`MODULE_STATE_LIVE`(正常运行)状态  
- 防止卸载正在初始化或已经退出的模块  

**6. 退出函数检查与强制卸载**  
```c
if (mod->init && !mod->exit) {
    forced = try_force_unload(flags);
    if (!forced) {
        ret = -EBUSY;  // 不能强制卸载
        goto out;
    }
}
```
- **exit函数检查**：确认模块定义了退出函数  
- **强制卸载**：某些特殊模块可能需要强制卸载(通过`-f`标志)  

**7. 停止模块运行**  
```c
ret = try_stop_module(mod, flags, &forced);
if (ret != 0)
    goto out;
```
- **引用计数检查**：确保没有其他代码正在使用该模块  
- **禁用模块**：将模块标记为正在卸载状态  

**8. 执行清理操作**  
一旦确认可以安全卸载：  
```c
// 释放互斥锁允许其他操作
mutex_unlock(&module_mutex);

// 1. 调用模块的exit函数
if (mod->exit != NULL)
    mod->exit();

// 2. 通知系统其他部分
blocking_notifier_call_chain(&module_notify_list, MODULE_STATE_GOING, mod);

// 3. 内核实时补丁系统通知
klp_module_going(mod);

// 4. 释放ftrace相关资源
ftrace_release_mod(mod);

// 5. 等待异步调用完成
async_synchronize_full();

// 6. 记录最后卸载的模块名
strlcpy(last_unloaded_module, mod->name, sizeof(last_unloaded_module));

// 7. 最终释放模块资源
free_module(mod);
```

**清理步骤说明**：  
1. **调用exit函数**：执行模块定义的清理代码  
2. **系统通知**：告知所有注册的监听者该模块即将卸载  
3. **实时补丁处理**：内核实时补丁系统的特殊处理  
4. **跟踪系统清理**：释放与ftrace相关的资源  
5. **异步操作同步**：等待所有异步操作完成  
6. **记录信息**：记录最后卸载的模块名用于诊断  
7. **资源释放**：最终释放模块占用的所有内存和资源  

**9. 错误处理**  
如果上述任何步骤失败：  
```c
out:
    mutex_unlock(&module_mutex);
    return ret;
```
- **释放锁**：确保互斥锁被正确释放  
- **返回错误**：向用户空间返回适当的错误代码  

**完整卸载流程总结**  
1. **用户命令**：执行`rmmod`命令触发卸载  
2. **权限验证**：检查调用者权限和系统设置  
3. **模块查找**：在内核模块列表中定位目标模块  
4. **安全检查**：  
   - 检查依赖关系  
   - 验证模块状态  
   - 确认有退出函数  
5. **停止模块**：确保模块不再被使用  
6. **清理操作**：  
   - 执行退出函数  
   - 系统通知  
   - 释放资源  
7. **资源释放**：彻底释放模块占用的所有资源  
8. **状态返回**：返回成功或失败状态给用户空间
### 2.2 如何导出符号的？

**什么是符号？**
- 符号是内核模块中通过`EXPORT_SYMBOL`宏声明的函数和变量，它们相当于模块对外提供的接口
- 当模块加载时，这些符号会被记录到内核的公共符号表中，成为其他模块可以访问的共享资源
- 在使用命令insmod加载模块后，模块就被连接到了内核，因此可以访问内核的共用符号

**为什么需要导出符号？**
- **模块间协作**：允许不同模块互相调用函数和共享数据
- **分层架构**：支持模块的层级依赖关系（如USB驱动依赖usbcore模块）
- **代码复用**：避免重复实现相同功能
- **动态扩展**：保持内核核心精简，通过模块扩展功能

**符号的导出方式**
```c
// 标准导出（所有模块可用）
EXPORT_SYMBOL(function_name);

// GPL协议限制导出（仅GPL兼容模块可用） 
EXPORT_SYMBOL_GPL(function_name);
```
- 必须在全局作用域导出，不能在函数内部使用
- `_GPL`版本会进行许可证检查

**符号的存储结构**：导出的符号会被编译到ELF文件的特殊段中：
- `__ksymtab`段：存储`kernel_symbol`结构体
- `__ksymtab_strings`段：存储符号名称字符串
- `kernel_symbol`结构包含：
```c
struct kernel_symbol {
    unsigned long value;  // 符号在内存地址
    const char *name;     // 符号名称
};
```

**符号的加载过程**
- **模块加载时**：通过`load_module()`函数中调用`simplify_symbols()`函数处理（遍历）符号表
- **地址解析**：根据ELF段的偏移量计算符号实际内存地址
	- 根据st_shndx找到符号所在的section和st_value中符号在section中的偏移得到真正的内存地址
- **注册符号**：将符号地址和名称记录到内核全局符号表

**符号查找机制** 当其他模块需要引用符号时：
- 调用`resolve_symbol_wait()`开始查找
- 通过`find_symbol()`在内核和已加载模块中搜索 ![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/565efec4d793d3d196461c91852674f7.png)
- 搜索范围包括：
	- 内核自带的导出符号
	- 所有已加载模块的导出符号
- 找到后：
	- 返回符号的内存地址
	- 通过重定位机制修正引用

**典型应用场景**
- **设备驱动**：导出设备操作函数集
- **文件系统**：如FAT模块导出给MSDOS模块使用
- **协议栈**：网络协议模块间的相互调用

**工具支持**
- `modprobe`：自动处理模块依赖关系，按需加载依赖模块
- `lsmod`：查看已加载模块及依赖关系
- `nm`：查看模块的符号表

这种符号导出机制实现了内核模块间的动态链接，是Linux内核模块化架构的核心基础之一。通过精心设计的符号导出，可以构建出层次清晰、耦合度低的模块系统。
## 3 参考链接

到这里内核就完成了内核模块的加载/卸载以及符号导出，感兴趣的读者可以查阅内核源码目录下/kernel/module.c

[https://apple.fandom.com/wiki/Kernel](https://apple.fandom.com/wiki/Kernel)