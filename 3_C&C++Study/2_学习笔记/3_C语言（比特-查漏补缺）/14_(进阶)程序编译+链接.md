## 1 程序的翻译环境的执行环境

在ANSI C的任何一种实现中，存在两个不同的环境
- 翻译环境，在这个环境中源代码被转换为可执行的机器指令
- 执行环境，用于实际执行代码
## 2 编译+链接（详解）

### 2.1 翻译环境

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/762dbb52ecc7d60739677c925ca4bdaf.png)

- 组成一个程序的每个源文件通过编译过程分别转换成目标代码（object code）
- 每个目标文件由链接器（linker）捆绑在一起，形成一个单一而完整的可执行程序
- 链接器同时也会`引入标准C函数库`中任何被该程序所用到的函数，而且它可以搜索`程序员个人的程序库`，将其需要的函数也链接到程序中
### 2.2 编译的几个阶段

[extern的定义](../2_C语言（尚硅谷）/6_函数.md#4.6.2%20外部函数（extern/默认）)

```c
// sum.c
int g_val = 2016;
void print(const char *str){
	printf("%s\n",str);
}

//test.c
#include <stdio.h>
int main(){
	extern void print(char *str);
	extern int g_val;
	printf("%d\n", g_val);
	print("hello bit.\n");
	return 0;
}
```

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/04ef548c8248784f52a25bf37abe949b.png)

**test.c单个文件的编译过程：**
- 预处理：`gcc -E test.c -o test.i`
- 编译：`gcc -S test.c -o test.s`
- 汇编：`gcc -c test.c -o test.o` （一般直接这一步即可）
- 链接：`gcc test.o -o test`

**假设test.c 和 sum.c 都需要**
- 直接都编译成目标文件
```shell
gcc -c test.c -o test.o   # 编译 test.c，生成 test.o
gcc -c sum.c -o sum.o     # 编译 sum.c，生成 sum.o
```
- 然后链接两个o文件即可
```shell
gcc test.o sum.o -o test   
```


最后输入可以执行的文件
```shell
./test   # 执行生成的可执行文件
```
### 2.3 运行环境

**程序的执行过程**
- 程序必须载入内存中。在有操作系统的环境中：一般这个由操作系统完成。在独立的环境中，程序 的载入必须由手工安排，也可能是通过可执行代码置入只读内存来完成。
- 程序的执行便开始。接着便调用main函数
- 开始执行程序代码。这个时候程序将使用一个运行时堆栈（stack），存储函数的局部变量和返回地址。程序同时也可以使用静态（static）内存，存储于静态内存中的变量在程序的整个执行过程一直保留他们的值。
- 终止程序。正常终止main函数；也有可能是意外终止。
## 3 预处理（详解）

### 3.1 预定义符号

```c
__FILE__      //进行编译的源文件
__LINE__     //文件当前的行号
__DATE__    //文件被编译的日期
__TIME__    //文件被编译的时间
__STDC__    //如果编译器遵循ANSI C，其值为1，否则未定义
```

这些预定义符号都是语言内置的。如下面的例子
```shell
#include <stdio.h>
int main() {  
    printf("file:%s line:%d\n",__FILE__,__LINE__);  
    return 0;  
}
```

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/e611b246e362c89340f0bccfbdf23a68.png)

### 3.2 `#define`
#### 3.2.1 定义标识符

```c
// 语法：
#define name stuff

//举例
#define MAX 1000
#define reg register          //为 register这个关键字，创建一个简短的名字
#define do_forever for(;;)     //用更形象的符号来替换一种实现
#define CASE break;case        //在写case语句的时候自动把 break写上。

// 如果定义的 stuff过长，可以分成几行写，除了最后一行外，每行的后面都加一个反斜杠(续行符)。
#define DEBUG_PRINT printf("file:%s\tline:%d\t \
                          date:%s\ttime:%s\n" ,\
                          __FILE__,__LINE__ ,       \
                          __DATE__,__TIME__ )  
```

**💡提示：** 在define定义标识符的时候，不要加上 `;`
#### 3.2.2 定义宏

`#define` 机制包括了一个规定，允许把参数替换到文本中，这种实现通常称为宏（macro）或定义
宏（define macro）

下面就是宏的声明方式：
```c
#define name(parament-list) stuff
```
- 其中的parament-list是一个由逗号隔开的符号表，它们可能出现在**stuff**中

**❗️注意：** 
- 参数列表的左括号**必须与name紧邻**
- 如果两者之间有任何空白存在，参数列表就会被解释为stuff的一部分
- 如下：
```c
// #define SQUARE( x )  x * x //情况1
// #define SQUARE(x)  x * x   //情况2
// #define SQUARE(x)  (x) * (x)  //情况3-1
// #define DOUBLE(x)  (x) * (x)  //情况3-2
#define DOUBLE(x)  ((x) * (x)) //情况4
int main(){
	int a = 5;
	printf("%d\n" ,SQUARE( a + 1) );  
	// 情况2 --->  a + 1 * a + 1 = 11
	// 情况3-1 ---> 符合预期

	printf("%d\n" ,10 * DOUBLE(a));
	// 情况3-2 ---> 10 * (5) + (5) = 55
	// 情况4 ---> 50 符合预期
}
```

**💡提示：** 所以用于对数值表达式进行求值的宏定义都应该用这种方式加上括号，避免在使用宏时由于参数中的操作符或邻近操作符之间不可预料的相互作用
#### 3.2.3 替换规则

在程序中扩展#define定义符号和宏时，需要涉及几个步骤。
- 在调用宏时，首先对参数进行检查，看看是否包含任何由#define定义的符号。如果是，它们首先被替换。
- 替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值替换。
- 最后，再次对结果文件进行扫描，看看它是否包含任何由#define定义的符号。如果是，就重复上述处理过程。

**❗️注意：** 
- 宏参数和#define 定义中可以出现其他#define定义的变量。但是对于宏，不能出现递归。
- 当预处理器搜索#define定义的符号的时候，字符串常量的内容并不被搜索。
#### 3.2.4 `#` 和 `##`

**如何把参数插入到字符串中？**
- 首先我们看看这样的代码：
```c
char* p = "hello ""bit\n";
printf("hello"," bit\n");
printf("%s", p);  // 输出hello bit
```
- 可以发现`字符串是有自动连接的特点`的

**那我们是不是可以写这样的代码？**
```c
#define PRINT(FORMAT, VALUE)\
    printf("the value is "FORMAT"\n", VALUE);
...
PRINT("%d", 10);
```
- 这里只有当字符串作为宏参数的时候才可以把字符串放在字符串中

**另外一个技巧是，使用`#` 把一个宏参数变成对应的字符串**
```c
#define PRINT(FORMAT, VALUE)\
    printf("the value of " #VALUE "is "FORMAT "\n", VALUE);
...
int i = 10;
PRINT("%d", i+3);//产生了什么效果？
// the value of i+3 is 13
```

**##的作用**
- ##可以把位于它两边的符号合成一个符号
- 它允许宏定义从分离的文本片段创建标识符
```c
#define ADD_TO_SUM(num, value) \
    sum##num += value;
...
ADD_TO_SUM(5, 10);//作用是：给sum5增加10.
```
- 注意：这样的连接必须产生一个合法的标识符。否则其结果就是未定义的。
#### 3.2.5 带副作用的宏参数

当宏参数在宏的定义中出现超过一次的时候，如果参数带有副作用，那么你在使用这个宏的时候就可能
出现危险，导致不可预测的后果。副作用就是表达式求值的时候出现的永久性效果。

例如：
```c
x+1;//不带副作用
x++;//带有副作用
```

**MAX宏可以证明具有副作用的参数所引起的问题。**
```c
#define MAX(a, b)  ( (a) > (b) ? (a) : (b) )
...
x = 5;
y = 8;
z = MAX(x++, y++);
printf("x=%d y=%d z=%d\n", x, y, z);//输出的结果是什么？
```
这里我们得知道预处理器处理之后的结果是什么：
```c
z = ( (x++) > (y++) ? (x++) : (y++));
```
所以输出的结果是：
```c
x=6 y=10 z=9
```
#### 3.2.6 宏和函数对比

宏通常被应用于执行简单的运算。比如在两个数中找出较大的一个。
```c
#define MAX(a, b) ((a)>(b)?(a):(b))
```

**那么为什么不用函数呢？**
- 用于调用函数和从函数返回的代码可能比实际执行这个小型计算工作所需要的时间更多。所以**宏比函数在程序的规模和速度方面更胜一筹**。
- 更为重要的是函数的参数必须声明为特定的类型。所以函数只能在类型合适的表达式上使用。反之这个宏怎可以适用于整形、长整型、浮点型等可以用于>来比较的类型。**宏是类型无关的。**

**当然和宏相比函数也有劣势的地方：**
- 每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能大幅度增加程序的长度。
- 宏是没法调试的。
- 宏由于类型无关，也就不够严谨。
- 宏可能会带来运算符优先级的问题，导致程容易出现错。

宏有时候可以做函数做不到的事情。比如：**宏的参数可以出现类型**，但是函数做不到。
```c
#define MALLOC(num, type)\
    (type *)malloc(num * sizeof(type))
...
//使用
MALLOC(10, int);//类型作为参数

//预处理器替换之后：
(int *)malloc(10 * sizeof(int));
```

**宏和函数的对比**

| 特性           | **`#`define宏**                          | 函数                             |
| ------------ | --------------------------------------- | ------------------------------ |
| **代码长度**     | 每次使用时，宏代码都会被插入到程序中，程序长度会大幅度增长。          | 函数代码只出现于一个地方，函数被调用时不会增加程序代码长度。 |
| **执行速度**     | 更快，因为没有函数调用和返回的开销。                      | 相对慢一些，因为存在函数调用和返回的额外开销。        |
| **操作符优先级**   | 宏参数的求值是在周围表达式的上下文环境中，可能导致优先级问题，因此建议加括号。 | 函数参数只在函数调用时求值一次，结果容易预测。        |
| **带有副作用的参数** | 参数可能被替换到宏体中的多个位置，带有副作用的参数可能产生不可预料的结果。   | 参数只在传参时求值一次，结果更容易控制。           |
| **参数类型**     | 宏的参数与类型无关，只要操作合法即可。                     | 函数的参数与类型有关，不同类型的参数需要不同的函数。     |
| **调试**       | 宏不便调试。                                  | 函数可以逐语句调试。                     |
| **递归**       | 宏不能递归。                                  | 函数可以递归。                        |

### 3.3 `#undef`

用于移出一个宏定义
```c
#undef NAME
//如果现存的一个名字需要被重新定义，那么它的旧名字首先要被移除。
```
### 3.4 命令行定义

许多C 的编译器提供了一种能力，允许在命令行中定义符号。用于启动编译过程。

例如：当我们根据同一个源文件要编译出不同的一个程序的不同版本的时候，这个特性有点用处。（假
定某个程序中声明了一个某个长度的数组，如果机器内存有限，我们需要一个很小的数组，但是另外一
个机器内存大写，我们需要一个数组能够大写。）

```c
#include <stdio.h>
int main()
{
    int array [ARRAY_SIZE];
    int i = 0;
    for(i = 0; i< ARRAY_SIZE; i ++)
    {
        array[i] = i;
    }
    for(i = 0; i< ARRAY_SIZE; i ++)
    {
        printf("%d " ,array[i]);
    }
    printf("\n" );
    return 0;
}
```

编译指令：
```shell
gcc -D ARRAY_SIZE=10 programe.c
```
### 3.5 条件编译📕

在编译一个程序的时候我们如果要将一条语句（一组语句）编译或者放弃是很方便的。因为我们有条件
编译指令。

比如说：调试性的代码，删除可惜，保留又碍事，所以我们可以选择性的编译。
```c
#include <stdio.h>
#define __DEBUG__
int main()
{
    int i = 0;
    int arr[10] = {0};
    for(i=0; i<10; i++)
    {
        arr[i] = i;
        #ifdef __DEBUG__
        printf("%d\n", arr[i]);//为了观察数组是否赋值成功。      
        #endif //__DEBUG__
    }
    return 0;
}
```

常见的条件编译指令：
```c
1.
#if  常量表达式
    //...
#endif
//常量表达式由预处理器求值。
如：
#define __DEBUG__ 1
#if __DEBUG__
    //..
#endif

2.多个分支的条件编译
#if 常量表达式
    //...
#elif 常量表达式
    //...
#else
    //...
#endif

3.判断是否被定义
#if defined(symbol)
#ifdef symbol

#if !defined(symbol)
#ifndef symbol

4.嵌套指令
#if defined(OS_UNIX)
    #ifdef OPTION1
        unix_version_option1();
    #endif
    #ifdef OPTION2
        unix_version_option2();
    #endif
#elif defined(OS_MSDOS)
    #ifdef OPTION2
        msdos_version_option2();
    #endif
#endif
```
### 3.6 文件包含

我们已经知道，#include 指令可以使另外一个文件被编译。就像它实际出现于#include指令的地方
一样。

这种替换的方式很简单：
- 预处理器先删除这条指令，并用包含文件的内容替换。
- 这样一个源文件被包含10次，那就实际被编译10次。
#### 3.6.1 头文件被包含的方式

**本地文件包含**
```c
#include "filename"
```

查找策略：
- 先在源文件所在目录下查找，如果该头文件未找到，编译器就像查找库函数头文件一样在标准位置查找头文件。
- 如果找不到就提示编译错误。

**Linux环境的标准头文件的路径：**
```shell
/usr/include
```

注意按照自己的安装路径去找。
- 库文件包含 `#include <filename.h>`
- 查找头文件直接去标准路径下去查找，如果找不到就提示编译错误。
- 这样是不是可以说，对于库文件也可以使用“”的形式包含？
	- 可以的，不过查找的效率就低一些，且不容易区分本地文件还是库文件了
#### 3.7 嵌套文件包含

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/133c4ec8d0abdfe26b63a49cf9d25ef4.png)

- comm.h和comm.c是公共模块
- test1.h和test1.c使用了公共模块
- test2.h和test2.c使用了公共模块
- test.h和test.c使用了test1模块和test2模块
- 这样最终程序中就会出现两份comm.h的内容。这样就造成了文件内容的重复

**我们可以使用条件编译来解决这个问题！！！**
- 在每个头文件的开头写其`__大写名_H__` ，test.h文件如下
```c
#ifndef __TEST_H__
#define __TEST_H__
//头文件的内容
#endif   //__TEST_H__
```
- 或者
```c
#pragma once
```
- 就可以避免头文件的重复引入
## 4 其他预处理指令

```c
#error
#pragma
#line
...
不做介绍，自己去了解。

#pragma pack()在结构体部分已介绍。
```