---
文章标题: "[[7_InnoDB数据存储结构]]" 
文章作者: Dakkk
文章概要: |
  详细介绍InnoDB存储引擎的数据存储结构，从页的基本概念到内部结构，涵盖页目录、行格式、区段概念等核心存储机制的完整技术解析
tags:
- "InnoDB"
- "存储引擎"
- "数据页"
- "行格式"
- "页结构"
- "B+树"
- "索引存储"
- "MySQL存储"
相关文章:
- "[[2_从数据页的角度看 B+ 树]]"
- "[[2_MySQL 一行记录是怎么存储的？]]"
- "[[6_索引的数据结构]]"
- "[[8_ZSet面试与分析]]"
- "[[1_索引常见面试题]]"
文章分类: "🗄️ 数据库技术"
文章路径: "04-🗄️ 数据库技术/01-🐬 MySQL/02-🚀 高级特性/7_InnoDB数据存储结构.md"
文章难度: 中级 🌳
目前阶段: ✅ 已完成
重要性: ⭐⭐⭐⭐ 核心能力
创建时间: 2024-08-11 18:15:12
修改时间: 2025-05-27 23:09:58
---

## 1 数据库的存储结构：页

索引结构给我们提供了高效的索引方式，不过**索引信息以及数据记录都保存在文件上**的，确切说是**存储在页结构中**。另一方面，索引是在存储引擎中实现的，MySQL服务器上的存储引擎负责对表中数据的读取和写入工作。**不同存储引擎中存放的格式一般不同的**，甚至有的存储引擎比如Memory都不用磁盘来存储数据。

由于InnoDB是MySQL的默认存储引擎，所以**本章剖析InooDB存储引擎的数据存储结构**。

### 1.1 磁盘与内存交互基本单位：页

**InnoDB将数据划分为若干个页，InnoDB中页的大小默认为16KB**。

以**页作为磁盘和内存之间交互的基本单位**，也就是一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。也就是说，**在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page），数据库I/O操作的最小单位是页**。一个页中可以存储多个行记录。

> 记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次I/O操作）只能处理一行数据，效率会非常低。

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/3ec906e4e8637b9cd3432a2eb17cb042.png)

### 1.2 页结构概述

1. 页a、页b、页c...页n这些页可以不在物理结构上相连，只要==通过双向链表相关联==即可
2. 每个==数据页中的记录==会==按照主键值从小到大的顺序组成一个单向链表==，每个数据页都会==为存储在它里边的记录生成一个页目录==，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应的分组中的记录即可快速找到指定的记录。

### 1.3 页的大小

不同的数据库管理系统（简称DBMS）的页大小不同。比如在MySQL的InnoDB存储引擎中，默认页的大小是`16KB`，我们可以通过下面的命令来进行查看：
```mysql
show variables like '%innodb_page_size%';
```

SQLServer中页的大小为`8KB`，而在Oracle中我们用术语“`块`”（Block）来代表“页”，Oralce支持的块大小为2KB, 4KB, 8KB，16KB, 32KB和 64KB。

### 1.4 页的上层结构（了解）

另外在数据库中，还存在着区(Extent)、段(Segment)和表空间(Tablespace)的概念。行、页、区、段、表空间的关系如下图所示：
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/f5c360107f569819eb03aa1ae4b9789b.png)


**区（Extent）是比页大一级的存储结构**
- 在InnoDB存储引擎中，==一个区会分配64个连续的页==。因为InnoDB中的页大小默认是16KB，所以一个区的大小是`64*16KB=1MB`
- 区在文件系统是一个连续分配的空间（在InnoDB中是连续的64个页）

**段（Segment）由一个或多个区组成**
- 在段中==不要求区与区之间是相邻的==
- ==段是数据库中的分配单位==，不同类型的数据库对象以不同的段形式存在
- 当我们创建数据表、索引的时候，就会相应创建对应的段，比如==创建一张表时会创建一个表段==，==创建一个索引时会创建一个索引段==

**表空间（Tablespace）是一个逻辑容器**
- 表空间存储的对象是段，在一个==表空间中可以有一个或多个段==，但是==一个段只能属于一个表空间==
- 数据库由一个或多个表空间组成，表空间从管理上可以划分为==系统表空间==、==用户表空间==、==撤销表空间==、==临时表空间==等。
## 2 页的内部结构

页如果按类型划分的话，常见的有**数据页（保存B+树节点）**、**系统页**、**Undo页**和**事务数据页**等。数据页是我们最常使用的页。

数据页的16KB大小的存储空间被划分为七个部分，分别是文件头（FileHeader）、页头（PageHeader）、最大最小记录（Infimum+supremum）、用户记录（UserRecords）、空闲空间（FreeSpace）、页目录（PageDirectory）和文件尾（File Tailer）
![image.png|400](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/3e41d024a3defdc403f50369874cd122.png)

这7个部分作用分别如下，我们简单梳理如下表所示：
![image.png|400](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/567266993cfd0e3a4cc2868d0f4f00f3.png)

我们可以把这7个结构，分为3部分
### 2.1 part1：文件头和文件尾
<h4>1. File Header（文件头部）（38字节）</h4>
作用：描述各种页的通用信息。（比如页的编号、其上一页、下一页是谁等）

大小：38字节

| 名称                               | 占用空间大小 | 描述                                |
| -------------------------------- | ------ | --------------------------------- |
| FIL_PAGE_SPACE_OR_CHKSUM         | 4字节    | 页的校验和（checksum值）                  |
| FIL_PAGE_OFFSET                  | 4字节    | 页号                                |
| FIL_PAGE_PREV                    | 4字节    | 上一个页的页号                           |
| FIL_PAGE_NEXT                    | 4字节    | 下一个页的页号                           |
| FIL_PAGE_LSN                     | 8字节    | 页面被最后修改时对应的日志序列位置                 |
| FIL_PAGE_TYPE                    | 2字节    | 该页的类型                             |
| FIL_PAGE_FILE_FLUSH_LSN          | 8字节    | 仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值 |
| FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID | 4字节    | 页属于哪个表空间                          |

- `FIL_PAGE_OFFSET`（4字节）：每一个页都有一个==单独的页号==，就跟你的身份证号码一样，InnoDB通过页号可以唯一定位一个页。
- `FIL_PAGE_TYPE`（2字节）：这个代表当==前页的类型==，明确是数据页还是目录页，主要有以下页的类型
  ![image.png|400](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/eaba2bbb25a3f8af11518b15afc20e11.png)

- `FIL_PAGE_PREV`（4字节）`和FIL_PAGE_NEXT`（4字节）：InnoDB都是以页为单位存放数据的，如果数据分散到多个不连续的页中存储的话需要把这些页关联起来，FIL_PAGE_PREV和FIL_PAGE_NEXT就分别代表本页的上一个和下一个页的页号。这样通过建立一个双向链表把许许多多的页就都串联起来了，保证这些页之间不需要是物理上的连续，而是逻辑上的连续。（==双向链表==）

- `FIL_PAGE_SPACE_OR_CHKSUM`（4字节）：代表==当前页面的校验和（checksum）==
	- ==文件头和文件尾都有属性：FIL_PAGE_SPACE_OR_CHKSUM==
	- ==校验和== 是用来确定两个页是否相等的！主要是验证内存和磁盘同步过程中，页中的数据是否一致！举例说明如下：
		- InnoDB存储引擎以页为单位把数据加载到内存中处理，如果该页中的数据在内存中被修改了，那么在修改后的某个时间需要把数据同步到磁盘中。但是在同步了一半的时候断电了，造成了该页传输的不完整。
		- 为了检测一个页是否完整（也就是在同步的时候有没有发生只同步一半的尴尬情况），这时可以==通过文件尾的校验和（checksum 值）与文件头的校验和做比对，来确定磁盘和内存中的页是否是相等的==，如果两个值不相等则证明页的传输有问题，需要重新进行传输，否则认为页的传输已经完成。

- `FIL_PAGE_LSN`（8字节）：页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）

<h4>2. File Trailer（文件尾部）（8字节）</h4>
- ==前4个字节代表页的校验和==：这个部分是和File Header中的校验和相对应的。
- ==后4个字节代表页面被最后修改时对应的日志序列位置（LSN）==：这个部分也是为了校验页的完整性的，如果首部和尾部的LSN值校验不成功的话，就说明同步过程出现了问题。

### 2.2 part2：空闲空间、用户记录和最小最大记录

第二部分是记录部分，页的主要作用是存储记录
![image.png|400](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/4ba66dc9b2a4f3d90caa9d3561383e02.png)

<h4>1. Free Space (空闲空间)</h4>
我们**自己存储的记录会按照指定的行格式存储到User Records部分**。但是在一开始生成页的时候，其实并没有User Records这个部分

**每当我们插入一条记录，都会从Free Space部分，也就是尚未使用的存储空间中申请一个记录大小的空间划分到User Records部分**

当Free Space部分的空间全部被User Records部分替代掉之后，也就意味着这个页使用完了，如果还有新的记录插入的话，就需要去**申请新的页**了

![image.png|400](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/f979d19a9ebe7687e356bbe71339a466.png)

<h4>2. User Records (用户记录)</h4>
User Records中的这些记录**按照指定的行格式一条一条摆在User Records部分，相互之间形成单链表**

**用户记录里的一条条数据是如何记录的呢？**
- 需要讲讲记录行格式的==记录头信息==了 [2.6 COMPACT行格式](#2.6%20COMPACT行格式)
<h4>3. Infimum + Supremum（最小最大记录）</h4>
**记录可以比较大小吗？**
- 是的，记录可以比大小，对于一条完整的记录来说，比较记录的大小就是比较主键的大小。比方说我们插入的4行记录的主键值分别是：1、2、3、4，这也就意味着这4条记录是从小到大依次递增。

InnoDB规定的最小记录与最大记录这两条记录的构造十分简单，都是由5字节大小的记录头信息和8字节大小的一个固定的部分组成的。

这**两条记录不是我们自己定义的记录**，所以它们并不存放在页的User Records部分，他们被单独放在一个称为Infimum + Supremum的部分

![image.png|400](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/d41e5e106cfa53df254a8fdd50e12954.png)

### 2.3 part3：页目录和页面头部
<h4>1. Page Directory（页目录）</h4>

**为什么需要页目录？**
- 在==页中，记录是以单向链表的形式进行存储的==。单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。因此==在页结构中专门设计了检索，提升效率==。

**使用页目录，进行二分法查找**
1. ==将所有的记录分成几个组==，这些==记录包括最小记录和最大记录==，但不包括标记为“已删除”的记录。
2. 分组的特点：
	- 第 1 组，也就是最小记录所在的分组只有 1 个记录；
	- 最后1组，就是最大记录所在的分组，会有 1-8 条记录；
	- 其余的组记录数量在 4-8 条之间
	- 这样做的好处是，==除了第 1 组（最小记录所在组）以外，其余组的记录数会尽量平分==。
	
3. 在每个组中最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段
4. ==页目录用来存储每组最后一条记录的地址偏移量==，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），每个槽相当于指针指向了不同组的最后一个记录。

**举例：**
- 现在的page_demo表中正常的记录共有6条，InnoDB会把它们分成两组，第一组中只有一个最小记录，第二组中是剩余的5条记录。如下图：
  ![image.png|400](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/010b53735f5f15fd46a02a3d7daf7873.png)
**举例：** 现在的page_demo表中正常的记录共有6条，InnoDB把它们分为2组，如下图
![image.png|400](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/362ec92ab2d76ddfe1c836b9128df76d.png)

**从这个图中我们需要注意这么几点：**
- 现在页目录部分中有两个槽，也就意味着我们的记录被分成了两个组，槽1中的值是112，代表最大记录的地址偏移量（就是从页面的0字节开始数，数112个字节）；槽0中的值是99，代表最小记录的地址偏移量。
- 注意最小和最大记录的头信息中的n_owned属性
	- 最小记录的n_owned值为1，这就代表着以最小记录结尾的这个分组中只有1条记录，也就是最小记录本身。
	- 最大记录的n_owned值为5，这就代表着以最大记录结尾的这个分组中只有5条记录，包括最大记录本身还有我们自己插入的4条记录。

- 用箭头指向的方式替代数字，这样更易于我们理解，修改后如下
  ![image.png|400](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/b931c9269cacaf04175312444210f20e.png)


**为什么最小记录的n_owned值为1，而最大记录的n_owned值为5呢？**
- InnoDB规定：对于最小记录所在的分组只能有1条记录，最大记录所在的分组拥有的记录条数只能在1~8条之间，剩下的分组中记录的条数范围只能在是 4~8 条之间。

**分组是按照下边的步骤进行的：**
- 初始情况下一个数据页里只有最小记录和最大记录两条记录，它们分属于两个分组。
- 之后每插入一条记录，都会从页目录中找到主键值比本记录的主键值大并且差值最小的槽，然后把该槽对应的记录的n_owned值加1，表示本组内又添加了一条记录，直到该组中的记录数等于8个。
- 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量。

<h4>2. Page Header（页面头部）</h4>

为了能得到一个==数据页中存储的记录的状态信息==，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等，特意在页中 定义了一个叫Page Header的部分，这个部分占用固定的56个字节，专门存储各种状态信息。

| 名称                | 占用空间大小 | 描述                                                                  |
| ----------------- | ------ | ------------------------------------------------------------------- |
| PAGE_N_DIR_SLOTS  | 2字节    | 页目录中的槽数量                                                            |
| PAGE_HEAP_TOP     | 2字节    | 还未使用的空间最小地址，也就是说从该地址之后就是Free Space                                  |
| PAGE_N_HEAP       | 2字节    | 本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）                                      |
| PAGE_FREE         | 2字节    | 第一个已经标记为删除的记录的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用） |
| PAGE_GARBAGE      | 2字节    | 已删除记录占用的字节数                                                         |
| PAGE_LAST_INSERT  | 2字节    | 最后插入记录的位置                                                           |
| PAGE_DIRECTION    | 2字节    | 记录插入的方向                                                             |
| PAGE_N_DIRECTION  | 2字节    | 一个方向连续插入的记录数量                                                       |
| PAGE_N_RECS       | 2字节    | 该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）                                     |
| PAGE_MAX_TRX_ID   | 8字节    | 修改当前页的最大事务ID，该值仅在二级索引中定义                                            |
| PAGE_LEVEL        | 2字节    | 当前页在B+树中所处的层级                                                       |
| PAGE_INDEX_ID     | 8字节    | 索引ID，表示当前页属于哪个索引                                                    |
| PAGE_BTR_SEG_LEAF | 10字节   | B+树叶子段的头部信息，仅在B+树的Root页定义                                           |
| PAGE_BTR_SEG_TOP  | 10字节   | B+树非叶子段的头部信息，仅在B+树的Root页定义                                          |
## 3 InnoDB行格式（或记录格式）

### 3.1 行格式相关语法

**查看mysql中默认使用的行格式**
```mysql
SELECT @@innodb_default_row_format;
```
`mysql5.7和8都是使用dynamic行格式的`

**指定表的行格式**
```mysql
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
```

```mysql
ALTER TABLE 表名 ROW_FORMAT=行格式名称
```
### 3.2 COMPACT行格式(经典)

在MySQL 5.1版本中，默认设置为Compact行格式。一条完整的记录其实可以被分为记录的额外信息和记录的真实数据两大部分。
![image.png|400](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/f8471c07795cdb9c3a107d9fa8e67899.png)

假设我们要创建一个表
```mysql
CREATE TABLE page_demo(
	c1 INT,
	c2 INT,
	c3 VARCHAR(1000),
	PRIMARY KEY(c1)
) CHARSET=ascii ROW_FORMAT=Compact;
```

这个表中记录的行格式示意图如下：
![image.png|400](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/017c77d53cfc652b927b09889ff72675.png)

<h4>1. 变长字段长度列表</h4>
`维护一个列表，用于记录可变长度的列，实际数据大小和定义数据大小`
- 如VARCHAR(10)，定义了10个字符，我们列中的数据为`Hello`，只用了5个字符

MySQL支持一些变长的数据类型，比如VARCHAR(M)、VARBINARY(M)、TEXT类型，BLOB类型，这些数据类型修饰列称为变长字段，变长字段中存储多少字节的数据不是固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来。

**在Compact行格式中，把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表**。

>  注意：这里面存储的变长长度和字段顺序是反过来的。比如两个varchar字段在表结构的顺序是a(10)，b(15)。那么在变长字段长度列表中存储的长度顺序就是15，10，是==反过来的==。
<h4>2. NULL值列表</h4>`维护了一个NULL值列表，对列中为NULL的地方，进行标注`

Compact行格式会**把可以为NULL的列统一管理起来**，**存在一个标记为NULL值列表中**。如果表中没有允许存储 NULL 的列，则 NULL值列表也不存在了。

**为什么定义NULL值列表？**
- 之所以要存储NULL是因为数据都是需要对齐的，如果没有标注出来NULL值的位置，就有可能在查询数据的时候出现混乱。如果使用一个特定的符号放到相应的数据位表示空置的话，虽然能达到效果，但是这样很浪费空间，所以直接就在行数据得头部开辟出一块空间专门用来记录该行数据哪些是非空数据，哪些是空数据，格式如下：
	1. 二进制位的值为1时，代表该列的值为NULL。
	2. 二进制位的值为0时，代表该列的值不为NULL。

> 注意：同样顺序也是反过来存放的，列定义的时候写明`NOT NULL` 或 明确改列是主键了， 那改列就是0（不用管）

![image.png|400](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/f32cee7feb5a308dc4c0ec48942ef481.png)

<h4>3. 记录头信息（5字节）</h4>
这些记录头信息中各个属性如下表：

| 名称            | 大小（单位：bit） | 描述                                              |
| ------------- | ---------- | ----------------------------------------------- |
| 预留位1          | 1          | 没有使用                                            |
| 预留位2          | 1          | 没有使用                                            |
| delete_mask   | 1          | 标记该记录是否被删除                                      |
| mini_rec_mask | 1          | B+树的每层非叶子节点中的最小记录都会添加该标记                        |
| n_owned       | 4          | 表示当前分组拥有的记录数                                    |
| heap_no       | 13         | 表示当前记录在记录堆的位置信息                                 |
| record_type   | 3          | 表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录 |
| next_record   | 16         | 表示下一条记录的相对位置                                    |
示意图如下：
![image.png|400](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/eade90299d09a806c1efad2f97777596.png)

我们插入四条数据
```myqsl
INSERT INTO page_demo VALUES
(1,100,'song),
(2,200,'tong),
(3,300'zhan),
(4,400,'lisi');
```

![image.png|400](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/6e7fd14e914e4e7747d7feb42a6b9d9f.png)


- `delete_mask`：这个属性==标记着当前记录是否被删除==，占用1个二进制位（`逻辑删除`）
	- 值为0：代表记录并没有被删除
	- 值为1：代表记录被删除掉了
	- **被删除的记录为什么还在页中存储呢？**
		- 你以为它删除了，可它还在真实的磁盘上
		- 这些被删除的记录之所以不立即从磁盘上移除，是因为==移除它们之后其他的记录在磁盘上需要重新排列，导致性能消耗==
		- 所以只是打一个删除标记而已，所有被删除掉的记录都会组成一个所谓的==垃圾链表==，在这个链表中的记录占用的空间称之为可重用空间，之后如果有新记录插入到表中的话，可能把这些==被删除的记录占用的存储空间覆盖掉==

- `min_rec_mask`：
	- B+树的每层==非叶子节点==中的==最小记录都==会添加该标记，==min_rec_mask值为1==
	- 我们自己插入的四条记录的min_rec_mask值都是0，意味着它们都不是B+树的非叶子节点中的最小记录

- `record_type`：这个属性表示当前记录的类型，一共有4种类型的记录：
	- 0：表示普通记录
	- 1：表示B+树非叶节点记录
	- 2：表示最小记录
	- 3：表示最大记录

- `heap_no`：这个属性表示当前记录在本页中的位置，图中我们插入的4条数据的位置为 `2,3,4,5`
- **怎么不见heap_no值为0和1的记录呢？**
	- MySQL会自动给每个页里加了两个记录，由于这两个记录并不是我们自己插入的，所以有时候也称为伪记录或者虚拟记录。这==两个伪记录一个代表最小记录，一个代表最大记录==。==最小记录和最大记录的heap_no值分别是0和1==，也就是说它们的位置最靠前

- `n_owned`：我们之前讲过，在页目录中会给所有的记录分组，只有分组中最大记录的记录头会有此项信息，表示改组的记录个数
	- ==如下图，除最小记录，假设剩余记录为1组，那么最大记录中的n_owned字段值为5==

- `next_record`：记录头信息里该属性非常重要，它表示从当前记录的真实数据到下一条记录的真实数据的==地址偏移量（单向链表）==
	- 删除1条记录：被删除的记录的`delete_mask`改为1，修改偏移量（移动指针），最大记录的`n_owned`值减1
	- 增加1条记录：增加的记录的`delete_mask`改为0，修改偏移量（移动指针），最大记录的`n_owned`值加1
  ![image.png|400](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/8f0e7b59ea9f30359d7f970df9029870.png)

<h4>4. 记录的真实数据</h4>
**记录的真实数据，还有三个隐藏列！！！**，具体如下表：

| 列名           | 是否必须 | 占用空间 | 描述                   |
| -------------- | -------- | -------- | ---------------------- |
| row_id         | 否       | 6字节    | 行ID，唯一标识一条记录 |
| transaction_id | 是       | 6字节    | 事务ID                 |
| roll_pointer   | 是       | 7字节    | 回滚指针               |
**实际上这几个列的真正名称其实是：DB ROW_ID、DB TRX ID、DB ROLL PTR**
- 一个表没有手动定义主键，则会选取一个Unique键作为主键，如果连Unique键都没有定义的话，则会为表默认添加一个名为row_id的隐藏列作为主键。所以row_id是在没有自定义主键以及Unique键的情况下才会存在的
- 事务ID和回滚指针在后面 `14_MySQL事务日志` 中讲解

分析举例：
- 创建一个表并插入数据
  ![image.png|400](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/d84bf127455a7170b8e2bf79da687f3d.png)
- 使用Hex查看该数据文件的二进制文件
  ![image.png|400](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/90baaf6ceff85d5bd54b4c8030c20945.png)
- `简单分析第一行数据：`
	- 03 02 01：变长字段长度列表
	- 00：null值列表
	- 00 00 10 00 2c：5个字节的记录头信息
	- 00 00 00 2b 68 00：6个字节的row_id，因为没有定义主键和unique键，默认添加row_id为主键
	- 依次类推即可

### 3.3 Dynamic和Compressed行格式

<h4>1. 行溢出</h4>

**举例：**
![image.png|400](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/8491089e9bfb4a99550bcbf0323d585d.png)
- 如上图所示（==有错误，应该是65532==），我们使用ASCII字符集，一个字符为1个字节
- VARCHAR这个类型，最大值为65535个字节
- 考虑到真实内容中，还需要 2字节的可变长度列表 和 1字节的null列表
- 如果该列加上，NOT NULL，就可以再加1个字节，为65533

我们可以知道`一个页的大小一般是16KB，也就是16384字节`，而一个VARCHAR(M)类型的列就最多可以存储65533个字节，这样就可能**出现一个页存放不了一条记录，这种现象称为行溢出**

在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在**记录的真实数据处只会存储该列的一部分数据**，把**剩余的数据分散存储在几个其他的页中进行分页存**储，然后记录的真实数据处**用20个字节存储指向这些页的地址**（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。这称为**页的扩展**。

在MySQL 8.0中，默认行格式就是Dynamic，Dynamic、Compressed行格式和Compact行格式挺像，只不过在处理行溢出数据时有分歧
- Compressed和Dynamic两种记录格式==对于存放在BLOB中的数据采用了完全的行溢出的方式==。如图，在数据页中只存放20个字节的指针（溢出页的地址），实际的数据都存放在Off Page（溢出页）中
  ![image.png|400](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/9f8b0f8fda50c0f183a13b53ac5f0711.png)
	- 除此之外，Compressed行记录格式的另外一个功能就是，==存储在其中的行数据会以lib的算法进行压缩==

- Compact和Redundant两种格式会在记录的真实数据处存储一部分数据（存放768个前缀字节）。

### Redundant行格式

MySQL5.5版本之前的行格式，有兴趣自行了解！
## 4 区、段和碎片区

### 4.1 为什么要有区？

`B+`树的每一层中的页都会形成一个双向链表，如果是**以页为单位来分配存储空间**的话，**双向链表相邻的两个页之间的物理位置可能离得非常远**。

我们介绍B+树索引的使用场景的时候特别提到范围查询只需要定位到最左边的记录和最右边的记录，然后沿着双向链表一直扫描就可以了，而**如果链表中相邻的两个页物理位置离得非常远，就是所谓的随机I/O**。

再一次强调，磁盘的速度和内存的速度差了好几个数量级，随机I/O是非常慢的，所以我们应该尽量让链表中相邻的页的物理位置也相邻，这样进行范围查询的时候才可以使用所谓的顺序I/O。

**如何解决呢？**
- ==引入区的概念，一个区就是物理位置上连续的64个页==。因为InnoDB中的页的大小默认是16KB，所以一个区的大小是`64*16KB=1MB`
- 在==表中数据量大的时候==，==为某个索引分配空间==的时候就不再按照页的单位分配了，而是==按照区为单位分配==，甚至在表中的数据特别多的时候，可以一次性分配多个连续的区
- 虽然可能造成一点点空间的浪费（数据不足以填充满整个区），但是从性能角度看，可以消除很多的随机I/O，功大于过！
### 4.2 为什么要有段？

对于范围查询，其实是对B+树叶子节点中的记录进行顺序扫描，而如果不区分叶子节点和非叶子节点，统统把节点代表的页面放到申请到的区中的话，进行范围扫描的效果就大打折扣了。所以**InnoDB对B+树的叶子节点和非叶子节点进行了区别对待，也就是说叶子节点有自己独有的区，非叶子节点也有自己独有的区**。

**存放叶子节点的区的集合就算是一个段（segment），存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成2个段，一个叶子节点段，一个非叶子节点段**。

除了索引的叶子节点段和非叶子节点段之外，InnoDB中还有为存储一些特殊的数据而定义的段，比如回滚段。所以，常见的段有数据段、索引段、回滚段。数据段即为B+树的叶子节点，索引段即为B+树的非叶子节点。

在InnoDB存储引擎中，对段的管理都是由引擎自身所完成，DBA不能也没有必要对其进行控制。这从一定程度上简化了DBA对于段的管理。

**段其实**不对应表空间中的某一个连续的物理区域，而**是一个逻辑上的概念**，由若干个零散的页面以及一些完整的区组成。

### 4.3 为什么要有碎片区？

默认情况下，一个使用InnoDB存储引擎的表只有一个聚簇索引，一个索引会生成2个段，而段是以区为单位申请存储空间的，一个区默认占用`1M（64*16KB=1024KB）`存储空间，所以默认情况下一个只存在几条记录的小表也需要2M的存储空间么？以后每次添加一个索引都要多申请2M的存储空间么？这对于存储记录比较少的表简直是天大的浪费。这个问题的症结在于到现在为止我们介绍的区都是非常纯粹的，也就是一个区被整个分配给某一个段，或者说区中的所有页面都是为了存储同一个段的数据而存在的，即使段的数据填不满区中所有的页面，那余下的页面也不能挪作他用。

为了考虑以完整的区为单位分配给某个段对于数据量较小的表太浪费存储空间的这种情况，**InnoDB提出了一个碎片（fragment）区的概念**。在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，而是碎片区中的页可以用于不同的目的，比如有些页面用于段A，有些页面用于段B，有些页甚至哪个段都不属于。碎片区直属于表空间，并不属于任何一个段。

**所以此后为某个段分配存储空间的策略是这样的：**
- 在刚开始向表中插入数据的时候，==段是从某个碎片区以单个页面为单位来分配存储空间的==。
- 当==某个段已经占用了32个碎片区页面之后==，就会申请以完整的区为单位来分配存储空间。

所以现在段不能仅定义为是某些区的集合，更精确的应该是某些零散的页面已经一些完整的区的集合。

### 4.4 区的分类

区大体上可以分为4种类型：
- `空闲的区(FREE)`：现在还没有用到这个区中的任何页面。
- `有剩余空间的碎片区(FREE_FRAG)`：表示碎片区中还有可用的页面。
- `没有剩余空间的碎片区(FULL_FRAG)`：表示碎片区中的所有页面都被使用，没有空闲页面。
- `附属于某个段的区(FSEG)`：每一索引都可以分为叶子节点段和非叶子节点段

处于FREE、FREE_FRAG以及FULL_FRAG这三种状态的区都是独立的，直属于表空间。而处于FSEG状态的区是附属于某个段的。