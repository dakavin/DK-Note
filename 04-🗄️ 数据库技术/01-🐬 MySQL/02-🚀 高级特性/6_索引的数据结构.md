---
文章标题: "[[6_索引的数据结构]]" 
文章作者: Dakkk
文章概要: |
  深入分析MySQL数据库索引的数据结构，从索引基本概念到B+树实现原理，详细讲解InnoDB和MyISAM存储引擎的索引差异，以及数据结构选择的技术考量。
tags:
- "MySQL索引"
- "B+树"
- "数据结构"
- "InnoDB"
- "MyISAM"
- "聚簇索引"
- "二级索引"
- "数据库优化"
相关文章:
- "[[2_从数据页的角度看 B+ 树]]"
- "[[8_ZSet面试与分析]]"
- "[[0_二叉树]]"
- "[[0_哈希表理论基础]]"
- "[[0_课程完整内容]]"
文章分类: "🗄️ 数据库技术"
文章路径: "04-🗄️ 数据库技术/01-🐬 MySQL/02-🚀 高级特性/6_索引的数据结构.md"
文章难度: 中级 🌳
目前阶段: ✅ 已完成
重要性: ⭐⭐⭐⭐⭐ 精通必备
创建时间: 2024-08-11 18:15:12
修改时间: 2025-05-27 23:09:58
---

## 1 为什么使用索引

**索引是存储引擎用于快速找到数据记录的一种数据结构**，就好比一本教课书的目录部分，通过目录中找到对应文章的页码，便可快速定位到需要的文章。MySQL中也是一样的道理，进行数据查找时，首先查看查询条件是否命中某条索引，**符合则通过索引查找相关数据**，如果**不符合则需要全表扫描**，即需要一条一条地查找记录，直到找到与条件符合的记录。

![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/e74bb53463af2eed8ad188b974100129.png)

- 如上图所示
	- 数据库没有索引的情况下，数据 **分布在硬盘的不同的位置上面**，读取数据时，摆臂需要前后摆动查找数据，这样的操作非常耗时！
	- 如果 **数据按顺序摆放（连续的地址空间）**，也需要按照顺序读取数据，这样操作依旧非常耗时！如果表很大时，有上千万条数据，就意味着要 **做很多次磁盘IO** 才能找到
	- 执行过程：CPU先去磁盘查找记录，找到后加载到内存，然后对数据进行处理
	- 耗时情况：磁盘IO最耗时（涉及到磁盘的旋转时间、磁头的寻道时间）

假如给数据使用 **二叉树** 这样的数据结构进行存储，如下图所示
![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/70266c0f157e71a5383554aad1130199.png)
- 如上图所示
	- 对字段`Col2`添加索引，相当于在硬盘中维护了一个索引的数据结构（**二叉查找树**）
	- 二叉查找树的每个节点存储的是`Key-Value结构`
	- 如果知道算法，简单的说，使用这种结构，我们在查找数据的时候，时间复杂度是O(logn)的
	- 这样我们减少了磁盘IO的次数，加快查询的速度（时间少了）；
## 2 什么是索引及其优缺点

### 2.1 索引概述

MySQL官方对索引的定义为：**索引（Index）是帮助MySQL高效获取数据的一种数据结构**

**索引的本质**：索引是数据结构。
- 你可以简单理解为“排好序的快速查找数据结构”，满足特定查找算法。 这些数据结构以某种方式指向数据， 这样就可以**在这些数据结构的基础上实现 高级查找算法**

**索引是在存储引擎中实现的（即索引是和具体的存储引擎（表的结构）相关）**，因此每种存储引擎的索引不一定完全相同，并且每种存储引擎不一定支持所有索引类型。

同时，**存储引擎可以定义每个表的最大索引数和最大索引长度**。所有存储引擎支持每个表至少16个索引，总索引长度至少为256字节。有些存储引擎支持更多的索引数和更大的索引长度。
### 2.2 优点

（1）类似大学图书馆建书目索引，提高数据检索的效率，**降低 数据库的IO成本 ，这也是创建索引最主 要的原因**。
（2）通过**创建唯一索引**，可以保证数据库表中每一行 **数据的唯一性** 。
（3）在实现数据的 **参考完整性方面**，可以 加速表和表之间的连接 。换句话说，对于有依赖关系的子表和父表联合查询时， 可以提高查询速度。
（4）在使用**分组和排序（索引本身也是排好序的）** 子句进行数据查询时，可以**显著减少查询中分组和排序的时 间 ，降低了CPU的消耗**
### 2.3 缺点

增加索引也有许多不利的方面，主要表现在如下几个方面： 
（1）**创建索引和维护索引要 耗费时间** ，并 且随着数据量的增加，所耗费的时间也会增加。 
（2）索引**需要占磁盘空间** ，除了数据表占数据空间之 外，每一个索引还要占一定的物理空间， 存储在磁盘上 ，如果有大量的索引，索引文件就可能比数据文 件更快达到最大文件尺寸。 
（3）虽然索引大大提高了查询速度，同时却会 **降低更新表的速度** 。当对表 中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。 

因此，选择使用索引时，需要综合考虑索引的优点和缺点。

>    Tips：
>    索引可以提高查找的速度，但是会影响插入记录的速度。这种情况下，最好的办法是先删除表中的索引，然后插入数据，插入完成后再创建索引
## 3 InnoDB中索引的推演

### 3.1 索引之前的查找

先来看一个精确匹配的例子：
```mysql
SELECT [列名列表] FROM 表名 WHERE 列名 = xxx ；
```

>    ==页的概念说明：==
>    一张表中有很多数据，页是描述表中数据的基本单位，大小为16KB
>    页与页之间是通过双向链表连接起来的
>    即一页能存储表中多行记录（多行记录之间是通过单链表连接的）


<h4>1. 一个页中的查找</h4>
假设目前表中的记录比较少，所有的记录都可以被存放到一个页中，在查找记录的时候可以根据搜索条件的不同分为两种情况：

- **以主键为搜索条件**
	- 可以在页目录中使用==二分法==快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录

- **以其他列作为搜索条件**
	- 因为在数据页中并没有对非主键列建立所谓的页目录，所以我们无法通过二分法快速定位相应的槽
	- 这种情况下只能从==最小记录==开始==依次遍历==单链表中的每条记录，然后对比每个记录是不是符合搜索条件，很显然这种查询效率是非常低的。

<h4>2. 很多页中查找</h4>
大部分情况下我们表中存放的记录都是非常多的，需要好多的数据页来存储这些记录。在很多页中查找记录的话可以分为两个步骤：
1. 定位到记录所在的页
2. 从所在的页进行查找对应的记录

在**没有索引的情况**下，不论是根据主键列或者其他列的值进行查找，由于我们并不能快速的定位到记录所在的页，所以**只能从第一个页沿着双向链表一直往下找**，在每一个页中根据我们上面的查找方式去查找指定的记录。因为要遍历所有的数据页，所以这种方式显然是**超级耗时**的。如果一个表有一亿条记录呢？**此时索引应运而生**。
### 3.2 设计索引

建一个表：
```mysql
CREATE TABLE index_demo(
	c1 INT,
	c2 INT,
	c3 CHAR(1),
	PRIMARY KEY(c1)
) ROW_FORMAT = Compact;
```

这个新建的`index_demo`表中有2个INT类型的列，1个CHAR(1)类型的列，而且我们**规定了c1列为主键**，这个表使用Compact行格式（下一章会讲解）来实际存储记录的。这里我们简化了index_demo表的行格式示意图：
![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/6621652595ee6200beae416d4b5df6a8.png)

我们只在示意图里展示记录的这几个部分：
- `record_type` ：记录头信息的一项属性，==表示记录的类型==， 0 表示普通记录、 2 表示最小记 录、 3 表示最大记录、 1 暂时还没用过，后续讲；
- `next_record` ：记录头信息的一项属性，表示下一条地址相对于本条记录的地址偏移量，我们用 箭头来==表明下一条记录是谁==
- `各个列的值` ：这里只记录在 index_demo 表中的三个列，分别是 c1 、 c2 和 c3
- `其他信息` ：除了上述3种信息以外的所有信息，包括其他隐藏列的值以及记录的额外信息

将记录格式示意图的其他信息项暂时去掉并把它**竖起来的效果**就是这样：
![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/31c518ede26637f4ca272dc21ae8f019.png)

把一些记录放到**页里的示意图**就是：
![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/151f3e80c35d28af1b37a4574020c138.png)

<h4>1. 简单的索引设计方案</h4>
我们在根据某个搜索条件查找一些记录时为什么要遍历所有的数据页呢？因为各个页中的记录并没有规律，我们并不知道我们的搜索条件匹配哪些页中的记录，所以不得不依次遍历所有的数据页。

如果 我们 **想快速的定位到需要查找的记录在哪些数据页** 中该咋办？我们可以为快速定位记录所在的数据页而 建 立一个目录 ，建这个目录必须完成下边这些事：
- ==下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值==
	- 假设：每个数据页最多能存放3条记录，我们向index_demo表插入3条记录
		```mysql
		INSERT INTO index_demo VALUES
		(1,4,'u'),
		(3,9,'d'),
		(5,3,'y');
		```
	- 那么这些记录就按照主键值的大小串联成一个单向链表了，如图所示
	  ![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/49d4b0464db431aed74db6a4af5dddac.png)
	- 然后我们不断添加数据：
		- "4,4,a"：4比5小，要保证主键是依次递增的，所以进行==记录移动==，主键为5的这条记录放在==分配的新页==上，主键为4这条记录插入在页10这里
		- 后续就不断添加下图中的数据

- ==给所有的页建立一个目录项==
	- 由于数据页的==编号可能不是连续的==，所以在向表中插入许多记录后，是如下效果
	  ![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/fe3b90abe16887da2518d1aaa3a7f19d.png)
	- 如果想从这么多页中，根据主键==快速定位某些记录所在的页==，我们需要给这些页做一个目录，每一个页对应一个目录项，每个目录包含两部分内容
		- `key`：页中最小的主键值
		- `page_no`：表示页号
	- 为上边几个页做好的目录如下图所示
	  ![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/08495fb456cd63d78370dd3958e9d2f2.png)
	- 以 ==页28== 为例，它对应 ==目录项2== ，这个目录项中包含着==该页的页号 28== 以及==该页中用户记录的最小主 键值 5 ==。我们只需要把几个目录项在物理存储器上连续存储（比如：数组），就可以实现根据主键 值快速查找某条记录的功能了
	- 比如：查找主键值为 20 的记录，具体查找过程分两步：
		- 先从目录项中根据 二分法 快速确定出主键值为 20 的记录在 目录项3 中（因为 12 < 20 < 209 ），它对应的页是 页9
		- 再根据前边说的在页中查找记录的方式去 页9 中定位具体的记录

至此，针对数据页做的简易目录就搞定了。这个**目录有一个别名，称为 索引**

<h4>2. InnoDB的索引方案</h4>
<h5>①迭代1次：记录目录项的页</h5>
根据我们上述的简单索引设计，目录项如果是连续的内存空间，会存在如下问题：
1. 目录项的删除和插入，会导致目录项内存地址的连续移动，成本高；
2. 当表的数据越来越多，页也会增多，从而导致目录项也增多，连续空间占据存储比较大块的区域，从而给存储造成压力比较大；

分析和解决：由于每个目录项和我们的页是类似的，所以可以采取页的做法，将==每个目录项使用单向链表连接==，然后==归于一个记录目录项的页（目录页）中==

如何区分目录页和数据页的区别呢？
- 把这些用来表示目录项的记录称为 `目录项记录`，使用记录头信息`record_type`属性，它的各个取值代表的意思如下：
	- 0 ： 普通用户记录
	- ==1 ：目录项记录==
	- 2 ： 最小记录
	- 3 ： 最大记录

最后，我们把前边使用到的目录项放到数据页中的样子就是这样：
![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/b458ea13f4894363a69a7b771902dbfd.png)

从图中我们可以看出目录页和数据页中的区别：
- 不同点：
	- 目录页的`record_type`的值是1，而数据页是0
	- 目录页的内容只有==主键值和数据页的编号==，而数据页是由用户自定义的（还有InnoDB自己添加的隐藏列）
	- 记录头信息中还有一个叫`min_rec_mask`的属性，只有目录页中的主键值最小的记录的`min_rec_mask`值为1，其他别的记录都是0
- 相同点：
	- 用的都是数据页，会为主键生成`Page Directory（页目录--后续会讲）`，从而在按照主键值进行查找的时候可以使用==二分法==来加快查询速度


<h5>②迭代2次：多个目录页</h5>
假设目录页最多存储4个目录项，我们不断向表中插入数据后，单个目录页肯定不够用

这时，我们就需要使用多个目录页，来维持新增的目录项

![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/e84f162405d5e1f052877c6f6c746b27.png)

从图中可以看出，我们插入了一条主键值为320的用户记录之后需要两个新的数据页：
- 为存储该用户记录而新生成了==页31==
- 因为原先存储目录项记录的 ==页30的容量已满== （我们前边假设只能存储4条目录项记录），所以不得 不==需要一个新的 页32 来存放 页31 对应的目录项==

现在因为存储目录项记录的页不止一个，所以如果我们想根据主键值查找一条用户记录大致需要3个步 骤，以查找主键值为 20 的记录为例：
- 确定 目录项记录页
- 通过目录项记录页 确定用户记录真实所在的页
- 在真实存储用户记录的页中定位到具体的记录。
<h5>③迭代3次：记录目录页的目录页</h5>
在上次迭代中，我们已经创建了多个目录页了，如果目录页又多起来了，就会导致存储上和查询效率上的一些问题，此时我们就需要继续迭代，为这多个目录页再创建目录页

![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/71edd49ef4c83a8ce007ad2802c50842.png)

③ 迭代3次：目录项记录页的目录页 如图，我们生成了一个存储更高级目录项的 页33 ，这个页中的两条记录分别代表页30和页32，如果用 户记录的主键值在 `[1, 320) `之间，则到页30中查找更详细的目录项记录，如果主键值 不小于320 的 话，就到页32中查找更详细的目录项记录。

我们可以用下边这个图来描述它：
![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/008cf2f8eebd5aaa47ca6bd6d9c0dd51.png)

这个数据结构，它的名称是` B+树`
<h5>④B+Tree</h5>
一个B+树的节点其实可以分成好多层，**规定最下边的那层，也就是存放我们用户记录的那层为第 0 层**， 之后依次往上加。

之前我们做了一个非常极端的假设：存放用户记录的页 最多存放3条记录 ，存放目录项 记录的页 最多存放4条记录 。

其实**真实环境中一个页存放的记录数量是非常大的**，假设所有**存放用户记录 的叶子节点**代表的数据页**可以存放 100条用户记录** ，所有**存放目录项记录的内节点**代表的数据页**可以存 放 1000条目录项记录** ，那么：
- 如果B+树只有1层，也就是只有1个用于存放用户记录的节点，最多能存放 ==100== 条记录
- 如果B+树有2层，最多能存放 ==1000×100=10,0000== 条记录
- 如果B+树有3层，最多能存放 ==1000×1000×100=1,0000,0000== 条记录
- 如果B+树有4层，最多能存放 ==1000×1000×1000×100=1000,0000,0000== 条记录。相当多的记 录！！！
- ......

你的表里能存放 100000000000 条记录吗？所以**一般情况下，我们 用到的B+树都不会超过4层** ，那我们 **通过主键值去查找某条记录最多只需要做4个页面内的查找（查找3个目录项页和一个用户记录页）**，又 因为在**每个页面内有所谓的 Page Directory （页目录）**，所以在**页面内也可以通过 二分法 实现快速 定位记录**。
### 3.3 常见索引概念

索引按照物理实现方式，索引可以分为 2 种：聚簇（聚集）和非聚簇（非聚集）索引。我们也把非聚集 索引称为二级索引或者辅助索引。
<h4>1. 聚簇索引</h4>
**聚簇索引**并不是一种单独的索引类型，而**是一种数据存储方式**（所有的用户记录都存储在了叶子节点），也就是所谓的`索引即数据，数据即索引`。

>  术语"聚簇"表示数据行和相邻的键值聚簇的存储在一起。

**特点：**
1. 使用记录主键值的大小进行记录和页的排序，包括三个方面的含义
	- ==页内==的记录是按照主键的大小顺序排列成一个==单向链表==
	- 各个存放==用户记录的页==也是根据也中用户记录的主键大小顺序排列成的一个==双向链表==
	- 存放==目录项记录的页==分为不同的层次，在同一层次中的页也是根据也中目录项记录的主键大小顺讯排成一个==双向链表==

2. B+数的==叶子节点==存储的是完整的用户记录
	- 所谓完整的用户记录，就是指这个记录中存储了所有列的值（包括隐藏列）

我们把**具有这两种特性的B+树称为聚簇索引**，所有完整的用户记录都存放在这个**聚簇索引的叶子节点**处。这种聚簇索引并不需要我们在MySQLi语句中显式的使用INDEX语句去创建，**InnoDB存储引擎会自动的为我们创建聚簇索引**。

**优点：**
- ==数据访问更快== ，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非 聚簇索引更快 
- 聚簇索引对于主键的 ==排序查找== 和 ==范围查找== 速度非常快 
- 按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多 个数据块中提取数据，所以 ==节省了大量的io操作==

**缺点：**
- ==插入速度严重依赖于插入顺序== ，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影 响性能。因此，对于InnoDB表，我们一般都会定义一个==自增的ID列为主键== 
- ==更新主键的代价很高== ，因为会导致被更新的行移动。因此，对于InnoDB表，我们一般定义==主键为 不可更新== 
- 二级索引访问需要两次索引查找 ，第一次找到主键值，第二次根据主键值找到行数据

**限制：**
- 对于MySQL数据库目前==只有InnoDB数据引擎支持聚簇索引==，而MyISAM并不支持聚簇索引。
- 由于数据物理存储排序方式只能有一种，所以==每个MySQL的表只能有一个聚簇索引==。一般情况下就是该表的主键。
- 如果==没有定义主键，Innodb会选择非空的唯一索引代替==。如果没有这样的索引，Innodb会隐式的定义一个主键来作为聚簇索引。
- 为了充分利用聚簇索引的聚簇的特性，所以==innodb表的主键列尽量选用有序的顺序id==。而不建议用无序的id，比如UUID、MD5、HASH、字符串列作为主键无法保证数据的顺序增长。

<h4>2. 二级索引（辅助索引、非聚簇索引）</h4>
上边介绍的**聚簇索引只能在搜索条件是主键值时才能发挥作用**，因为B 树中的数据都是按照主键进行排序的。那如果我们想**以别的列作为搜索条件该怎么办呢？** 肯定不能是从头到尾沿着链表依次遍历记录一遍。

**答案：** 我们可以**多建几棵B+树**，不同的B+树中的数据采用不同的排序规则。比方说我们用c2列的大小作为数据页、页中记录的排序规侧，再建一棵B+树，效果如下图所示：
![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/00c3530c174eaff297259631a6d04d56.png)

**概念：回表** 
- 我们根据这个以c2列大小排序的B+树==只能确定我们要查找记录的主键值==
- 所以如果我们想==根据c2列的值查找到完整的用户记录的话==，==仍然需要到 聚簇索引 中再查一遍==，这个过程称为 回表 。也就是根据c2列的值查询一条完整的用户记录需要使用到 2 棵B+树！

**问题：**
- 为什么我们还需要一次 回表 操作呢？直接把完整的用户记录放到叶子节点不OK吗？
	- 把完整的用户记录放在二级索引的叶子节点，太浪费存储空间了


我们把这种按照非主键列建立的B+树称为二级索引，也可以称这个B+树是为c2列建立的索引

非聚簇索引的存在不影响数据在聚簇索引中的结构，所以**一张表可以有多个非聚簇索引**
  ![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/428be5edddd1f1b004974295d34f7bbe.png)
**小结：**
- 聚簇索引的叶子节点存储的就是我们的数据记录，非聚簇索引的叶子节点存储的是数据位置。非聚簇索引不会影响数据表的物理存储顺序。
- 一个表只能有一个聚簇索引，因为只能有一种排序存储的方式，但可以有多个非聚簇索引，也就是多个索目录提供数据检索。
- 使用聚簇索引的时候，数据的查询效率高，但如果==对数据进行插入，删除，更新等操作，效率会比非聚簇索引低==。

<h4>3. 联合索引</h4>
我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让**B+树按 照 c2和c3列 的大小进行排序**，这个包含两层含义： 
- 先把各个记录和页按照c2列进行排序。 ==先按c2进行排序，生成c2的非聚簇索引==
- 在记录的c2列相同的情况下，采用c3列进行排序，==c2相同的地方，在采用c3进行排序==

注意一点，**以c2和c3列的大小为排序规则建立的B+树称为 联合索引** ，**本质上也是一个二级索引**。它的意 思与分别为c2和c3列分别建立索引的表述是不同的，不同点如下：
- ==c2和c3联合索引，只会生成一颗B+树==

![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/6c2ab6b3b3906a1a1dbd463deb836d0d.png)

### 3.4 InnoDB和B+树索引的注意事项、
<h4>1. 根页面位置万年不动（聚簇索引）</h4>
`根页面/节点是常驻内存的！！！`

我们之前介绍B+树索引的时候，是自下往上的过程，即先画出来叶子节点，再描述目录项。而**在MySQL实际存储过程中，是自上而下的**，具体过程如下：
- 开始为某个表创建一个B+树索引的时候，会为这个索引创建一个==根节点页面==
- 表中没有数据，到有数据的时候，此时==根节点存储的是用户记录==
- 当==根节点空间用完==时，继续插入记录，就会把根节点的数据复制到新分配的页a，然后页a进行==页分裂==的操作，得到新的页b，此时会将数据排列顺序依次放入页a和页b，而==根节点变为了存储目录项的目录页==

**注意：** 
- 一个B+树的根节点是不会移动的！！！只有在根节点空间用完的时候，会移动根节点中的数据到新页中去
- 这样的话，InnoDB存储引擎需要用到这个索引的时候，就直接找根节点就完事了
<h4>2. 内节点中目录项记录的唯一性（非聚簇索引）</h4>

> **内节点指的是非叶子节点的其他节点**

我们知道B+树索引的内节点中目录项记录的内容是**索引列+页号的搭配**，但是**这个搭配对于二级索引来说有点儿不严谨**。还拿`index_demo`表为例，假设这个表中的数据是这样的：
![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/4b64e0a7056a971ec639d6217475835a.png)

如果二级索引中目录项记录的内容只是`索引列+页号`的搭配的话，那么为c2列建立索引后的B+树应该长这样：
![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/403dc99bd8bc992050318622512b98c0.png)

如果此时我们插入一条数据 `c1 = 9 ,c2 = 1,c3 = 'c'`，此时c2还是1，**那这条记录是放在页4还是页5呢？答案：MySQL懵了**

**解决办法：内节点的目录项记录唯一！**
- 把==主键值==页添加到二级索引内节点中的目录项记录中，这样就能保证B+树每一层节点中各条目录项记录都是唯一的，如下图：
  ![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/d84eeb2b43a8d67d5b33c7a39a91185a.png)
- 此时我们继续添加这条记录，就很明显知道，我们需要添加到==页5==
<h4>3. 一个页面最少存储2条记录</h4>

一个B+树只需要很少的层级就可以轻松存储数亿条记录，查询速度相当不错！

这是因为B+树本质上就是一个大的多层级目录，每经过一个目录时都会过滤掉许多无效的子目录，直到最后访问到存储真实数据的目录。

**那如果一个大的目录中只存放一个子目录是个啥效果呢？**
- 那就是目录层级非常非常非常多，而且最后的那个存放真实数据的目录中只能存放一条记录。费了半天劲只能存放一条真实的用户记录？
- 所以InnoDB的一个数据页至少可以存放两条记录。
## 4 MyISAM中的索引方

**B树索引适用存储引擎如表所示：**

| 索引/存储引擎  | MyISAM | InnoDB | Memory |
| -------- | ------ | ------ | ------ |
| B-Tree索引 | 支持     | 支持     | 支持     |

即使多个存储引擎支持同一种类型的索引，但是他们的实现原理也是不同的。
- Innodb和MyISAM默认的索引是Btree索引；
- 而Memory默认的索引是Hash索引

**MyISAM引擎使用 B+Tree 作为索引结构，叶子节点的data域存放的是 数据记录的地址**
### 4.1 MyISAM索引的原理

我们已经知道了**InnoDB中索引及数据（叶子节点包含了数据）**，而MyISAM的索引方案虽然也是用了树形结构，但是却 **将索引和数据分开存储**：
- ==数据（.MyD）==：将表中的记录==按照记录的插入顺序==单独存储在一个文件中，不划分为若干个数据页，==没有可以按照主键大小对记录进行排序==
- ==索引（.MyI）==：单独为表的主键创建一个索引，索引中的叶子节点存储的是 ==主键值+数据记录的地址值==的组合
  ![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/6c1d8c7479b86a2b3ba6000f0f72c412.png)
- 如果我们在Col2上建立一个二级索引，则此索引的结构如下图所示：
  ![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/a546c911139882c8f8f189255ab4556d.png)
- **本质上：MyISAM是没有聚簇索引的，可以把其索引理解为都是非聚簇索引**
### 4.2 MyISAM 与 InnoDB 对比

- 在==InnoDB==存储引擎中，我们只需要根据主键值对 ==聚簇索引== 进行一次查找就能找到对应的记录，而在 ==MyISAM== 中却需要进行一次 ==回表== 操作，意味着MyISAM中建立的索引相当于全部都是 ==二级索引==

- InnoDB的数据文件本身就是索引文件，而MyISAM索引文件和数据文件是 ==分离的== ，索引文件仅保存数据记录的地址

- InnoDB的非聚簇索引data域存储相应记录 主键的值 ，而MyISAM索引记录的是 地址 。换句话说， InnoDB的所有非聚簇索引都引用主键作为data域

- MyISAM的回表操作是十分 快速 的，因为是拿着地址偏移量直接到文件中取数据的，反观InnoDB是通 过获取主键之后再去聚簇索引里找记录，虽然说也不慢，但还是比不上直接用地址去访问

- InnoDB要求表 必须有主键 （ MyISAM可以没有 ）。如果没有显式指定，则MySQL系统会自动选择一个 可以非空且唯一标识数据记录的列作为主键。如果不存在这种列，则MySQL自动为InnoDB表生成一个隐 含字段作为主键，这个字段长度为6个字节，类型为长整型

![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/2af965ce261e3e76bf12b3a732468e2d.png)

**小结：**
- InnoDB存储引擎下，**主键的字段不建议太长**，因为所有的二级索引都引用了主键索引，过程的主键索引会令二级索引变得很大
- InnoDB存储引擎下，**主键不要使用非单调（即不是递增/递减的）字段**，因为非单调字段在插入记录时，存储引擎为了位置B+Tree的特性而频繁的分裂调整，十分低效
## 5 索引的代价

索引是个好东西，可不能乱建，它在空间和时间上都会有消耗：

- **空间上的代价**
  - 每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认会 占用 16KB 的存储空间，一棵很大的B+树由许多数据页组成，那就是很大的一片存储空间

- 时间上的代价
  - 每次 ==增、删、改== 操作时，都需要去改B+树索引
  - 这些操作会对节点和记录的排序造成破坏，存储引擎需要额外的时间去进行==记录移位、页面分裂、页面回收==等操作来维护节点和记录的排序
  - 如果有许多索引，会给性能拖后腿

## 6 MySQL数据结构选择的合理性

从MySQL的角度讲，影响性能的关键点在于磁盘的IO操作。
- 查找都是索引操作，==一般对于关系型数据库，其索引非常大==，且==索引文件是存储在外部磁盘上==的
- 我们利用索引查询的时候，不可能加载所有的索引，只能==逐一加载==，那么MySQL衡量查询效率的标准就是磁盘的IO次数
### 6.1 全表遍历

懂的都懂，肯定不行，效率太低，不过也考虑一下两面性（情况极低）
### 6.2 Hash结构

举例：如果有两个文件，让你看看这两个文件是否相同
- 两个文件逐一比对，效率低，还可能出错
- 两个文件经过hash函数计算的结果比对，一眼看出是否相同

![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/91fbadff9a3f85cd048dcaf20d98d47c.png)

上图中哈希函数h有可能将两个不同的关键字映射到相同的位置，这叫做 碰撞 ，在数据库中一般采用 链 接法 来解决。在链接法中，将散列到同一槽位的元素放在一个链表中，如下图所示：
![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/94d802a6bfefbe7f9292d27b68bfba12.png)

体会数组和hash表在查找方面的效率区别
![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/41493171c747df2b017a84e2fe8cb9b6.png)

**Hash结构效率高，那为什么索引结构要设计成树型呢？**
- Hash索引，仅能满足 `= < > IN` 的查询，如果进行范围查询，时间复杂度会 退化为O(n)
- Hash索引，数据的存储是==没有顺序的==，使用ORDER BY的时候，数据需要重新排序
- 联合索引的情况下，Hash值将联合索引键合并后一起计算的，无法对单独一个键或几个索引进行查询
- 对于等值查询来说，Hash索引的效率更高，但是如果有hash冲突，时间复杂度也退化为O(n)

**补充：Memory存储引擎是支持HASH索引的**

**InnoDB本身不支持Hash索引的，但是提供自适应Hash索引（Adaptive Hash Index）**，如果某个数据被经常访问，当满足一定条件时，就会把这个数据页的地址存放到Hash表中，下次查询的时候，直接找到这个页的所在位置，这样就让B+树也具备了Hash索引的优点。
![image.png|380|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/d84a1b005dc3ad56ef5a9365c21774c2.png)


采用自适应 Hash 索引目的是方便根据 SQL 的查询条件==加速定位到叶子节点==，特别是当 B+ 树比较深的时 候，==通过自适应 Hash 索引可以明显提高数据的检索效率==

我们可以通过 `innodb_adaptive_hash_index` 变量来查看是否开启了自适应 Hash，比如：
```mysql
show variables like '%adaptive_hash_index%';
```

![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/d23e6022556995e056ecb727456184e4.png)

### 6.3 二叉搜索树

如果我们利用二叉树作为索引结构，那么磁盘的IO次数和索引树的高度是相关的

**1. 特点**
- 一个节点最多只能有两个子节点
- 所有的节点，左边永远比右边小

**2. 查找规则**
- key大于根节点，在右子树中进行查找
- key小于根节点，在左子树中进行查找
- key等于根节点，直接返回
- 左右子树的查找过程中，不断重复上述步骤

正常情况的二叉查找树
![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/520a632291bf5d258cc497ae0358aaea.png)

特殊情况下的二叉查找树，此时效率就退化为O(n)
![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/17815844131eefc160d04977dbb81baa.png)

为了提高查询效率，就需要 **减少磁盘IO数** 。为了减少磁盘IO的次数，就需要尽量 **降低树的高度** ，需要把 原来“瘦高”的树结构变的“矮胖”，树的每层的分叉越多越好。

### 6.4 AVL树（平衡二叉树）

主要是为了解决二叉查找树退化为链表的问题，它在二叉查找树的基础上增加了约束，具有一下性质：
- 它是一颗空树
- 它的左右两个子树的高度差的绝对值不能超过1，且左右两个子树也是平衡二叉树

![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/ad4329dc9b29a9072048a7ce04b39a51.png)


常见的平衡二叉树有很多种，主要包括了 **平衡二叉搜索树、红黑树、数堆、伸展树**，它们的时间复杂度一般都是 `O(logn)`的

针对同样的数据，如果我们把二叉树改成` M 叉树 （M>2）呢？`当 M=3 时，同样的 31 个节点可以由下面 的三叉树来进行存储：

![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/75f4f2cb443fed24c5f4f353614d721e.png)

M叉树的高度会远小于二叉树的高度，所以**我们需要就把一个树，从瘦变成胖了！**
### 6.5 B-Tree

在上述的基础上，我们引入了B-Tree

B树的英文是Balance Tree,也就是多路平衡查找树。简写为B-Tree(注意横杠表示这两个单词连起来的意思，不是减号）。它的高度远小于平衡二叉树的高度。

B 树的结构如下图所示：
![image.png|600](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/fbc5f74f1b72c0ddaaef23b738bb5137.png)

- 一个 M 阶的 B 树（M>2）有以下的特性：（暂时可以不看）
	1. 根节点的儿子数的范围是` [2,M]`
	2. 每个中间节点包含 k-1 个关键字和 k 个孩子，孩子的数量 = 关键字的数量 +1，k 的取值范围为 `[ceil(M/2), M]`
	3. 叶子节点包括 k-1 个关键字（叶子节点没有孩子），k 的取值范围为` [ceil(M/2), M]`
	4. 假设中间节点节点的关键字为：Key[1], Key[2], …, Key[k-1]，且关键字按照升序排序，即 Key[i] <Key[i+1]。此时 k-1 个关键字相当于划分了 k 个范围，也就是对应着 k 个指针，即为：P[1], P[2], …, P[k]，其中 P[1] 指向关键字小于 Key[1] 的子树，P[i] 指向关键字属于 (Key[i-1], Key[i]) 的子树，P[k] 指向关键字大于 Key[k-1] 的子树
	5. 所有叶子节点位于同一层

上面那张图所表示的 B 树就是`一棵 3 阶的 B 树`。我们可以看下磁盘块 2，里面的关键字为（8，12），它 有 3 个孩子 (3，5)，(9，10) 和 (13，15)，你能看到 (3，5) 小于 8，(9，10) 在 8 和 12 之间，而 (13，15) 大于 12，刚好符合刚才我们给出的特征。

然后我们来看下如何用 B 树进行查找。假设我们想要 ==查找的关键字是 9== ，那么步骤可以分为以下几步： 
1. 我们与根节点的关键字 (17，35）进行比较，9 小于 17 那么得到指针 P1； 
2. 按照指针 P1 找到磁盘块 2，关键字为（8，12），因为 9 在 8 和 12 之间，所以我们得到指针 P2； 
3. 按照指针 P2 找到磁盘块 6，关键字为（9，10），然后我们找到了关键字 9。 

你能看出来在 B 树的搜索过程中，我们比较的次数并不少，但如果把数据读取出来然后在内存中进行比 较，这个时间就是可以忽略不计的。而读取磁盘块本身需要进行 I/O 操作，消耗的时间比在内存中进行 比较所需要的时间要多，是数据查找用时的重要因素。==B 树相比于平衡二叉树来说磁盘 I/O 操作要少== ， 在==数据查询中比平衡二叉树效率要高==。所以 只要树的高度足够低，IO次数足够少，就可以提高查询性能 。

我们再来看一张B树的图：
![image.png|600](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/f97666de00784492bb9b5f5e42919452.png)

**很显然，在内节点中，也是包含数据的！！！这个我们说的B+Tree不一样**
### 6.6 B+Tree

B+树也是一种多路搜索树，`基于B树做出了改进`，主流的DBMS都支持B+树的索引方式，比如MySQL。相比于B-Tree，`B+Tree适合文件索引系统`。

**B+树和B树的差异在于以下几点**
- 有k个孩子的节点就有k个关键字。也就是孩子数量=关键字数，而B树中，孩子数量=关键字数+1
- 非叶子节点的关键字也会同时存在在子节点中，并且是在子节点中所有关键字的最大（或最小）
- 非叶子节点仅用于索引，不保存数据，数据都在叶子结点中
- 所有关键字都在叶子结点出现，叶子节点构成一个有序（按关键字排序的）链表

**MySQL为什么选择B+树呢？**
- B+树查询效率更稳定！因为B树的非叶子节点也存放了数据，会导致查询效率不稳定的情况
- B+树的查询效率更高！因为B+树的非叶子节点只存放主键和页，存放内容更多，树层次比较低，IO次数更少
- 查询范围上，B+树的效率也比B树高！因为B树非叶子节点有数据，顺序查找的时候，需要在各个层中上下跳动

> B 树和 B+ 树都可以作为索引的数据结构，在 MySQL 中采用的是 B+ 树。 
> 
> 但B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然

![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/aa07c7639323e532ae4fc1d06432dbc9.png)

![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/3881497b1c0ff56bca8413918804e484.png)

![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/54d13199a8b6ff9a5ab1d5e6fc2a79c8.png)
### 6.7 R树（了解）

R-Tree在MySQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有MyISAM、bdb、innodb、ndb、archive几种。

举个R树在现实领域中能够解决的例子：查找20英里以内所有的餐厅。如果没有R树你会怎么解决？一般情况下我们会把餐厅的坐标x,y)分为两个字段存放在数据库中，一个字段记录经度，另一个字段记录纬度。这样的话我们就需要遍历所有的餐厅获取其位置信息，然后计算是否满足要求。如果一个地区有100家餐厅的话，我们就要进行100次位置计算操作了，如果应用到谷歌、百度地图这种超大数据库中，这种方法便必定不可行了。

R树就很好的解决了这种高维空间搜索问题。它把B树的思想很好的扩展到了多维空间，采用了B树分割空间的思想，并在添加、删除操作时采用合并、分解结点的方法，保证树的平衡性。因此，R树就是一棵用来存储高维数据的平衡树。相对于B-Tree,R-Tree的优势在于范围查找。

### 6.8 小结

使用索引可以帮助我们从海量的数据中快速定位想要查找的数据，不过索引也存在一些不足，比如占用存储空间、降低数据库写操作的性能等，如果有多个索引还会增加索引选择的时间。当我们使用索时，需要平衡索引的利（提升查询效率）和弊（维护索引所需的代价）

在实际工作中，我们还需要==基于需求和数据本身的分布情况来确定是否使用索引==，尽管索引不是万能的，但数据量大的时候不使用索引是不可想象的，毕竟索引的本质，是帮助我们提升数据检索的效率。

## 7 附录：算法的时间复杂度

同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在 于选择合适算法和改进算法。

![image.png|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/18788b101d1574e594e24d6dad724e3d.png)
