本小节中，我们将继续完善标签导航栏组件，实现能够自由关闭标签页功能。
## 1 成果展示

完成本小节功能代码开发完成后，成果如下：

![](https://img.quanxiaoha.com/quanxiaoha/169458758309550)

## 2 删除逻辑分析

看了上面的最终成果图后，我们来分析一下删除标签页的逻辑，主要有两种情况：

- 1、 用户点击 _删除非选中状态的标签页_；
- 2、用户点击 _删除正处于选中状态的标签页_；

删除了非选中的标签页比较简单，直接删除目标标签页即可。主要是删除正处于选中状态的标签页，就涉及到选中状态的转移，细想一波，逻辑应该是这样：当我们删除了被选中的标签页，如果这个标签页后面还有标签页，则应该选中后面第一个标签页为激活状态；如果后面没有标签页了，则选中前面一个标签页为激活状态。

## 3 开始动手

有了大致的思路后，开始敲代码。

### 3.1 删除事件监听

前面小节的开发中，我们已经为 `<el-tabs>` 组件预留了删除事件的监听方法, 只不过方法块中的代码逻辑还没写：

![](https://img.quanxiaoha.com/quanxiaoha/169458767496664)

### 3.2 标签删除逻辑

接下来，我们就来编写 `removeTab()` 删除标签页的逻辑代码，内容如下：

```js
// 省略...

// 删除 Tab 标签
const removeTab = (path) => {
    let tabs = tabList.value
    // 当前被选中的 tab 标签
    let actTab = activeTab.value

    // 如果要删除的是当前被选中的标签页，则需要判断其被删除后，需要激活哪个 tab 标签页
    if (actTab == path) {
        // 循环 tabList
        tabs.forEach((tab, index) => {
            // 获取被选中的 tab 元素
            if (tab.path == path) {
                // 拿到被选中的标签页下标，如果它后面还有标签页，则取下一个标签页，否则取上一个
                let nextTab = tabs[index + 1] || tabs[index - 1]
                if (nextTab) {
                    actTab = nextTab.path
                }
            }
        })
    }

    // 需要被激活的标签页
    activeTab.value = actTab

    // 过滤掉被删除的标签页, 重新设置回去
    tabList.value = tabList.value.filter((tab) => tab.path != path)

    // 存储到 cookie 中
    setTabList(tabList.value)
	
	// 切换标签页
    tabChange(activeTab.value)
}

// 省略...
```

上述代码中，`path` 入参为标签页的路由地址。在 `removeTab()` 方法中，我们首先处理的是特殊情况，也就是当被删除的标签页为选中状态时：
- 需要找到下一个需要被激活的 `tab` 对象，对 `tabList` 进行循环，找到被删除的标签下标，默认向后移动一位，如果后面没有标签了，则前移一位，找到激活目标后，并记录到 `actTab` 变量中；
然后就是通用逻辑的处理，激活目标标签页，过滤掉被删除的标签页，最后存储新的数据到 `cookie` 中。至此，标签删除功能就搞定啦~

## 5 结语

本小节主要将标签导航栏的删除功能开发完成，内容不多，只涉及一个监听方法，主要需要注意的是其中的逻辑判断。