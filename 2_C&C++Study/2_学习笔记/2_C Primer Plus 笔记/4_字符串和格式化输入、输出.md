
本节内容
- 函数——strlen()
- 关键字——const
- 字符串
- 创建、存储字符串
- 使用strlen()函数获取字符串的长度
- 用C预处理器指令 `#define` 和 ANSCI的const修饰符 定义、使用符号常量
## 1 前导程序

```c
// 演示与用户交互  
#include <stdio.h>  
#include <string.h> //提供strlen()函数的原型  
  
#define DENSITY 62.4 // 人体密度（单位：磅/立方英尺）  
  
int main(){  
    float weight,volume;  
    int size,letters;  
    char name[40];  // name是一个可容纳40个字符的数组  
  
    printf("Hi! What`s your first name?\n");  
    fflush(stdout);  
    scanf("%s",name);  
    printf("%s,what`s your weight in pounds?\n",name);  
    fflush(stdout);  
    scanf("%f",&weight);  
    size = sizeof(name);  
    letters = strlen(name);  
    volume = weight / DENSITY;  
    printf("Well,%s,your volume is %2.2f cubic feet.\n",name,volume);  
    printf("Also,your first name has %d letters,\n",letters);  
    printf("and we have %d bytes to store it.\n",size);  
  
    return 0;  
}
```

**该程序包含一下特性**：
- 用数组（array）存储字符串（character string），且该数组占用内存中连续的40个字节，每个字节存储一个字符值
- 用%s转换说明来处理字符串的输入和输出
	- 注意：name没有用 & ， 而weight使用了&
- 用C预处理器，把字符常量 DENSITY 定义为 62.4
- 用C函数strlen()获取字符串的长度
## 2 字符串简介

定义：字符串（character string）是一个或多个字符的序列，使用双引号括起来标识字符串

### 2.1 char类型数组和null字符

**C语言没有专门用于存储字符串的变量类型，字符串都被存储在char类型的数组中**，数组由连续的存储单元组成，字符串中的字符被存储在相邻的存储单元中，每个单元存储一个字符

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/08/3f0c7004d83a2b3b1c98689dc44446af.png)

- 注意
	- 数组末尾位置的字符 `\0`，这是空字符（null character），用于标记字符串的结束
		- 计算机可以自己处理末尾加空字符
	- 空字符不是0，是非打印字符，ASCII码值是0
	- 所以一个长度为40的数组，实际只能保存39个字符
### 2.2 使用字符串

```c
/* 使用不同类型的字符串 */#include <stdio.h>  
#define PRAISE "You are an extraordinary being."  
  
int main(void){  
    char name[40];  
  
    printf("What`s your name?");  
    fflush(stdout);  
    scanf("%s",name);  
    printf("Hello,%s. %s\n",name,PRAISE);  
  
    return 0;  
}
```

- %s告诉printf()打印一个字符串
- scanf()在读取输入时，会在name的末尾自动加上空字符；也不需要在PRAISE末尾加空字符
- **注意：** scanf()在遇到第1个空白（空格、制表符或换行符）时就不再读取输入

**字符串和字符的区别**
- 字符：`'x'` 是基本类型char
- 字符串：`"x"` 是派生类型（char数组），本质是 `'x' + \0` 两个字符组成
### 2.3 strlen()函数

```c
#include <stdio.h>  
#include <string.h>  
  
#define PRAISE "You are an extraordinary being."  
  
int main(void){  
    char name[40];  
  
    printf("What`s your name?");  
    fflush(stdout);  
    scanf("%s",name);  
    printf("Hello,%s. %s\n",name,PRAISE);  
    printf("Your name of %zd letters occupies %zd memory cells.\n",  
           strlen(name),sizeof name);  
    printf("The phrase of praise has %zd letters,",  
           strlen(PRAISE));  
    printf("and occupies %zd memory cells.\n",sizeof PRAISE);  
  
    return 0;  
}
```

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/08/aeb786ddc0f5f09dc4bfa49402649470.png)

**上面的程序使用了两种方法处理很长的 printf()语句**
- 将printf语句，在参数之间断为两行
- 使用两个printf语句，第一个语句不换行

**strlen()函数用于计算字符串的字符个数，而sizeof函数用于计算字符串所占据的内存空间**

**第3节提到过，sizeof返回的类型添加了%zd转换说明，这对于strlen()同样适用**

**上一节的sizeof使用了圆括号，但本例没有**
- 运算对象是类型时，圆括号必不可少
- 但是对于特定量，圆括号可有可无
- 尽管如此，还是*建议所有情况下都使用圆括号*
## 3 常量和C预处理器

**如何创建符号常量？**
- 方法一：声明一个变量，然后将该变量设置为所需的常量（可能会无意间改变它的值）
```c
float taxrate;
taxrate = 0.015;
```

- 方法二：使用C语言提供的C预处理器
	- 编译时替换（compile-timesubstitution）​：编译时，所有TAXRATE都会被替换为0.015
	- 通常，这样定义的常量也称为明示常量（manifest constant）
```c
#define TAXRATE 0.015

// 通用格式
#define NAME value

// 还可以定义字符和字符串常量
#define BEEP '\a'
#define TEE 'T'
#define ESC '\033'
#define OOPS "Now you have done it!"
```
### 3.1 const限定符

C90标准新增了const关键字，用于限定一个变量为**只读**

```c
const int MONTHS = 12; // MONTHS在程序中不可更改，值为12
```

- MONTHS成为一个只读值
- const用起来比#define更灵活，第12节将讨论与const相关的内容
### 3.2 明示常量

C头文件`limits.h`和`float.h`分别提供了与`整数类型和浮点类型大小限制`相关的详细信息

limits.h头文件包含以下类似的代码：
```c
#define INT_MAX +32767
#define INT_MIN -32768
```

- 这些明示常量代表int类型可表示的最大值和最小值。
- 如果系统使用32位的int，该头文件会为这些明示常量提供不同的值。

如果在程序中包含limits.h头文件，就可编写下面的代码：
```c
printf("Maximum int value on this system = %d\n", INT_MAX);
```

**limits.h中的一些明示常量**

|         明示常量         |            含义            |
| :------------------: | :----------------------: |
|       CHAR_BIT       |        char类型的位数         |
|       CHAR_MAX       |        char类型的最大值        |
|       CHAR_MIN       |        char类型的最小值        |
|      SCHAR_MAX       |    signed char类型的最大值     |
|      SCHAR_MIN       |    signed char类型的最小值     |
|      UCHAR_MIN       |   unsigned char类型的最小值    |
|      UCHAR_MAX       |   unsigned char类型的最大值    |
| SHRT_MAX<br>SHRT_MIN |       short类型的最大值        |
|      USHRT_MAX       |   unsigned short类型的最大值   |
|       INT_MAX        |        int类型的最大值         |
|       INT_MIN        |        int类型的最小值         |
|       UINT_MAX       |    Unsigned int类型的最大值    |
|       LONG_MAX       |        long类型的最大值        |
|       LONG_MIN       |        long类型的最小值        |
|      ULONG_MAX       |      unsigned类型的最大值      |
|      LLONG_MAX       |     long long类型的最大值      |
|      LLONG_MIN       |     long long类型的最小值      |
|      ULLING_MAX      | unsigned long long类型的最大值 |

类似的，float.h头文件也定义一些明示常量
- 如FLT_DIG 和 DBL_DIG，分别float 和 double的有效数字位数

**float.h中的一些明示常量**

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/08/ced2721883a6c4a90c2421961122115a.png)

## 4 printf() 和 scanf()

### 4.1 printf()函数

请求printf()函数打印数据的指令要与待打印数据的类型相匹配。

打印整数时使用%d，打印字符时使用%c。这些符号被称为`转换说明（conversion specification）`​，它们指定了如何把数据转换成可显示的形式。

下表列出了一些转换说明和各自对应的输出类型。

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/08/d92d85c7ea6f1edd912ca88c86e91edb.png)

### 4.2 使用printf()

printf()函数的格式：
```c
printf( 格式字符串, 待打印项1, 待打印项2,...);
```

- 要打印的项可以是变量、常量，甚至是在打印之前先要计算的表达式
- **格式字符串中的转换说明一定要与后面的每个项相匹配**
- **使用两个%符号可以打印出一个%字符出来**
### 4.3 printf()的转换说明修饰符

在%和转换字符之间插入修饰符可修饰基本的转换说明。

**printf()的修饰符**

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/08/04bd92c5d7f37c268e6c84bedc8107d0.png)


- 如果要插入多个字符，其书写顺序应该与上表中列出的顺序相同。
- 不是所有的组合都可行。表中有些字符是C99新增的，如果编译器不支持C99，则可能不支持表中的所有项。
- 注意 **类型可移植性**：
	- sizeof运算符以字节为单位返回类型或值的大小，标准只规定了该值是无符号整数
	- 如果要用printf()函数显示sizeof表达式，根据不同系统，可能使用%u、%lu或%llu
- 注意 **float参数的转换：**
	- 在 K&R C 中，表达式或参数中的float 类型值会被自动转换成 double 类型
	- printf() 函数中所有 float 类型的参数（对未使用显式原型的所有 C 函数都有效）仍自动转换成 double 类型

**printf()中的标记**

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/08/842bb725b8a24e248a9789bf781acaa6.png)

**演示**

```c
/* width.c -- 字段宽度 */
#include <stdio.h>
#define PAGES 959
int main(void)
{
     printf("*%d*\n", PAGES);
     printf("*%2d*\n", PAGES);
     // 输出结果应该是2字段宽度。因为待打印的整数有3位数字，所以字段宽度自动扩大以符合整数的长度
     printf("*%10d*\n", PAGES);
     // 输出结果有10个空格宽度，实际上有7个空格和3位数字
     printf("*%-10d*\n", PAGES);
     // -标记说明打印的数字位于字段的左侧

     return 0;
}
```

![image.png|200](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/08/88590b637c5dc902094e7f67633e33f2.png)

```c
// floats.c -- 一些浮点型修饰符的组合
#include <stdio.h>

int main(void)
{
     const double RENT = 3852.99;  // const变量

     printf("*%f*\n", RENT);
     printf("*%e*\n", RENT);
     printf("*%4.2f*\n", RENT);
     printf("*%3.1f*\n", RENT);
     printf("*%10.3f*\n", RENT);
     printf("*%10.3E*\n", RENT);
     printf("*%+4.2f*\n", RENT);
     printf("*%010.2f*\n", RENT);

     return 0;
}
```

![image.png|100](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/08/54174133e0e0b3073504f5d89653ef9a.png)

```c
/* flags.c -- 演示一些格式标记 */
#include <stdio.h>
int main(void)
{
     printf("%x %X %#x\n", 31, 31, 31);
     printf("**%d**% d**% d**\n", 42, 42, -42);
     // 用空格在输出的正值前面生成前导空格，负值前面不产生前导空格
     printf("**%5d**%5.3d**%05d**%05.3d**\n", 6, 6, 6, 6);
     // 5. 表示除数字本身外，多余的用空格占据
     // .3 表示除数字本身外，多余的用0占据
     // 使用0标记会使得编译器用前导0填充满整个字段宽度
     // 如果0标记和精度一起出现，0标记会被忽略。

     return 0;
}
```

![image.png|300](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/08/6098f55e769f6f003c513cd5f01bd3b3.png)

```c
/* stringf.c -- 字符串格式 */
#include <stdio.h>
#define BLURB "Authentic imitation!"
int main(void)
{
     printf("[%2s]\n", BLURB);
     printf("[%24s]\n", BLURB);
     printf("[%24.5s]\n", BLURB);
     printf("[%-24.5s]\n", BLURB);

     return 0;
}
```
### 4.4 转换说明的意义

#### 4.4.1 定义

转换说明把以二进制格式存储在计算机中的值**转换成一系列字符（字符串）** 以便于显示。

例如，数字76在计算机内部的存储格式是二进制数01001100
- %d 转换说明将其转换为字符7和6，显示为76
- %x 转换说明将其转化为十六进制计数法，显示为4C
- %c 转换说明将其转化为ASCII码表对于的字符L

**转换的本质是翻译！！！**

---

#### 4.4.2 转换不匹配

强调：转换说明应该与待打印值的类型相匹配。例如
- 打印一个int类型的值，可以使用%d、%x或%o
- 打印double类型的值时，可使用%f、%e或%g
- 区别在于它们分别表示一个值的形式不同

下面这个程序演示了转换说明与待打印值的类型不匹配的情况：
```c
#include <stdio.h>  
#define PAGES 336  
#define WORDS 65618  
  
int main(void) {  
    short num = PAGES;  
    short mnum = -PAGES;  
  
    printf("num as short and unsigned short: %hd %hu\n",num,num);  
    printf("-num as short and unsigned short: %hd %hu\n",mnum,mnum);  
    printf("num as short and char: %d %c\n",num,num);  
    printf("WORDS as int,short,and char: %d %hd %c\n",WORDS,WORDS,WORDS);  
  
    return 0;  
}
```

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/08/512b2290638f97c13d691dbf9b6f621a.png)

可以看到
- **第二行**：mnum变量对应的转换说明%u（无符号）输出的结果却为65200，并非期望的336。这是由于有符号short类型的值在我们的参考系统中的表示方式所致。
	- 首先，short int的大小是2字节；
	- 其次，系统使用二进制补码来表示有符号整数
	- 这种方法，数字0～32767代表它们本身，而数字32768～65535则表示负数。其中，65535表示-1，65534表示-2，以此类推。因此，-336表示为65200（即，65536-336）​。所以被解释成有符号int时，65200代表-336；而被解释成无符号int时，65200则代表65200。

- **第三行**：把一个大于255的值转换为字符时，由于short是2字节，而char是1字节，所以会发生截断，即只看short后1字节的内容
  ![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/08/86333458d2205e753ef26d299a01254e.png)
- **第四行**：首先，WORDS本身会使用4字节保存，使用%hd的时候只使用了最后2字节，%c就只使用1字节

下面这个程序演示 *混淆整型和浮点型* 的情况，结果更奇怪！
```c
/* floatcnv.c -- 不匹配的浮点型转换 */
#include <stdio.h>
int main(void)
{
     float n1 = 3.0;
     double n2 = 3.0;
     long n3 = 2000000000;
     long n4 = 1234567890;

     printf("%.1e %.1e %.1e %.1e\n", n1, n2, n3, n4);
     printf("%ld %ld\n", n3, n4);
     printf("%ld %ld %ld %ld\n", n1, n2, n3, n4);

     return 0;
}
```

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/08/226b0fcccde8af8d1d352e1190009720.png)

- %e转换说明让printf()函数认为待打印的值是double类型（本系统中double为8字节）​，对于n3变量（long）是4个字节，还会查看前4个字节，最后将这8字节解释为浮点数，结果是毫无意义的值
- 同样的，float类型的值作为printf参数时，会被转换为double类型，即4字节变位8字节
- 反之，用%ld转换说明打印浮点数会失败

---

**参数传递**


### 4.5 使用scanf()

### 4.6 printf和scanf的 * 修饰符

### 4.7 printf的用法提示
## 5 关键概念

## 6 本节小结