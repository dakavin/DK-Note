
## 1 格式控制符

| 格式控制符                      | 说明                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| %c                              | 输出一个单一的字符                                           |
| %hd、%d、%ld                    | 以十进制、有符号的形式输出 short、int、long 类型的整数       |
| %hu、%u、%lu                    | 以十进制、无符号的形式输出 short、int、long 类型的整数       |
| %ho、%o、%lo                    | 以八进制、不带前缀、无符号的形式输出 short、int、long 类型的整数 |
| %#ho、%#o、%#lo                 | 以八进制、带前缀、无符号的形式输出 short、int、long 类型的整数 |
| %hx、%x、%lx %hX、%X、%lX       | 以十六进制、不带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字也小写；如果 X 大写，那么输出的十六进制数字也大写。 |
| %#hx、%#x、%#lx %#hX、%#X、%#lX | 以十六进制、带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字和前缀都小写；如果 X 大写，那么输出的十六进制数字和前缀都大写。 |
| %f、%lf                         | 以十进制的形式输出 float、double 类型的小数                  |
| %e、%le %E、%lE                 | 以指数的形式输出 float、double 类型的小数。如果 e 小写，那么输出结果中的 e 也小写；如果 E 大写，那么输出结果中的 E 也大写。 |
| %g、%lg %G、%lG                 | 以十进制和指数中较短的形式输出 float、double 类型的小数，并且小数部分的最后不会添加多余的 0。如果 g 小写，那么当以指数形式输出时 e 也小写；如果 G 大写，那么当以指数形式输出时 E 也大写。 |
| %s                              | 输出一个字符串                                               |

## 2 数组

### 2.1 定义的格式及其变形

#### 2.1.1 一维数组

```c
// 格式1：数组名[下标]
int arr[10];
```

注意
- 数组脚标越界问题，C语言编译器不一定会报错角标越界

```c
// 格式2：在声明时，使用大括号，同时对每一个成员赋值
int arr[3] = {10,20,30}; 

// 根据大括号里面的值的数量，自动确定数组的长度
int arr[] = {10,20,30};

// 大括号里面的值，少于数组的成员数量，那么未赋值的成员自动初始化为 0 
int arr[5] = {10, 20, 30};  
	// 等同于  
int arr[5] = {10,20,30, 0, 0};

// 将整个数组的每一个成员都设置为零 ！
int a[100] = {0};
```

```c
// 格式3：可以指定为哪些位置的成员赋值
int arr[15] = {[2] = 10, [5] = 20, [14] = 30};  //非角标2、5、14的位置自动赋值为0

// 指定位置的赋值与顺序赋值，可以结合使用
int arr[15] = {1, [5] = 10, 11, [10] = 20, 21}; //角标0、5、6、10、11的位置被赋值

// 省略成员数量时，如果同时采用指定位置的赋值，数组长度 = 指定最大位置 + 1
int arr[] = {[2] = 6, [9] = 12};  // 此时数组的长度是10
```

#### 2.1.2 二维数组

```c
//格式1：
int a[3][4]; //二维数组，3行4列

//格式2：在声明的同时，一次性对所有成员赋值
int a[3][4] = {{1,2,3,4},  
               {5,6,7,8},  
               {9,10,11,12}};

//格式3：仅为指定的位置进行初始化赋值，未赋值的成员会自动设置为“零”值  
int a[2][2] = {[0][0] = 1, [1][1] = 2};  //其他位置就自动设为 0 


//格式4：单层大括号赋值，值按照线性匹配
int a[2][3] = {1, 2, 3, 4, 5, 6};    //会自动匹配到各行各列
//可以写为：  
int a[][3] = {1, 2, 3, 4, 5, 6};   
//也可以写为：  
int a[][3] = {{1, 2, 3},{4, 5, 6}}; //行数自然判定为2
```

![image.png|500|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/11/0c99003f86c829f5f05284746f903623.png)

### 2.2 长度

```c
// 数组的字节长度
int arr[10];
printf("数组的字节长度为：%zd\n",sizeof(arr)); //40

// 数组的长度，一般表示数组有多少个元素
//数组中元素的个数：  
int arrLen = sizeof(arr) / sizeof(arr[0]);
```

注意
-  sizeof 返回值的数据类型是 `size_t` ，所以 sizeof(a) / sizeof(a[0]) 的数据类型也是size_t 。在 printf() 里面的占位符，要用 `%zd` 或 `%zu`

### 2.3 内存分析

#### 2.3.1 一维数组

```c
int a[5] = {1,2,3,4,5};
```

![image.png|500|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/11/219d801a1c17f03338652131a9360c1e.png)

- **数组的变量名，记录的是数组第一个元素的地址（首地址）**

#### 2.3.2 二维数组

在`内存`中，各元素是连续存放的，不是二维的，是`线性`的。

C语言中，二维数组中元素排列的顺序是`按行存放`的。即：先顺序存放第一行的元素，再存放第二行的元素

![image.png|500|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/11/cc351e5a5bd877d06cd2b076d191d038.png)
### 2.4 变长数组

```c
// 方式1：
int n = 10;  
int arr[n];
int arr1[n + 1];  // 依次类推

// 方式2：使用动态内存分配  malloc()函数
//   分配
int length = 5;  
int *arr = (int *)malloc(length * sizeof(int));
//   释放
free(arr);

// 二维数组
// 初始化外层数组
    int **array = (int **) malloc(sizeof(int *) * rows);//先创建第一维  
    for (int i = 0; i < rows; i++) {  
        //在内层循环中动态创建第二维，初始化内层数组  
        array[i] = (int *) malloc(sizeof(int) * cols);  
    } 
```

### 2.5 数组的应用

应用一：求特征值，平均值、最大值、最小值、总和等

应用二：数组的复制
- 使用for循环，复制一些简单的数组
- 使用memcpy()函数
	- 3个参数依次为：`目标数组`、`源数组`以及`要复制的字节数`。
```c
// 使用 memcpy 函数复制数组 a 到数组 b  
memcpy(b, a, LENGTH * sizeof(int));  
```

应用三：数组元素的翻转

应用四：字符型数组
- C语言没有专门用于存储字符串的变量类型，字符串都被存储在char类型的数组中
- 在字符串结尾，C 语言会自动添加一个`'\0'`的转义字符作为字符串结束的标志
- `字符数组的长度可以让编译器自动计算`，声明时可以省略字符数组的长度
- 使用 `strlen()`函数，获取的是字符串的实际长度，不考虑`'\0'`
### 2.6 注意事项

**C 语言规定，数组变量一旦声明，数组名指向的地址就不可更改。** 因为声明数组时，编译器会自动为数组分配内存地址，这个地址与数组名是绑定的，不可更改。

```c
// 错误1
int nums[5];  
nums = {22, 37, 3490, 18, 95}; // 使用大括号赋值时，必须在数组声明时赋值，否则编译时会报错。

// 错误2
int nums[5] = {1, 2, 3, 4, 5};  
nums = {6, 7, 8, 9, 10}; // 报错

// 错误3
int ints[100];  
ints = NULL; //报错

// 错误4
int a[5] = {1, 2, 3, 4, 5};  
// 写法一  
int b[5] = a; // 报错  
// 写法二  
int b[5];  
b = a; // 报错
```

## 3 指针

### 3.1 理解

`指针`：变量所使用的内存空间的地址，即变量的地址

`指针变量`：**专门用来存放另一变量在内存空间的地址 (即指针)** 的一个变量，则它称为“指针变量”
- 可以通过访问指针变量达到访问内存中另一个变量数据的目的
- **有时为了阐述方便，将指针变量直接说成指针**

### 3.2 定义

```c
// 一般格式：
数据类型 *指针变量名 [=初始地址值];

// 举例
int *p;
// 变形
int* p;  
int * p;
```

- 字符 `*` 用于告知系统这里定义的是一个指针变量，通常跟在类型关键字的后面

### 3.3 运算

**&：取值运算符**：用于获取变量的地址，然后给指针赋值

**`*`:取值运算符** ：与 & 的作用相反，根据给定的内存地址取出改地址对应的变量值，`搭配指针使用`   

**指针的加减运算**
- 整数类型，即按照类型所占字节，向前向后移动
- 数组类型，一般指针指向首元素，通过指针+1，实现向后遍历元素的效果

**指针也可以自增、自减运算**
- 效果和加减运算，加减1是一样的

**指针 - 指针**
- 返回他们之间的距离，即相隔多少个数据单位
- 返回值属于 `ptrdiff_t` 类型，定义在头文件 `stddef.h`

**指针间的比较**
- 比较的是指针各自的内存地址大小
- 返回值是整数 1 （true）或 0 （false）

### 3.4 野指针

**定义**
- 指针定义时未初始化（值是随机的）
	- 后续的一系列操作（赋值，修改指向等）都是错误的
- 指针越界
- 指针指向已释放的空间（如通过函数获取的指针，但是指针指向的变量是局部变量）

**避免**
- 定义指针的时候初始化，或者`赋NULL值`
- 小心指针越界
- 避免返回局部变量的地址
- 指针指向空间释放，及时将指针置NULL

### 3.5 二级（多重）指针

**二级指针即一个指针变量的值是另外一个指针变量的地址**。通俗来说，**二级指针就是指向指针的指针**

**格式：**
```c
数据类型 **指针名;

int a = 10;  
int *pa = &a;  //pa是一级指针  
int **ppa = &pa; //ppa是二级指针，类型为int **
```

- 注意 ppa的类型是`int **` 类型

### 3.6 const类型的指针

这种指针比较特殊：
```c
#include <stdio.h>

int main(){
    int a = 9, b = 10;
    const int * p = &a;
    *p = 20;   //这里直接报错，因为被const标记的指针，所指地址上的值不允许发生修改
  	p = &b;   //但是指针指向的地址是可以发生改变的
}
```

我们再来看另一种情况：
```c
#include <stdio.h>

int main(){
    int a = 9, b = 10;
    int * const p = &a;   //const关键字被放在了类型后面
    *p = 20;   //允许修改所指地址上的值
    p = &b;   //但是不允许修改指针存储的地址值，其实就是反过来了。
}
```

当然也可以双管齐下：
```c
#include <stdio.h>

int main(){
    int a = 9, b = 10;
    const int * const p = &a;
    *p = 20;   //两个都直接报错，都不让改了
    p = &b;
}
```

### 3.7 注意事项

1、指针只能存放地址
2、C语言中的地址是 **带类型的地址**，所以指针只能指向同类型的变量
3、指针没赋值的时候，系统会分配一个未知的地址

## 4 指针和数组

### 4.1 定义

```c
// 一维数组
int a[10]={2,4,6,8,10,12,14,16,18,20};   
int *p; //定义p为指向整型变量的指针变量 

// 指针指向数组的方式
p = &a[0];
int *p = &a[0];
int *p = a;  // 常用
```

### 4.2 应用

**使用指针访问数组元素**

```c
#include <stdio.h>  
​  
#define N 5  
​  
int main() {  
    int a[N];  
    int *p = a;  
    printf("请输入%d个整数：\n", N);  
    for (int i = 0; i < N; i++)  
        scanf("%d", p + i);  
​  
    for (p = a; p < (a + N); p++)  // 方式一：这里p++了
        printf("%d ", *p);  

    for (int i = 0; i < N; i++)   // 方式二：
        printf("%d ", *(p + i)); 
​  
    printf("\n");  
    return 0;  
}
```

**指针可以带下标使用**

### 4.3 二维数组

进而：
- p+j 将指向 `a[0]` 数组中的元素 `a[0][j]`。
- 对于二维数组`a[M][N]`来讲，由于 `a[0]、a[1]、... 、a[M-1]`等各行数组在内存中是依次连续存储，则对于 a 数组中的任一元素 `a[i][j]`：
    - 地址表示：`p+i*N+j`
    - 值表示：`*(p+i*N+j)`、`p[i*N+j]`
      ![image.png|500|500|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/11/cc351e5a5bd877d06cd2b076d191d038.png)

### 4.4 数组指针 VS 指针数组

数组指针：前面外面说的都是数组指针，即指向数组的指针

指针数组：用于存放指针的数组

**指针数组的格式**

```c
数据类型 *指针数组名[大小];

int *arr[5];
```

### 4.5 字符数组 vs 字符指针变量

一个字符串，可以使用`一维字符数组`表示，也可以使用`字符指针`来表示。
- 字符数组由若干个元素组成，每个元素放一个字符
- 字符指针变量中存放的是地址（字符串/字符数组的首地址），绝不是将字符串放到字符指针变量中

```c
char str[] = "hello tom";  //使用字符数组  
​  
char * pStr = "hello tom";  //使用字符指针，最后一个字符还是 `\0`
```

**字符数组赋值后是不能修改的**
**字符指针是可以修改的，本质上是指向的地址发生变化**


### 4.6 字符串数组

如果一个数组的每个成员都是一个字符串，则构成了字符串数组。字符串数组有两种表示方式：
- `二维字符数组` 
- `字符指针数组`

方式1：使用二维字符数组

```c
char fruit[][7]={"Apple","Orange","Grape","Pear","Peach"};
```

方式2：使用字符指针数组

```c
char* weekdays[7] = {  //7也可以省略  
  "Monday",  
  "Tuesday",  
  "Wednesday",  
  "Thursday",  
  "Friday",  
  "Saturday",  
  "Sunday"  
};
```


### 4.7 指向固定长度数组的指针变量

定义格式：

```c
(*标识符)[一维数组元素个数];
```

例如：定义一个指针变量 p，它指向包含有 4 个元素的一维数组。

```c
int (*p)[4]; // 这表示p指针的类型是 包含4个整型元素的一维数组

int *p[4]; // 注意这个是指针数组！
```

> 说明：p先和`*`结合，说明p是一个指针变量，指向一个大小为4的整型数组。
> 
> 注意：此时定义的是一个指针变量，并非是一个指针数组。(`*p` 必须放在括弧内，否则就变成了定义指针数组。)

由于 p 是指向有 4 个整型元素的一维数组的指针变量，因此，p+1 是将地址值加上 `4*4`，即指向下一个一维数组。

举例：

```c
int a[3][4] = {{1, 2,  3,  4},  
               {5, 6,  7,  8},  
               {9, 10, 11, 12}};  
int (*q)[4];  
q = a;
```

则：

`q` 为二维数组第 0 行首地址，与 `a` 相同；

`q+1` 为二维数组第 1 行首地址，与 `a+1`相同；

`q+2` 为二维数组第 2 行首地址，与 `a+2`相同；

`*(q+i)`为二维数组第 i 行第 0 列元素的地址，与`*(a+i)`相同；

`*(q+i)+j`为二维数组第 i 行第 j 列元素的地址，与`*(a+i)+j` 相同；

`*(*(q+i)+j)`为二维数组第 i 行第 j 列元素值，与`*(*(a+i)+j)`相同，即 `a[i][j]`。

## 5 函数

### 5.1 值传递、地址传递和引用传递

- 值传递：传入变量副本，不会改变原值
- 地址传递：传入指针，可通过解引用直接修改原值，需自行管理指针安全
- 引用传递：传入对象引用（别名），语法上简单、可靠，与原值同步变化，多见于C++
  
### 5.2 main()函数的传参

main()的声明中可以带有两个参数，格式如下。

```c
int main(int argc, char *argv[]) {  
   //函数体  
} 
```

其中，形参argc，全称是argument count，表示传给程序的参数个数，其值至少是1；而argv，全称是argument value，argv[]则是指向字符串的指针数组。

这种方式可以通过命令行的方式，接收指定的字符串传给参数argv。举例：

```c
#include <stdio.h>  
​  
int main(int argc, char *argv[]) {  
    printf("argc = %d\n",argc);  
    //函数体  
    for(int i = 0;i < argc;i++){  
        printf("%s\n",argv[i]);  
    }  
      
    return 0;  
}
```

命令行执行参考：
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/12/196991f58c0996ee005c109d3fc1d83a.png)


### 5.3 exit()函数

exit() 函数用来终止整个程序的运行。一旦执行到该函数，程序就会立即结束。

该函数的原型定义在头文件 `stdlib.h` 里面

在`stdlib.h` 里面
- EXIT_SUCCESS （相当于 0）表示程序运行成功，正常结束；
- EXIT_FAILURE （相当于 1）表示程序异常中止。

```c
// 程序运行成功
// 等同于 exit(0);
exit(EXIT_SUCCESS);

// 程序异常中止
// 等同于 exit(1);
exit(EXIT_FAILURE);
```

在main()函数结束时也会隐式地调用exit()函数，exit() 等价于使用 return 语句。其它函数使用 exit() ，就是终止整个程序的运行，没有其它作用。

**C 语言还提供了一个 atexit() 函数，用来登记 exit() 执行时额外执行的函数，用来做一些退出程序时的收尾工作**
```c
int atexit(void (*func)(void)); //参数是一个函数指针
```

### 5.4 指针函数

定义：
```c
返回值类型 *函数名(形参列表) {
	函数体
｝
```

注意点：**返回的指针不能是局部变量的指针，局部变量会随着函数的结束而失效**
- 可以使用static修饰局部变量，变量会在静态数据区
- 也可以使用malloc给局部变量分配内存，变量会在堆空间中

### 5.5 函数指针

定义：
```c
返回值类型 (*指针变量名)(参数列表);
```

**C 语言规定，函数名本身就是指向函数代码的指针，通过函数名就能获取函数地址。也就是说， print 和 &print 是一回事**

## 6 变量

![image.png|700](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/12/891a0dbc2170cb1f7a89ec951c39c0ea.png)

## 7 结构体

### 7.1 声明并调用

```c
// 一般格式
struct 结构体名{   
    数据类型1 成员名1;   //分号结尾  
    数据类型2 成员名2;   
    ……  
    数据类型n 成员名n;  
}; //注意最后有一个分号

// 格式1
struct 结构体类型名称 结构体变量名;
结构体变量名.成员名 [= 常量或变量值]

// 格式2（顺序一致，缺的属性自动初始化）
struct 结构体名 结构体变量={初始化数据};

// 格式3（顺序一致，缺的属性自动初始化）
struct 结构体名 结构体变量={.成员1=xxx,.成员2=yyy,...};

// 格式4
struct 结构体名 {  
    成员列表  
} 变量名列表;

// 格式5：不指定类型名而直接定义结构体类型变量
struct {  
    成员列表;  
} 变量名列表;

// 格式6：开发中常用，使用typedef命令，为struct指定别名
typedef struct cell_phone {  
    int phone_no;              //电话号码  
    double minutes_of_charge;  //每分钟费用  
} Phone;  
​  
Phone p = {13012341234, 5};

// cell_phone可以省略
```

### 7.2 同类型结构体赋值

1、值传递，而不是地址传递，即复制一份结构体变量在新的内存空间
2、如果内部变量是指针，传递的是地址值，修改会发生对于的变化
- 例如：字符数组不会发生变化，但是字符指针会！！！
