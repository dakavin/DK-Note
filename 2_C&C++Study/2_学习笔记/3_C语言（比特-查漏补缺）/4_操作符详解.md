
## 1 操作符分类

看本文目录即可
## 2 算术

```c
+ - * / %
```

1. 除了% 操作符之外，其他的几个操作符可以作用于整数和浮点数。
2. 对于/ 操作符如果两个操作数都为整数，执行整数除法。而只要有浮点数执行的就是浮点数除法。
3. % 操作符的两个操作数必须为整数。返回的是整除之后的余数。

## 3 移位

**移位操作符的操作数只能是整数**
### 3.1 左移

**左变抛弃，右边补0**

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/04/c43befdbd7fd534ab3881cdcb38ce8b4.png)
### 3.2 右移

**逻辑移位：左边补0，右边丢弃**
**算术移位：左边用该值的符号位填充，右边丢弃**

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/04/1caf021276cc94734ae8cfac0fc07169.png)

`对于移位运算符，不要移动负数位，这个是标准未定义的`
```c
int num = 10;
num >> -1; // error
```
## 4 位

```c
& //按位与
| //按位或
^ //按位异或
```

**注：他们的操作数必须是整数**

例1：不创建临时变量，实现两个数的交换
```c
int a = 10;
int b = 20;
a = a ^ b;
b = a ^ b;
a = a ^ b;
```

例2：求一个整数存储在内存中的二进制中1的个数
```c
int num = 8;  
int count = 0;  
if(num == 0) return 0
while(num){  
    if(num & 0x1){  
        count++;  
    }  
    num >>= 1;  
}
return num;
```
## 5 赋值

```c
=

// 复合赋值
+= -= *= /= %= >>= <<= &= |= ^= 
```
## 6 单目

### 6.1 单目操作符介绍

```c
! 逻辑反操作
- 负值
+ 正值
& 取地址
sizeof 操作数的类型长度（以字节为单位）
~ 对一个数的二进制按位取反
-- 前置、后置--
++ 前置、后置++
* 间接访问操作符(解引用操作符)
(类型) 强制类型转换
```
### 6.2 sizeof 和 数组

```c
void test1(int arr[])  
{  
    printf("%d\n", sizeof(arr));//(2)  首元素的大小
}  
void test2(char ch[])  
{  
    printf("%d\n", sizeof(ch));//(4)  首元素的大小
}  
int main()  
{  
    int arr[10] = {0};  
    char ch[10] = {0};  
    printf("%d\n", sizeof(arr));//(1)  数组的大小
    printf("%d\n", sizeof(ch));//(3)  数组的大小
    test1(arr);  
    test2(ch);  
    return 0;  
}
```
## 7 关系

```c
>
>=
<
<=
!= 用于测试“不相等”
== 用于测试“相等”
```

注意：== 和= 不小心写错，导致的错误
## 8 逻辑

```c
&& 逻辑与
|| 逻辑或
```

```c
int main()  
{  
    int i = 0,a=0,b=2,c =3,d=4;  
    //i = a++ && ++b && d++;  // a=0后面不会走下去 1,2,3,4
    i = a++||++b||d++;        // a=0走到b，b为真，不走到d 
    // 故1,3,3,4
    printf("a = %d\n b = %d\n c = %d\nd = %d\n", a, b, c, d);  
    return 0;  
}
```
## 9 条件

```c
exp1 ? exp2 : exp3
```
## 10 逗号表达式📕

```c
exp1 , exp2 , exp3 ,..., expN
```

- 从左向右依次执行
- 整个表达式的结果是最后一个表达式的结果

```c
int a = 1;  
int b = 2;  
int c = (a>b, a=b+10, a, b=a+1);//  
printf("c = %d\n",  c);

// 即
//...
a>b;
a=b+10;
a;
b=a+1;
c=b; // 13
```

## 11 下标引用、函数调用和结构成员

- []下标引用操作符：操作数（一个数组名 + 一个索引值）
- ()函数调用操作符：接受一个或者多个操作数：第一个操作数是函数名，剩余的操作数就是传递给函数的参数
- 访问一个结构的成员
	- `.` 结构体.成员名
	- `->` 结构体指针->成员名

## 12 表达式求值

表达式求值的顺序一部分是由**操作符的优先级和结合性决定**

有些表达式的操作数在求值的过程中可能需要**转换为其他类型**

### 12.1 隐式类型转换📕

- char和short类型进行运算时，会先被转换为int类型
	- 因为CPU内的整型运算器（ALU）操作数的字节长度一般是int的字节长度
	- 加法运算完成后，**结果将被截断**，再存储

- **整型提升：负数高位补1，正数高位补0，无符号整形高位补0**

```c
int main()  
{  
    char a = 0xb6;  
    short b = 0xb600;  
    int c = 0xb6000000;  
    if(a==0xb6)  // 发生整型提升，变为负数，错
        printf("a");  
    if(b==0xb600)  // 发生整型提升，变为负数，错
        printf("b");  
    if(c==0xb6000000)  // 直接比较，对
        printf("c");  
    return 0;  
}
```

a和b，再发生比较时，会先提升为int，因为本身高位为1，所以提升的时候，被解释为负数 和 0xb6 0xb600这个是int
- a ---> 0xffffffb6 != 0x000000b6  , b同理

```c
int main()
{
	char c = 1;
	printf("%u\n", sizeof(c)); // 1
	// 发生运算，会提升类型
	printf("%u\n", sizeof(+c)); // 4
	printf("%u\n", sizeof(-c)); // 4
	return 0;
}
```

### 12.2 算术转换

某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另外一个操作数的类型后执行运算

```c
short、char ---> int  ---> unsigned int ---> long
---> unsigned long ---> float  ---> double
---> double long

// 算术转换要合理，否则会丢失精度
float f = 3.14;
int num = f;
```

### 12.3 操作符的属性

- 操作符优先级
- 操作符的结合性
- 是否控制求值顺序

**函数的调用先后顺序无法通过操作符的优先级确定**