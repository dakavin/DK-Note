## 1 什么是串口？作用？

串行口，简称为串口，什么是串口？它的作用是什么？

两个人交流，一般通过在说话在空气中产生的声波传输，两台机器交流，我们可以模拟摩斯密码一样，其中一台机器通过IO发送对应频率高低电平的脉冲，另一台机器接收进行解析，但这种操作IO的方式需要我们考虑的问题很多，多快的频率，谁发谁收，丢失了一个脉冲怎么办等等，于是后面就有了规范这些交流的协议，简称为通讯协议，基于通讯方式的不同，也有了**串行通讯**和**并行通讯**两种通讯方式

串口是一种应用十分广泛的通讯接口，串口成本低、容易使用、通信线路简单，可实现两个设备的互相通信

**串口通信**
- 串行通信是指使用一条数据线，将数据一位一位地依次传输，每一位数据占据一个固定的时间长度
- 只需要少数几条线就可以在系统间交换信息，特别适用于计算机与计算机，计算机与外设之间的远距离通信，`先传输低位再传输高位`。如下图所示：
  ![whiteboard_exported_image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/c2f7da877fedac704dbd434702eada5b.png)
**并行通信**
- 并行通信通常是将数据字节的各位用多条数据线同时进行传送，通常是8位，16位，32位等数据一起传输。如下图所示：
  ![whiteboard_exported_image (1).png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/441ea7bc362dced7535cd1a67c9f39af.png)
**对比：**
- 串行通信的特点：`传输线少（需要的IO口少），长距离传送时成本低`，且可以利用电话网等现成的设备，但数据的传送控制比并行通信复杂。
- 并行通信的特点：`控制简单，传输速度快`；由于传输线较多，长距离传送时成本高且接收方的各位同时接受存在困难，抗干扰能力差。

**现阶段绝大部分的通讯口都使用串口**
## 2 串口的参数

### 2.1 通信方式

**串行通信的基本方式**
- 单工通信：数据只能单方向传输
- 半双工通信：通信双方交替进行双向数据传输，但两个方向的传输不能同时进行
- **全双工通信**：通信双方可**同时进行数据收发**的工作方式。51单片机的串行口是**全双工**传输方式

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/2f5842b26d56fafb548a29f078b77379.png)

### 2.2 电平标准

**串口电平标准**：是传输线缆中人为规定的电压与数据的对应关系，串口常用的电平标准有如下三种：
• `TTL电平`（transistor transistor logic ）： +3V~+5V 表示 1 ， 0V 表示 0
• `RS232 电平`： -3~-15V 表示 1 ， +3~+15V 表示 0
• `RS485 电平`：两线压差 +2~+6V 表示 1 ， -2~-6V 表示 0 （差分信号）

### 2.3 数据结构

一个完整的串行数据，也就是一个数据帧（Data frame），包**括起始位**、**数据位**、**停止位**、**奇偶校验位**。数据位前后即帧头和帧尾，包含一些必要的控制信息。其中，MSB（Most Significant Bit）是指低地址存放最高有效字节，LSB（Least Significant Bit）则是低地址存放最低有效字节
  ![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/133269c6c46b5584a103684e50ff7c01.png)

- **起始位**：由高电平置位低电平
- **数据位**：
	- 20 - > 0x14 -> 0b0001 0100
	- MSB（从最高位开始发送）:  （先发）0->0->0->1->0->1->0->0
	- LSB （从最低位开始发送） : （先发）0->0->1->0->1->0->0->0  **51常用**
### 2.4 波特率

通俗解析就是，波特率越高，传输速度越快。

常见的串口典型的“波特率”值是 300/1200/2400/9600/19200/38400/115200 /230400等。

串口通信速率，单位时间内传输二进制的位数（例波特率为9600，指1s内传输9600位，则传输一位需要1/9600=104.17us）
- 假设1个完整的串行数据是10bit
- 那么发送这个完整的数据，需要的时间为1041.7us 约为 1ms


**发送端和接收端的波特率要求是相等的**
### 2.5 校验位

1. `N 无校验`：不加校验位，可以少传输一位数据

2. `O 奇校验`：a要传输的数据中（不包含校验位）有奇数个‘1’ 则校验位为‘0’， 反之为‘1’
- 例： 数据‘1111 000’ 偶数个‘1’ 所以添加校验位为‘1’ 整体为‘1111 0000 1’

1. `E 偶校验`：要传输的数据中（不包含校验位）有偶数个‘1’ 则校验位为‘0’， 反之为‘1’

2. `M`（Mark 标记、符合）检验位固定为1
  
3. `S`（Space 空间、空地）校验位固定为0
### 2.6 停止位

停止位，停止位是一帧数据结束的标志，可以是1bit、1.5bit或者2bit逻辑“1” **高电平**

如果没有停止位，接收设备就无法知道何时一个数据包结束，从而无法正确地处理接收到的数据。
### 2.7 空闲位

空闲位不算是串口报文内的数据, 它是发送完一组报文后，总线会自动将电平拉高，产生1bit 逻辑“1”的**空闲位**
### 2.8 串口调试工具

https://alithon.com/downloads

主要使用CH340驱动软件和逻辑分析仪驱动软件，参考文章[_使用工具的软件驱动](_使用工具的软件驱动.md)

USB 转串口助手：
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/d9dbe062dfd078de6bc0c688f660e71d.png)

逻辑分析仪：
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/b700ca2720440f98ad3168b355a87f20.png)

## 3 51的串口使用

### 3.1 硬件接线

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/22196670c5a1bfcc0eff8b605fc8e7ae.png)

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/9510181cfff5ca71579f27d69176045a.png)

![whiteboard_exported_image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/2a628176a06fd86cbf20eaec70c5d16c.png)

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/bd76fe636a8c5c5455de40e7a6d01337.png)
 
### 3.2 串口相关寄存器

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/616a0e3682dee8f130d3d0b63fa7b685.png)


一般常用的是SCON、SBUF、PCOM、IE，如果需要配置不同中断优先级的则需要配置IPH IP，SADEN、SADDR用于多机通讯，比较少用
## 4 模式选择

STC89C51RC/RD+系列单片机内部集成有一个功能很强的全双工串行通信口，与传统8051单片机的串口完全兼容。设有 **2个互相独立的接收、发送缓冲器，可以同时发送和接受数据。**

发送缓冲器只能写入不能读出，接收缓冲器只能读出而不能写入，因而两个缓冲器可以共用一个地址码（`99H`）。 **两个缓冲器统称串口通信特殊功能寄存器SBUF**

串口通信有4钟工作方式，其中两种方式的波特率是可变的，另两种是固定的，以供不同应用场合选用。波特率由内部定时器/计数器产生，用软件设置不同的波特率和选择不同的工作方式。主机可通过查询或中断方式对接收/发送进行程序管理，使用十分灵活

**STC89C51RC/RD+系列单片机串行口对应的硬件部分对应的管脚是 P3.0/RxD 和 P3.1/TxD**

STC89C52 有 1 个 UART， 有四种工作模式：
- 模式0：同步移位寄存器，主要用于扩展并行输入或输出口
- **模式1：8位UART，波特率可变（常用）**
- 模式2：9为UART，波特率固定（多出的1位为校验位）
- 模式3：9位UART，波特率可变（多出的1位为校验位）

这里简单说明下常用和其他的区别，常用的表示使用串口功能时，一般使用模式1就能满足所有需求，平常工作中，其他模式基本上不常用，所以学习时把常用的学会，原理搞懂就可以了，后面根据项目需求有目的性学习，而不是把所有细节都学一遍
### 4.1 模式选择寄存器

![image.png|500|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/02/bb002300ac3cee1f9294bb00d9369bf6.png)

![image.png|500|500|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/02/44f315dcb505db256e7288ee21358e29.png)

```c
SM0 = 0;
SM1 = 1;
// 或者
SCON = 0x40; // 0100 0000 串口工作模式1
```

### 4.2 模式1说明

当软件设置SCON的SM0、SM1为`“01”`时，串口通信则以模式1工作。此模式为8位UART格式，一帧信息为10位：
- 1位起始位
- 8位数据位（低位在先）
- 1位停止位

波特率可变，即可根据需要进行设置。TxD（TxD/P3.1）为发送消息，RxD（RxD/P3.0）为接收端接收信息，串行口为全双工接受/发送串行口
## 5 发送 数据相关寄存器配置

**发送流程**
- 模式1的发送过程：串口通信模式发送时，数据由串口发送端TxD输出。当主机执行一条写“SBUF”的指令就启动串行通信的发送，写“SBUF”信号还把“1”装入发送移位寄存器的第9位，并通知TX控制单元开始发送。发送各位的定时是由16分频计数器同步

- 移位寄存器将数据不断右移送TxD端口发送，在数据的左边不断移入“0”做补充。当数据的最高位移到移位寄存器的输出位置，紧跟其后的是第9位“1”，在它的左边各位全为“0”，这个状态条件，使TX控制单元作最后一次移位输出，然后使允许发送信号“SEND”失效，完成一帧信息的发送，并置位中断请求位TI，即TI=1，向主机请求中断处理。

**SBUF 串口数据缓冲寄存器：可写入需要发送的数据**
- STC89xx系列单片机的串行口缓冲寄存器（SBUF）的地址是99H，实际是2个缓冲器，写SBUF的操作完成待发送数据的加载，读SBUF的操作可获得已接收到的数据。两个操作分别对应两个不同的寄存器，1个是只写寄存器，1个是只读寄存器
  ![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/92cec8cb8b3b4973cf9bba235c09df84.png)
  ![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/b227dd1e8f5eca3dd8b2b63849c9dc94.png)
### 5.1 时钟源选择，影响波特率

**Timer1 Overflow：定时器1的中断溢出作为时钟源，用于设置串口通讯的波特率**

**方式1：查表法：**
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/1aa79c965ac22d96d768a5880512ca38.png)

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/574843cb5dc4ba904cffe49d854e9873.png)

![image.png|500|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/2a9d41aa43ec0f30c87f58aecbdca4fc.png)

```c
// 方式一：
SCON = 0x40; // 0100 0000 串口工作模式1
TMOD = 0x20; // 设置定时器1工作模式2 8位自动重载
TL1 = 0xFD;  // 设置初值
TH1 = 0xFD;  // 设置装载值
TR1 = 1; // 开始计时（打开计数器）
PCON = 0;

while(1);
```

```c
方式二：
TMOD = 0X20;   //设置定时器1工作模式2 8位自动重载
TH1 = 0xFD;    //设定初值
TL1 = 0XFD;    //设定装载值 
TR1 = 1;       //打开计数器


TMOD &= 0x0F;  //清空TMOD中定时器1相关
TMOD |= 0X20;  //设置定时器1工作模式2 8位自动重载，这里为什么使用|=而不使用=呢，为了避免清除定时器0配置
TH1 = 0xFD;    //设定初值
TL1 = 0XFD;    //设定装载值 
TR1 = 1;       //打开计数器
```

**方式2：公式法（不太明白，先放着）**

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/de4c934201005aa4c29d07014975c514.png)

如果需要设置波特率为`9600=(1/32)*(11059000/12/(256-TH1))`

**SMOD:波特率加倍选择位，复位为0，可以不设置**
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/ad9da1bf1cfa97f6ab4c416129528e9a.png)

```c
TMOD &= 0x0F; // 清空TMOD中定时器1相关配置
TMOD |= 0x20; // 设置定时器1的工作模式为2，8位自动重载，且不影响定时器0
TH1 = 0xFD;  // 设置初值
TL1 = 0xFD;  // 设定转载值
TR1 = 1;  // 打开计数器
PCON |= 0x00; // 设置B7为0
```
### 5.2 校验位设置

**TB8:校验位，在串口模式2、3作为校验位，模式1是8bit的，无需设置校验位**
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/4f5cbf4075a9d2ade3bf2469be3f5547.png)

### 5.3 发送数据

**发送字节数据**
```C
#include <reg52.h>

void UartInit()                //9600bps@11.0592MHz
{
	SCON = 0x40;        //0100 0000 串口工作模式1
	TMOD &= 0x0F;       //清空TMOD中定时器1相关
	TMOD |= 0X20;       //设置定时器1工作模式2:8位自动重载
	TH1 = 0xFD;         //设定定时初值
	TL1 = 0XFD;
	TR1 = 1;            //启动定时器1
}
 
//主函数
void main()
{
	UartInit();//调用串口初始化函数
	SBUF=0x30;
	while(1);       
}
```

发送字符串函数：
- 这里还需要注意一个点是发送完成最后一位后，会置TI=1，所以我们可以用TI寄存器来判断是否发送完
```c
#include <reg52.h>

void UartInit()             //9600bps@11.0592MHz
{
	SCON = 0x40;        //0100 0000 串口工作模式1
	TMOD &= 0x0F;       //清空TMOD中定时器1相关
	TMOD |= 0X20;       //设置定时器1工作模式2， 8位自动重载
	TH1 = 0xFD;         //设定定时初值
	TL1 = 0XFD;
	TR1 = 1;            //启动定时器1
}

void send_string(unsigned char str[])
{
	unsigned char i=0;
	while(str[i]!='\0')//判断是否到字符串尾
	{
		SBUF = str[i];
		while(TI==0);    //等待发送完成，发送完成TI会置1
		TI=0;            //下次发送前，要手动将TI置0
		i++;             //下次发送
	}        
}
 
//主函数
void main()
{
	UartInit();//调用串口初始化函数
	send_string("hello world!!");
	while(1);       
}
```

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/d0e0287609fc44c84eed8118771a535d.png)

## 6 接收 数据相关寄存器配置

模式1的接收过程：
- 当软件置位接收允许标志位REN，即REN=1时，接收器便以选定波特率的`16分频的速率`采样串行接收端口RxD
- 当检测到RxD端口从 `1 -> 0` 的负跳变时就启动接收器准备接收数据，并立即复位16分频计数器，将1FFH植装入移位寄存器
- 复位16分频计数器是使它与输入位时间同步

16分频计数器的16个状态是将1波特率（每位接收时间）均分为16等份，在每位时间的7、8、9状态由检测器对RxD端口进行采样，所接收的值是这次采样直径`“三中取二”的值，即3次采样`至少2次相同的值，以此消除干扰影响，提高可靠性。

在起始位，如果接收到的值不为 0（低电平），则起始位无效，复位接收电路，并重新检测 `1 -> 0` 的跳变。如果接收到的起始位有效，则将它输入移位寄存器，并接收本帧的其余信息

接收的数据从接收移位寄存器的右边移入，已装入1FFH向左边移出，当起始位 0 移到移位寄存器的最左边时，使RX控制器作最后一次移位，完成一帧的接收。若同时满足以下两个条件：
- RI=0
 
则接收的数据有效，实现装载入SBUF，停止位进入RB8，置位RI，即RI=1，向主机请求中断，若上述两条件不能同时满足，则接收到的数据作废并丢失，无论条件满足与否，接收器重新检测RxD端口上的 `1 -> 0` 的跳变，继续下一帧的接收。接收有效，在响应中断后，必须由软件清0，即RI=0。通常情况下，串行通信工作于模式1时，SM2设置为0


![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/2dbfb8d35843608f6041a24dcd4b44e5.png)

![whiteboard_exported_image (1).png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/9abe0580fb0b2a14fbf5237c9b95f3e0.png)

### 6.1 波特率设置

波特率部分和发送是一样，于是初始化函数就变为
```c
void UartInit()                //9600bps@11.0592MHz
{
      SCON = 0x40;            //0101 0000 串口工作模式1
      TMOD &= 0x0F;           //清空TMOD中定时器1相关
      TMOD |= 0X20;           //设置定时器1工作模式2:8位自动重载
      TH1 = 0xFD;             //设定定时初值
      TL1 = 0XFD;
      TR1 = 1;                //启动定时器1
}
```

### 6.2 允许接收寄存器设置

REN 禁止/允许串口接收控制位，为1时，才能接收

![image.png|500|500|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/02/44f315dcb505db256e7288ee21358e29.png)

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/424f549322dd98502c51954d188a6199.png)

```c
SM0 = 0;
SM1 = 1;
REN = 1;//允许接收数据
或
SCON = 0x50;                //0101 0000 串口工作模式1 允许接收
```

### 6.3 接收有效数据标志位

RI：接收有效数据标志位

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/1a9d8f5e745d7664c2f257c0c9621eae.png)

```C
#include <reg52.h>
sbit led=P2^7;
 
//串口初始化函数
void UartInit()                //9600bps@11.0592MHz
{
      SCON = 0x50;            //0101 0000 串口工作模式1 允许接收
      TMOD &= 0x0F;           //清空TMOD中定时器1相关
      TMOD |= 0X20;           //设置定时器1工作模式2:8位自动重载
      TH1 = 0xFD;             //设定定时初值
      TL1 = 0XFD;
      TR1 = 1;                //启动定时器1
}
 
void main()
{
    char receive;//用于接收串口数据的变量
    UartInit();
    while(1)
    {
        if(RI==1)  //RI=1说明串口接收到了数据
        {
           RI=0;   //RI置0保证下次接收
           receive=SBUF;//将从串口接收到的数据报存到变量中
           //判断接收的数据，作出相应的操作
           if(receive=='O')
               led=0;
           else if(receive=='C')
               led=1;        
        }
    }
}
```
## 7 串口中断

**接收到有效数据时，会触发串口中断**，这时候，我们开启串口中断相关的寄存器，就可以在中断服务函数中处理相关逻辑，不需要在大循环中一直判断啦

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/f62ac158b38e952f148fdcd74d47596d.png)

```Java
#include <reg52.h>
sbit led=P2^7;
 
//串口初始化函数
void UartInit()                //9600bps@11.0592MHz
{
	SCON = 0x50;                //0101 0000 串口工作模式1
	TMOD &= 0x0F;                //清空TMOD中定时器1相关
	TMOD |= 0X20;       //设置定时器1工作模式2:8位自动重载
	TH1 = 0xFD;                //设定定时初值
	TL1 = 0XFD;
	TR1 = 1;                //启动定时器1
	ES=1;//打开串行通信中断
	EA=1;//打开总中断
}
//串行中断函数
void Uart_receive() interrupt 4
{
	
	if(RI==1)//RI=1说明串口接收到了数据
	{                
		char receive;
		RI=0;//RI置0保证下次接收
		receive=SBUF;//将从串口接收到的数据报存到变量中
		//判断接收的数据，作出相应的操作
		if(receive=='O')
			led=0;
		if(receive=='C')
			led=1;        
	}
}
//主函数
void main()
{
	UartInit();
	while(1)
	{
	}
}
```
## 8 Printf发送数据

```C
#include <reg52.h>
#include <stdio.h>  

void UartInit(void)                //9600bps@11.0592MHz
{
	PCON &= 0x7F;                //波特率不倍速
	SCON = 0x50;                //8位数据,可变波特率
	TMOD &= 0x0F;                //清除定时器1模式位
	TMOD |= 0x20;                //设定定时器1为8位自动重装方式
	TL1 = 0xFD;                //设定定时初值
	TH1 = 0xFD;                //设定定时器重装值
	ET1 = 0;                //禁止定时器1中断
	TR1 = 1;                //启动定时器1
}

/*
**重写printf调用的putchar函数，重定向到串口输出
**需要引入头文件<stdio.h>
*****/
char putchar(char dat){
	//输出重定向到串口
	SBUF = dat;     //写入发送缓冲寄存器
	while(!TI);    //等待发送完成，TI发送溢出标志位 置1
	TI = 0;      //对溢出标志位清零
	return dat;  //返回给函数的调用者printf
}

//主函数
void main()
{
	UartInit();//调用串口初始化函数
	printf("hello\r\n");
	while(1)
	{
	
	}        
}
```

printf格式化输出
- 和c语言中的格式输出稍微一些不同 
- 例如打印 unsigned char 类型的数据需要使用 `%bd`

```C
unsigned char dat1 = 48;
printf("char-->%bd\r\n",dat1);   //无符号字符型使用%bd显示十进制数
```


![image.png|800](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/01/1af34efcf3171c2b5cd0408c7ab6f85d.png)


