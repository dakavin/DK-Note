---
文章标题: "[[14_序列化与反序列化]]" 
文章作者: Dakkk
文章概要: |
  本文详细阐述了序列化与反序列化的概念、应用场景及其在TCP/IP应用层的位置。文章介绍了Java中`transient`关键字用于控制字段序列化，并列举了Hessian、Kryo等常见序列化协议。同时，深入分析了不推荐使用JDK自带序列化方式的原因，包括跨语言限制、性能低下和安全风险。
文章标签:
- "序列化"
- "反序列化"
- "Java"
- "transient"
- "RPC"
- "数据持久化"
- "序列化协议"
- "安全漏洞"
相关文章:
- "[[13_📕自定义 Jackson 序列化、反序列化，支持 Java 8 日期新特性]]"
- "[[5_特殊关键字的理解]]"
- "[[0_基础加强]]"
- "[[0_链表理论基础]]"
- "[[0_try catch finally原理]]"
文章分类: "🎉 面试"
文章路径: "11-🎉 面试/1_JavaGuide/1_Java面试题/1_Java基础常见面试题/14_序列化与反序列化.md"
文章难度: 初级 💧
目前阶段: ✅ 已完成
重要性: ⭐⭐⭐⭐⭐ 精通必备
创建时间: 2024-08-11 18:15:12
修改时间: 2025-05-27 01:06:00
---

## 1 什么是序列化和反序列化？

如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。

简单来说：

- **序列化**：将数据结构或对象转换成二进制字节流的过程
- **反序列化**：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程

对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。

下面是序列化和反序列化常见应用场景：

- 对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；
- 将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；
- 将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；
- 将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。

维基百科是如是介绍序列化的：

> **序列化**（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不概括之前原始对象所关系的函数。这种过程也称为对象编组（marshalling）。从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。

综上：**序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。**
![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/0a7b2360265d7e5f538f5ab7465cfec2.png)

**序列化协议对应于 TCP/IP 4 层模型的哪一层？**

我们知道网络通信的双方必须要采用和遵守相同的协议。TCP/IP 四层模型是下面这样的，序列化协议属于哪一层呢？

1. 应用层
2. 传输层
3. 网络层
4. 网络接口层

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/144ee98219363b93be5b0772043ce972.png)

如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？

因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以序列化协议属于 TCP/IP 协议应用层的一部分。

`回答思路：`
	1. **序列化**：将数据结构或对象转换成二进制字节流的过程
	2. **反序列化**：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程
	3. 序列化的主要目的：通过网络传输对象，或将，对象保存在文件系统、数据库、内存中；
	4. 延伸：在网络传输的TCP/IP协议中，应用层（表示层）中也有序列化协议
## 2 如果有些字段不想进行序列化怎么办？

`回答思路：`

对于不想进行序列化的变量，使用 `transient` 关键字修饰。

`transient` 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 `transient` 修饰的变量值不会被持久化和恢复。

关于 `transient` 还有几点注意：

- `transient` 只能修饰变量，不能修饰类和方法。
- `transient` 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 `int` 类型，那么反序列后结果就是 `0`。
- `static` 变量因为不属于任何对象(Object)，所以无论有没有 `transient` 关键字修饰，均不会被序列化。

## 3 常见的序列化协议有哪些？

`回答思路：`
	1. JDK自带的序列化方式一般不用用，因为效率低且存在安全问题；
	2. 比较常用的有：Hessian、Kryo、Protobuf、ProtoStuff，这些基于二进制的序列化协议
	3. JSON、XML属于文本类序列化方式，可读性较好，性能较差，一般不会选择
## 4 为什么不推荐使用JDK自带的序列化？

`回答思路：`

- **不支持跨语言调用** : 如果调用的是其他语言开发的服务的时候就不支持了。
- **性能差**：相比于其他序列化框架性能更低，主要原因是`序列化之后的字节数组体积较大`，导致传输成本加大。
- **存在安全问题**：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。相关阅读：[应用安全：JAVA 反序列化漏洞之殇open in new window](https://cryin.github.io/blog/secure-development-java-deserialization-vulnerability/) 。

