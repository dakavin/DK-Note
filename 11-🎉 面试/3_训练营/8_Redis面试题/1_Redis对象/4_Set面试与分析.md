  
## 1 面试考点分析

Set是一个无序集合对象。

面试的考察点集中在Set常规操作和底层实现，常规操作必须熟练掌握，底层实现要了解其编码方式，其中HASHTABLE是重中之重，面试大热门考点，后面会有单独章节讲解

## 2 面试题

### 2.1 Set是有序的吗？

分析：
- Set的底层实现是整数集合和HASHTABLE，前者是有序的，后者是无序的。

回答：
- Set的`底层实现是整数集合或字典`，前者是有序的，后者是无序的。整体看来，建议不依赖SET的顺序。
### 2.2 如何查看Set的所有成员？

分析：
- 基本操作考察

回答：
- SMEMBERS命令即可返回，参数是Set对象，即SMEMBERS key

### 2.3 如何查看Set中成员个数？

分析：
- 基本操作考察

回答：
- SSCARD命令即可返回成员个数，参数是Set对象，即SCARD key

### 2.4 如何求两个Set的并集或交集呢？

分析：
- 基本操作考察

回答：
- 使用`SINNER获取两个Set的交集`，使用`SUNION获取两个Set的并集`
- SINNER可以找到在第一个集合中，且后面集合都出现的元素，是可以求两个Set的交集的，SUNION则可以求并集
### 2.5 Set的编码方式是什么？

分析：
- Set底层使用了两种编码，一种是整数集合，另一种是字典。
- 成员的数据结构和成员数量会触发Set更改底层编码，当Set通知满足元素都是整数 且 元素个数不超过512这两个条件，会使用整数集合编码，否则使用字典编码。
```shell
set-max-intset-entries 512
```

回答：
- Set使用整数集合和字典作为底层编码，当元素`都是整数`同时`元素个数不超过512个`，会`使用整数集合编码`，否则使用字典编码

### 2.6 Set为什么要用两种编码方式？

分析：
- 我们可以从编码转换条件来进行思考，Set的底层编码从INTSET到HASHTABLE的条件是元素个数或元素类型的变化。
- 所以采用两种编码方式的原生是`INTSET更节约内存`，所在在小数据时使用，而`数据多起来了，需要HASHTABLE的查找性能`。
- 实际上如果Set保存的所有元素都是整数，而且元素个数不是特别多的情况下，使用INTSET会比较节约内存，Redis用一个含有三个字段的结构体来表示INTSET，分别是编码方式、元素数量和实际存储元素的有序柔性数组：
```C
typedef struct intset {
	uint32_t encoding; //编码格式
	uint32_t length;   //元素数量
	int8_t contents[]; //保存元素的数组
} intset
```

- INTSET用来保存元素的数组默认情况下是int16编码，后续如果插入各大的整数，才会升级到int32或者int64编码。
- 这种策略可以尽可能的节约内存以及提升整数集合的灵活性。

- 但是升级也有弊端，升级之后，整个数组的编码会变成与最大元素的类型一致。
- 假如这个时候，元素的数量非常多，就不那么节约内存了，厄齐尔有序整数数组二分查找的平均时间复杂度是$O(logn)$，不如使用字典编码。

回答：
- Set的底层编码是整数集合和字典，当元素数量少且全部是整数的时候，会使用整数集合编码，更加的节约内存。元素数量变大会使用字典编码，查找元素的速度会更快。