---
文章标题: "[[11_(进阶)自定义类型详解]]" 
文章作者: Dakkk
文章概要: |
  本文详细解析了C语言中的结构体、位段、枚举和联合体等自定义类型。文章深入探讨了结构体的声明、特殊用法、内存对齐规则及优化方法，阐述了位段的内存分配、跨平台问题。同时，也讲解了枚举和联合体的定义、特点及实际应用，提供了丰富的代码示例。
tags:
- "C语言"
- "结构体"
- "内存对齐"
- "位段"
- "枚举"
- "联合体"
- "自定义类型"
- "指针"
相关文章:
- "[[12_(进阶)动态内存管理]]"
- "[[5_指针]]"
- "[[6_结构体]]"
- "[[9_(进阶)指针（多回顾）📕📕📕]]"
- "[[_常用函数]]"
文章分类: "💻 编程语言"
文章路径: "02-💻 编程语言/02-🔷 C&C++技术栈/02-📖 C语言基础/3_C语言（比特-查漏补缺）/11_(进阶)自定义类型详解.md"
文章难度: 中级 🌳
目前阶段: ✅ 已完成
重要性: ⭐⭐⭐⭐⭐ 精通必备
创建时间: 2025-04-14 00:13:56
修改时间: 2025-05-27 21:58:16
---

## 1 结构体的声明

### 1.1 结构的基础知识

结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同类型的变量。
### 1.2 结构的声明

```c
struct tag{
	member-lust;
}variable-list;
```

例如描述一个学生：
```c
struct stu{
	char name[20];
	int age;
	char sex[5];
	char id[20];
}; //分号不能丢
```
### 1.3 特殊的声明📕

在声明结构的时候，可以不完全的声明
```c
//匿名结构体类型
struct {
	int a;
	char b;
	float c;
}x,a[20],*p;
```
- 上面的两个结构在声明的时候省略掉了结构体标签（tag）
- **问题：在上面的代码基础上，`p = &x` 合法吗？**
	- ❗️❗️❗️编译器会把上面的两个声明当成完全不同的两个类型，所以是 `非法的`
### 1.4 结构自引用误区📕

**在结构中包含一个类型为该结构本身的成员是否可以呢？**
```c
struct Node{
	int data;
	struct Node next;
};
// 可行否？
// 如果可以，那sizeof(struct Node)是多少？
```
- 不可行：结构体内部包含完整的结构体，导致无线递归定义，编译器无法计算大小

**正确的定义方式**
```c
struct Node{
	int data;
	struct Node *next; // 使用指针，而不是结构体本身
};
```

**再看看下面的代码是否可行？**
```c
typedef struct{
	int data;
	Node *next;
}Node;
```
- 不可行：结构体内部用了Node，但是在typedef过程中，Node还没定义完成
- 编译器会报错：Node未定义

**正确的定义方式**
```c
typedef struct{
	int data;
	struct Node *next;  // 注意，这里struct Node* 才是结构体指针
}Node;
```
### 1.5 结构体变量的定义和初始化

有了结构体类型，那如何定义变量，其实很简单
```c
struct Point{
	int x;
	int y;
}p1;                //1. 声明类型的同时定义变量p1
struct Point p2     //2. 定义结构体变量p2

//3. 定义变量的同时赋值
struct Point p3 = {x,y};
```

```c
struct Stu{
	char name[15];
	int age;
};

struct Stu s = {"zhangsan",20}；  //1. 正常初始化

struct Node{
	int data;
	struct Point p;
	struct Node *next;
}n1={10,{4,5},NULL};              //2. 结构体嵌套初始化

struct Node n2 = {20,{5,6},NULL}; //3. 结构体嵌套初始化
```

### 1.6 结构体内存对齐

现在我们深入讨论一个问题：**计算结构体的大小**。
这也是一个特别热门的考点： `结构体内存对齐`

基本概念：
- 计算机要求基本类型的数据按一定地址边界存储，称为对齐。
- 比如，`int` 必须放在4字节对齐地址（地址能被4整除），`double` 通常8字节对齐。
- 结构体中如果数据成员顺序导致对齐规则不满足，会插入一些“空洞”（padding）来满足对齐。
- 结构体整体大小也会补足到最大对齐数的整数倍。

```c
struct S1{  
    char c1;  
    int i;  
    char c2;  
};  
  
struct S2{  
    char c1;  
    char c2;  
    int i;  
};  
  
struct S3{  
    double d;  
    char c;  
    int i;  
};  
  
struct S4{  
    char c1;  
    struct S3 s3;  
    double d;  
};  
int main() {  
    printf("%d\n", sizeof(struct S1));  //12
    printf("%d\n", sizeof(struct S2));  //8
    printf("%d\n", sizeof(struct S3));  //16
    printf("%d\n", sizeof(struct S4));  //32
    return 0;  
}
```

**如何计算？** 掌握结构体的对齐规则
- 第一个成员在与结构体变量偏移量为0的地址处
- 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处
	- `对齐数 = 编译器默认的一个对齐数与该成员大小的较小值`
	- VS中默认的值为8
- 结构体总大小为`最大对齐数`（每个成员变量都有一个对齐数，除去默认对齐数！）的整数倍
- 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是`所有最大对齐数`（含嵌套结构体的对齐数）的整数倍

例子说明：
```c
struct S1{
	char c1;   // 1字节
	// 3字节填充(padding)，使int i对齐到4字节边界 （4<8）
	int i;     // 4字节
	char c2;   // 1字节
	// 3字节填充(padding)，使结构体长度是4的倍数（最大对齐数是4）
};

struct S2{
	char c1;   // 1字节
	char c2;   // 1字节
	// 2字节填充，使int i对齐到4字节边界 （4<8）
	int i;     // 4字节
};

struct S3{
	double d; // 8字节，偏移0，对齐8字节
	char c;   // 1字节
	// 3字节padding，保证int i在4字节对齐地址  （4<8）
	int i;    // 4字节 
	// 4字节padding，使结构体总大小是8的倍数（double的对齐）
};

struct S4{
	char c1;       // 1字节
	// 7字节padding，使s3结构体从8字节对齐的地址开始 （16>8）
	struct S3 s3;  // 16字节，对齐8字节
	double d;      // 8字节，对齐8字节
};
```

**为什么存在内存对齐？**
- 平台原因（移植）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
- 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐，原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问

**总体来说：** 结构体的内存对齐是拿**空间**来换取**时间**的做法

**如何减少结构体大小呢？**
- 按照内存对齐规则，尽量把大类型放前面，小类型放后面，减少中间填充。
- 让占用空间小的成员尽量集中在一起，例如S1和S2的区别
- 例如 S1 按顺序改成 `int i; char c1; char c2;`，大小可以减少。
- 也可以用 `#pragma pack` 或 `__attribute__((packed))` 来改变对齐，但代价是可能导致未对齐访问带来性能损失或错误。
### 1.7 修改默认对齐数

之前我们见过了#pragma 这个预处理指令，这里我们再次使用，可以改变我们的默认对齐数
```c
#include <stdio.h>  
#pragma pack(8)  //设置默认对齐数为8  
struct S1{  
    char c1;  
    int i;  
    char c2;  
};  
#pragma pack() // 还原默认对齐数  
  
#pragma pack(1)  //设置默认对齐数为1  
struct S2{  
    char c1;  
    int i;  
    char c2;  
};  
#pragma pack() // 还原默认对齐数  
  
int main() {  
    printf("%d\n", sizeof(struct S1));  // 12  
    printf("%d\n", sizeof(struct S2));  // 6  
    return 0;  
}
```
### 1.8 结构体传参

```c
struct S{  
    int data[1000];  
    int num;  
};  
  
//1. 结构体传参  
void print1(struct S s){  
    printf("%d\n",s.num);  
}  
//2. 结构体地址传参  
void print2(struct S *s){  
    printf("%d\n",s->num);  
}  
  
int main() {  
    struct S s = {{1,2,3,4},1000};  
    print1(s);  
    print2(&s);  
    return 0;  
}
```

**开发的时候首选print2函数**
- 函数传参的时候，参数是需要压栈，会有时间和空间上的系统开销
- 如果传递一个结构体对象的时候，结构体过大，参数压栈的的系统开销比较大，所以会导致性能的下降
## 2 位段/位域（bit-field）

结构体讲完就得讲讲结构体实现`位段`的能力
### 2.1 什么是位段/位域（bit-field）

位段的声明和结构是类似的，有两个不同：
- 位段的成员必须是`int`、`unsigned int` 或`signed int`
- 位段的成员名后边有一个冒号和一个数字（数字不能超过类型规定的bit位长度）

例如：
```c
struct A{
	int _a:2;
	int _b:5;
	int _c:10;
	int _d:30;
};

// A就是一个位段类型，大小是多少呢？
printf("%d\n", sizeof(struct A)); // 8
```

**为什么大小是8个字节呢？**
- 位域声明了结构体成员占用的**位数**，如`int _a:2`表示2位
- 位域所在的类型（这里是`int`）决定了分配单元的大小和对齐
- 位域按照声明从低位开始紧凑排列在同一个“**分配单元**”中，直到`分配单元用满`或者`下一个位域跨越边界`时，或者`类型不一致`会另起一个分配单元。
- 位域的“分配单元”一般是其基础类型的大小，这里是`int`，通常是4字节（32位系统或者64位系统里`int`通常是4字节）

A结构体成员位域长度总和 ： `2 + 5 + 10 + 30 = 47` 位

**分配单元大小及对齐**
- 一个 `int` 是4字节，即32位
- 编译器给位域分配空间时，会用完整的`int`（32位）为一个分配单元
- 由于位域总长度为47位，超过一个32位的`int`单位，无法放入一个单位中，因此需要2个`int`单位存储，所以大小为8个字节
### 2.2 位段的内存分配

- 位段的成员可以是`int`、`unsigned int` 或`signed int`类型
- 位段的空间上是按照需要以`4个字节（ int ）`或者`1个字节（ char ）`的方式来开辟的
- **位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段**

```c
struct S {  
    char a: 3;  
    char b: 4;  
    char c: 5;  
    char d: 4;  
};

struct S s = {0};
s.a = 10;
s.b = 12;
s.c = 3;
s.d = 4;

```

**分配过程：**
- 第1个 `char` 单元（8位）先放 `a:3` (占3位)
- 剩余 5 位可放 `b:4` ➔ 剩余1位不用了
- 第2个 `char` 单元开始，因为 `c:5`(5位) 超过第1个字节剩余1位，不够放，开始新字节存储
- 第2个单元存 `c:5` (5位)
- 剩余3位放 `d:4` (4位)，不足只能在下一个单元继续
- 第3个单元存 `d:4` (4位)

**内存空间分配示意图：**
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/d79bf32a0cc7bfc1d1d9b33da25f532c.png)
### 2.3 位段的跨平台问题

1. int 位段被当成有符号数还是无符号数是不确定的
2. 位段中最大位的数目不能确定。（16位机器最大16，32位机器最大32，写成27，在16位机器会出问题
3. 位段中的成员在内存中从左向右分配，还是从右向左分配标准尚未定义
4. 当一个结构包含两个位段，第二个位段成员比较大，无法容纳于第一个位段剩余的位时，是舍弃剩余的位还是利用，这是不确定的

**所以：** 跟结构相比，位段可以达到同样的效果，但是可以很好的节省空间，但是有跨平台的问题存在
### 2.4 位段的应用

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/405564e85ac0a2927d9ee2a0ee54cbc7.png)

如图：网络协议的底层代码，使用的还是位段
## 3 枚举

枚举就是列举，把可能得取值列举出来

比如：
- 一周的星期一到星期日是有限的7天，可以一一列举
- 性别有：男、女、保密，也可以一一列举
- 月份有12个月，也可以一一列举
### 3.1 枚举类型的定义

```c
enum Day{ //星期
	Mon,
	Tues,
	Wed,
	Thur,
	Fri,
	Sat,
	Sun
};
enum Sex{  //性别
	MALE,
	FEMALE,
	SECRET
}；
enum Color{//颜色
	RED,
	GREEN,
	BLUE
};
```
- 以上定义的enum Day ， enum Sex ， enum Color 都是枚举类型
- {}中的内容是枚举类型的可能取值，也叫`枚举常量`

这些可能取值都是有值的，默认从0开始，一次递增1，**当然在定义的时候也可以赋初值**
```c
enum Color{//颜色
	RED=1,
	GREEN=2,
	BLUE=4
};
```
### 3.2 枚举的优点

我们可以使用#define 定义常量，为什么非要使用枚举？其优点如下
- 增加代码的可读性和可维护性
- 枚举有类型检查，更加严谨
- 防止了命名污染（封装）
- 便于调试
- 使用方便，一次可以定义多个常量
### 3.3 枚举的使用

```c
enum Color{  
    RED = 1,  
    GREEN = 2,  
    BLUE = 4  
};  
  
int main() {  
	//只能拿枚举常量给枚举变量赋值，才不会出现类型的差异。
    enum Color color = GREEN;  
    printf("%d\n", color); // 2  索引值
    color = 5;  
    printf("%d\n", color); // 5  
    return 0;  
}
```
## 4 联合（共用）体

### 4.1 联合类型的定义

联合也是一种特殊的自定义类型
- 这种类型定义的变量也包含一系列的成员，特征是这些成员`共用同一块空间（所以联合也叫共用体）`
- 所以其内存空间大小，是类型最大的成员的大小

```c
#include <stdio.h>  
  
// 联合体的声明  
union Un{  
    char c;  
    int i;  
};  
  
int main() {  
    // 联合变量的定义  
    union Un u;  
    // 计算联合变量的大小  
    printf("sizeof(u) = %d\n", sizeof(u));  //共用int的内存空间，4
    return 0;  
}
```
### 4.2 联合的特点📕

联合的成员是共用同一块内存空间的，这样一个联合变量的大小，至少是最大成员的大小（因为联
合至少得有能力保存最大的那个成员）

```c
int main() {  
    // 联合变量的定义  
    union Un u;  
    printf("%d\n", sizeof(u.i));  // 4
    printf("%d\n", sizeof(u.c));  // 1
  
    u.i = 0x11223344;  
    u.c = 0x55;  
    // 共享一块内存，先写入0x11223344
    // 小端存储方式，将0x55写入该内存最低地址字节，低地址0x44---> 0x55
    // 所以结果 0x11223355
    printf("%x\n", u.i);   
    return 0;  
}
```

**案例：使用联合体判断当前计算机的大小端存储**
```c
union Un{  
    char c[sizeof(int)];  
    int i;  
};  
  
int main() {  
    union Un u;  
    u.i = 0x11223344;  
    // 大端(低字节高（右）地址)：11 22 33 44  
    // 小端(低字节低（左）地址)：44 33 22 11  
    // u.c此时共用i的内存，且在低地址  
    if  (u.c[0] == 0x11) {  
        printf("大端\n");  
    } else {  
        printf("小端\n");  
    }  
    return 0;  
}
```
### 4.3 联合大小的计算

- 联合的大小至少是最大成员的大小。
- 当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍。

```c
#include <stdio.h>  
  
union Un1{  
    char c[5];  
    int i;  
};  
  
union Un2{  
    char c[7];  
    int i;  
};  
  
int main() {  
    printf("sizeof(Un1) = %d\n", sizeof(union Un1)); //8  
    printf("sizeof(Un2) = %d\n", sizeof(union Un2)); //8  
    return 0;  
}
```