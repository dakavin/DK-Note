
## 1 C语言中函数的分类

### 1.1 库函数

C语言的基础库中提供了一系列类似的库函数，方便程序员进行软件开发。这里我们简单的看看
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/04/c201df98e1ccd2fcfd08ada90003bf77.png)

简单的总结，C语言常用的库函数都有：
- IO函数
- 字符串操作函数
- 字符操作函数
- 内存操作函数
- 时间/日期函数
- 数学函数
- 其他库函数

**注意：使用库函数，必须包含#include 对应的头文件**

参考网址：https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5
### 1.2 自定义函数

懂得都懂
## 2 函数的参数

### 2.1 实参

真实传给函数的参数，叫实参

实参可以是：`常量、变量、表达式、函数`等

无论实参是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参
### 2.2 形参

形式参数是指函数名后括号中的变量，因为形式参数只有在函数被调用的过程中才实例化（分配内存单元），所以叫形式参数

形式参数当函数调用完成之后就自动销毁了。因此**形式参数只在函数中有效**。

## 3 函数的调用📕

### 3.1 传值调用

**函数的形参和实参分别占有不同内存块，对形参的修改不会影响实参**
### 3.2 传址调用

- 传址调用是把函数外部创建变量的`内存地址传递给函数参数`的一种调用函数的方式。
- 这种传参方式可以让函数和函数外边的变量建立起真正的联系，也就是`函数内部可以直接操作函数外部的变量`

```c
void add(int *i){  
    (*i)++;  
}  
  
int main() {  
    int num = 0;  
    add(&num);  
    printf("num = %d\n",num);  
    return 0;  
}
```

## 4 函数的嵌套和链式访问

函数和函数之间可以根据实际的需求进行组合的，也就是互相调用的。
### 4.1 嵌套调用

函数可以嵌套调用，但是不能嵌套定义。
### 4.2 链式访问

把一个函数的返回值作为另外一个函数的参数。

## 5 函数的声明和定义

- 告诉编译器有一个函数`叫什么`，`参数是什么`，`返回类型是什么`。但是具体是不是存在，函数声明决定不了。
- 函数的声明一般出现在函数的使用之前。要满足先声明后使用。
- 函数的声明一般要放在头文件中

函数的定义是指函数的具体实现，交待函数的功能实现
- 放在test.h的内容
```h
#ifndef __TEST_H__
#define __TEST_H__
//函数的声明
int Add(int x, int y);
#endif //__TEST_H__
```
- 放在test.c的内容
```c
#include "test.h"
//函数Add的实现
int Add(int x, int y)
{
	return x+y;
}
```
## 6 函数递归

程序调用自身的编程技巧称为递归（ recursion）
- 递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有`直接或间接调用自身的`
- 一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略
- 只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量
- **递归的主要思考方式在于：把大事化小**
### 6.1 递归两个必要条件

- 存在限制条件，当满足这个限制条件的时候，递归便不再继续。
- 每次递归调用之后越来越接近这个限制条件。

例子1：按照顺序打印一个无符号整型的每1位
- 如 1234 ---> 1,2,3,4
```c
void print(unsigned int n){  
    if(n>9){  
        print(n/10);  
    }  
    printf("%d ",n%10);  
}
```

例子2：编写函数不允许创建临时变量，求字符串的长度
```c
int Strlen(const char *str) {  
    if (*str == '\0') return 0; 
    // 移动str指向下一个元素 
    return 1 + Strlen(str + 1);  
}
```

例子3：快速排序
```c
int partition(int arr[],int left,int right){  
    int p = arr[left];  
    while(left < right){  
        while ((left<right)&&(arr[right]>=p)) right--;  
        arr[left] = arr[right];  
        while ((left<right)&&(arr[left]<=p)) left++;  
        arr[right] = arr[left];  
    }  
    arr[left] = p;  
    return left;  
}  
  
void quickSort(int arr[],int left,int right){  
    if(left<right){  
        int p = partition(arr,left,right);  
        quickSort(arr,left,p-1);  
        quickSort(arr,p+1,right);  
    }  
}
```

例子4：汉诺塔
```c
void move(char start, char end, int n){   //用于打印移动操作到控制台，start是起始柱子，end是结束柱子，n是哪一个圆盘
    printf("第%d个圆盘：%c --> %c\n", n, start, end);
}

void hanoi(char a, char b, char c, int n){  //刚进来的时候，B作为中间柱子，C作为目标柱子，要移动A上的n个圆盘到C去
    if(n == 1) {
        move(a, c, n);   //无论a,b,c如何变换，通过递归，最后都会变成一个n = 1的问题，直接移动就完事了
    } else{
        hanoi(a, c ,b, n - 1);  //首要目标是先把上面n-1个圆盘全部放到B去，这里就变换一下，让B作为目标柱子，C作为中间
        move(a, c, n);   //现在A上只剩下一个最大的圆盘了，接着把A最下方的一个圆盘移到C去
        hanoi(b, a, c, n - 1);   //最后需要把B上的全部搬到C上去，这里就可以以C为目标柱子，A为中间柱子
    }
}
```

简化
```c
void hanoi(char a, char b, char c, int n){
    if(n == 0) return;
    hanoi(a, c ,b, n - 1);
    printf("第%d个圆盘：%c --> %c\n", n, a, c);
    hanoi(b, a, c, n - 1);
}
```
### 6.2 递归和迭代

```c
// n的阶乘
int factorial(int n)
{
	if(n <= 1)
		return 1;
	else
		return n * factorial(n-1);
}


// 第n个斐波那契数
int fib(int n)
{
	if (n <= 2)
		return 1;
	else
		return fib(n - 1) + fib(n - 2);
}
```

**有个问题**
- 在使用fib 这个函数的时候如果我们要计算第50个斐波那契数字的时候特别耗费时间
- 使用factorial 函数求10000的阶乘（不考虑结果的正确性），程序会崩溃

**原因**
- 每次递归都会调用一次函数，然后压栈，栈占内存空间是有限的，如果次数较多（n过大）就会报错，`stack overflow（栈溢出）`

**解决**
- 将递归改写成非递归，即迭代
- 使用static对象替代nonstatic 局部对象。在递归函数设计中，可以使用static 对象替代nonstatic 局部对象（即栈对象），这不仅可以减少每次递归调用和返回时产生和释放nonstatic 对象的开销，而且static 对象还可以保存递归调用的中间状态，并且可为各个调用层所访问

**迭代的方式**
```c
int factorial(int n)
{
	int res = 1;
	while(n>1){
		res *= n;
		n--;
	}
	return res;
}
```

