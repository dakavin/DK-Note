---
文章标题: "[[8_(进阶)数据的存储]]"
文章作者: Dakkk
文章概要: |
  文章深入讲解C语言中数据的内存存储机制，包括基本数据类型、整型（原码、反码、补码、大小端字节序）和浮点型（IEEE 754标准）的详细存储原理，并通过代码示例帮助读者理解。
tags:
  - 数据存储
  - C语言
  - 整型存储
  - 浮点型存储
  - 原码反码补码
  - 大小端
  - IEEE
  - 内存表示
相关文章:
  - "[[_常用函数]]"
  - "[[0_课程完整内容]]"
  - "[[0_Linux系统编程]]"
  - "[[1_704.二分查找]]"
  - "[[1_持久化介绍]]"
文章分类: 💻 编程语言
文章路径: 02-💻 编程语言/02-🔷 C&C++技术栈/02-📖 C语言基础/3_C语言（比特-查漏补缺）/8_(进阶)数据的存储.md
文章难度: 中级 🌳
目前阶段: ✅ 已完成
重要性: ⭐⭐⭐⭐⭐ 精通必备
创建时间: 2025-04-14 00:13:55
修改时间: 2025-05-26 07:26:51
---

## 1 重点

1. 数据类型详细介绍
2. 整形在内存中的存储：原码、反码、补码
3. 大小端字节序介绍及判断
4. 浮点型在内存中的存储解析
## 2 数据类型介绍

基本的数据类型复习
```c
char //字符数据类型       1
short //短整型           2
int //整形               4
long //长整型            4（32位） / 8（64位） 类似于指针类型占用的内存大小
long long //更长的整形    8
float //单精度浮点数      4
double //双精度浮点数     8
//C语言没有字符串类型!
```

**类型的意义**
- 使用这个类型开辟内存空间的大小
- 如何看待内存空间的视角

**类型的基本归类**
- 整型
```c
char // char没有默认下面那个，取决于编译器的实现
	unsigned char
	signed char
short
	unsigned short [int]
	signed short [int]
int
	unsigned int
	signed int
long
	unsigned long [int]
	signed long [int]
```

- 浮点型
```c
float
double
```

- 构造类型
```c
> 数组类型
> 结构体类型 struct
> 枚举类型 enum
> 联合类型 union
```

- 指针类型
```c
int *pi;
char *pc;
float* pf;
void* pv;
```

- 空类型
	- void 表示空类型（无类型）
	- 通常应用于函数的返回类型、函数的参数、指针类型
## 3 整型在内存中的存储

数据在所开辟内存中到底是如何存储的？
```c
int a = 20; // 为a分配4个字节的内存空间
int b = -10；
```
### 3.1 原码、反码、补码

三种表示方法均有**符号位**和**数值位**两部分，符号位都是用0表示“正”，用1表示“负”，而数值位
**负整数的三种表示方法各不相同**

原码：直接将二进制按照正负数的形式翻译成二进制即可
反码：原码符号位不变，其他位取反
补码：反码+1，**数据在内存中存放的就是补码**
- 使用补码，可以将符号位和数值位统一处理
- 同时，加法和减法也可以统一处理（CPU只有加法器），此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路

`正数的原、反、补码都相同`

我们看看在内存中的存储：
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/b092ac42cd9cbe8a6a18afbe73bd296c.png)

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/10a3544f4c45e5bbac489a9c427b6036.png)


我们可以看到对于a和b分别存储的是补码。但是我们发现顺序有点不对劲。
这是又为什么？
### 3.2 大小端介绍

大端存储模式：数据低位--->内存高地址，数据高位--->内存低地址
小端存储模式：数据低位--->内存低地址，数据高位--->内存高地址

为什么有大端和小端？
- 在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit
- 但是在C语言中，除了8bit的char之外，还有16bit的short，32bit的long（看具体的编译器）
- 例外，对于位数大于8位的处理器，如16和32位处理器，由于寄存器宽度大于一个字节，那么必然存在如何将多个字节安排的问题。
- 因此就导致了大端存储模式和小端存储模式

**例如：** 一个16bit的short类型变量x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高位字节，0x22为低位字节
- 大端模式，0x11在低位，0x22在高位
- 小段模式，0x11在高位，0x22在低位

**常用的系统结构对应的存储模式**
- x86架构：小端模式
- Keil C51架构：大端模式
- ARM，DSP架构：小端模式
- 其他ARM处理器，可以选择大端还是小端
### 3.3 练习

设计一个小程序来判断当前机器的字节序
```c
#include <stdio.h>
int check_sys(){  
    int i = 1;  
    return (*(char *)&i);  
}  
int main() {  
    int ret = check_sys();  
    if (ret == 1) {  
        printf("Little Endian\n");  
    } else {  
        printf("Big Endian\n");  
    }  
    return 0;  
}
```

输出什么？
- 补充知识
  ![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/00c075d353f55c287fe6c09c8f40ca50.png)

```c
char a= -1;          // 补码 11111111，整型提升，负数左边补1
signed char b=-1;    // 补码 11111111，整型提升，负数左边补1
unsigned char c=-1;  // 补码 11111111，整型提升，unsigned，左边补0
printf("a=%d,b=%d,c=%d",a,b,c);   // -1 -1 255

//------------------------------

char a = -128;      // 补码为 1000 0000
printf("%u\n",a);   // 整型提升，char变int，高位是1，左边补1，0xFF FF FF 80，输出正数

//------------------------------

char a = 128;       // 溢出，存储为补码 `10000000`
printf("%u\n",a);

//------------------------------

unsigned int i;
for(i = 9; i >= 0; i--)  // i>=0永远成立
{
	printf("%u\n",i);   // 9 ---> 0 ---> -1变正数 ... 
}

//------------------------------

char a[1000];
int i;
for(i=0; i<1000; i++){
	a[i] = -1-i;   // 注意赋值给char，发生截断，假设char在平台是有符号的
	               // int的变化为 -1 ---> -1000，但是截断了
	              // 所以 -1 ---> -128 ---> 127 ---> 0 
}
printf("%d",strlen(a));  // 检测到'\0'停止，所以一个循环为255

//------------------------------

unsigned char i = 0;
int main(){
	for(i = 0;i<=255;i++){   // char变int，比较的是 (int)i<=255
	                         // i是无符号8为，到255会溢出，重新变为0
		                       // 循环永远不会结束  
		printf("hello world\n");
	}
	return 0;
}
```

## 4 浮点型在内存中的存储
### 4.1 一个例子

```c
int main(){
	int n = 9;
	float *pFloat = (float *)&n;
	printf("n的值为：%d\n",n);
	printf("*pFloat的值为：%f\n",*pFloat);
	
	*pFloat = 9.0;
	printf("num的值为：%d\n",n);
	printf("*pFloat的值为：%f\n",*pFloat);
	return 0;
}
```

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/2f387fe3d4294711bf0f1e87beac95fe.png)

### 4.2 浮点数存储规则

num 和`*pFloat `在内存中明明是同一个数，为什么浮点数和整数的解读结果会差别这么大？
要理解这个结果，一定要搞懂浮点数在计算机内部的表示方法。

根据国际标准IEEE（电气和电子工程协会） 754，任意一个`二进制浮点数V`可以表示成下面的形式：
- $(-1)^S * M * 2^E$
- $(-1)^s$ 表示符号位，当s=0，正数，s=1，负数
- M表示有效数字，大于等于1，小于2
- $2^E$ 表示指数位

**举例**
- 十进制的5.0，写成二进制是101.0 ，相当于$1.01×2^2$ 。
- 那么，按照上面V的格式，可以得出s=0，M=1.01，E=2。
- 十进制的-5.0，写成二进制是-101.0 ，相当于-1.01×2^2 。那么，s=1，M=1.01，E=2。
	- IEEE 754规定：
	- 对于32位的浮点数，最高的1位是符号位s，接着的`8位是指数E`，剩下的`23位为有效数字M`。
	  ![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/2814995bd61de10c19a196a68a35ff4d.png)
	- 对于64位的浮点数，最高的1位是符号位S，接着的`11位是指数E`，剩下的`52位为有效数字M`
	  ![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/c097cd4367df2c2a37a7d3a7f1b174b4.png)
**IEEE 754对有效数字M和指数E，还有一些特别规定**
- `1≤M<2` ，也就是说，M可以写成`1.xxxxxx` 的形式，其中xxxxxx表示小数部分
- 在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存后面的xxxxxx部分，例如保存1.01时，只保存01，等到读取的时候，再把第一位的1加上去。目的是为了节省1位有效数字，以32位浮点数为例子，将第一位1舍去之后，可以保存24位有效数字

**至于指数E，情况就比较复杂**
- 首先，E为一个无符号整数（unsigned int），如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047
- 但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，存入内存时E的真实值**必须再加上一个中间数**，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。比如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001

**然后指数E从内存中取出还可以分成3种情况**

**情况1：E不全为0或不全为1**
- 这时，浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。
- 比如：0.5（1/2）的二进制形式为0.1，由于规定正数部分必须为1，即将小数点右移1位，则为`1.0*2^(-1)`，其阶码为-1+127=126，表示为01111110，而尾数1.0去掉整数部分为0，补齐0到23位00000000000000000000000，则其二进制表示形式为:
```c
0 01111110 00000000000000000000000
```

**情况2：E全为0**
- 这时，浮点数的指数E等于1-127（或者1-1023）即为真实值
- 有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。

**情况3：E全为1**
- 这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；

### 4.3 题目回顾

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/395b34297720a4e8eb611d9f3d203575.png)

首先，将0x00000009 拆分，得到第一位符号位s=0，后面8位的指数E=00000000 ，最后23位的有效数字M=000 0000 0000 0000 00001001
```c
9 -> 0000 0000 0000 0000 0000 0000 0000 1001
```

由于指数E全为0，所以符合上一节的第二种情况。因此，浮点数V就写成：
`V=(-1)^0 × 0.00000000000000000001001×2^(-126)=1.001×2^(-146)`

显然，V是一个很小的接近于0的正数，所以用十进制小数表示就是0.000000

请问浮点数9.0，如何用二进制表示？还原成十进制又是多少？

首先，浮点数9.0等于二进制的1001.0，即1.001×2^3
```c
9.0 -> 1001.0 ->(-1)^0*1.001*2^3 -> s=0, M=1.001,E=3+127=130
```

那么，第一位的符号位s=0，有效数字M等于001后面再加20个0，凑满23位，指数E等于3+127=130，即10000010

所以二进制形式，应该是s+E+M，即
```c
0 10000010 001 0000 0000 0000 0000 0000
```

这个32位的二进制数，还原成十进制，正是1091567616