---
文章标题: "[[2_Java并发]]" 
文章作者: Dakkk
文章概要: |
  文章系统性概述Java并发核心概念，包括死锁、线程同步（Synchronized、ReentrantLock、AQS、CAS）、线程间通信、volatile关键字及Java内存模型，以及并发集合。内容全面，旨在提供并发编程的基础与进阶理解。
tags:
- "Java并发"
- "死锁"
- "线程同步"
- "Synchronized"
- "ReentrantLock"
- "AQS"
- "volatile"
- "并发集合"
相关文章:
- "[[0_前置知识快速回顾]]"
- "[[1_并发理论基础]]"
- "[[5_特殊关键字的理解]]"
- "[[7_Volatile关键字的作用]]"
- "[[15_锁]]"
文章分类: "💻 编程语言"
文章路径: "02-💻 编程语言/01-☕ Java技术栈/02-📚 基础语法/2_Java复习笔记/11_并发、多线程/2_Java并发.md"
文章难度: 中级 🌳
目前阶段: ✅ 已完成
重要性: ⭐⭐⭐⭐ 核心能力
创建时间: 2024-08-11 18:15:12
修改时间: 2025-05-27 21:36:04
---

**学完并发之后回过头来看**

[JAVA并发 - 简书 (jianshu.com)](https://www.jianshu.com/p/4a81ef3ee2df)
## 1 死锁

### 1.1 死锁产生条件

1. 互斥条件：一个资源每次只能被一个线程使用。
2. 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。
4. 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。

> 在JAVA编程中，有3种典型的死锁类型：  
> 静态的锁顺序死锁，动态的锁顺序死锁，协作对象之问发生的死锁。

### 1.2 静态的锁顺序死锁

**原因：**

a和b两个方法都需要获得A锁和B锁。一个线程执行a方法且已经获得了A锁，在等待B锁；另一个线程执行了b方法且已经获得了B锁，在等待A锁。这种状态，就是发生了静态的锁顺序死锁。

```java
public class StaticLockOrderDeadLock {
        private final Object lockA =new Object();
        private final Object lockB =new Object();


        public void a(){
            synchronized (lockA){
                synchronized (lockB){
                    System.out.println("lockA");
                }
            }
        }

        public void b(){
            synchronized (lockB){
                synchronized (lockA){
                    System.out.println("lockB");
                }
            }
        }
    }
```

**解决办法：**

解决静态的锁顺序死锁的方法就是：所有需要多个锁的线程，都要以相同的顺序来获得锁。
### 1.3 动态的锁顺序死锁

### 1.4 协作对象之间发生的死锁

## 2 线程同步问题的产生和解决

### 2.1 问题的产生

### 2.2 Synchronized关键字

#### 2.2.1 简介

#### 2.2.2 原理

#### 2.2.3 使用场景

#### 2.2.4 总结

### 2.3 ReentrantLock锁

#### 2.3.1 简介

#### 2.3.2 Lock接口

#### 2.3.3 使用

#### 2.3.4 非公平锁的实现

#### 2.3.5 公平锁的实现

#### 2.3.6 重入锁的实现

#### 2.3.7 条件变量Condition

#### 2.3.8 总结

### 2.4 Synchronized和ReentrantLock比较

#### 2.4.1 区别

#### 2.4.2 在锁的相关概念上区别

#### 2.4.3 性能比较

### 2.5 锁的分类

#### 2.5.1 重入锁

#### 2.5.2 公平锁

#### 2.5.3 悲观锁

#### 2.5.4 乐观锁

### 2.6 CAS

#### 2.6.1 Java中通过锁和循环CAS的方式来实现原子操作

#### 2.6.2 CAS问题

### 2.7 AbstractQueueSynchronizer

#### 2.7.1 介绍

#### 2.7.2 用处

#### 2.7.3 同步器和锁

#### 2.7.4 独占模式和共享模式

#### 2.7.5 总结

## 3 线程间通信

### 3.1 两种方式

#### 3.1.1 wait/notify实现通信

#### 3.1.2 Condition实现通信

### 3.2 生成者与消费者

## 4 Volitile关键字

### 4.1 Java内存模型

### 4.2 并发编程三大概念

#### 4.2.1 原子性

#### 4.2.2 可见性

#### 4.2.3 有序性

### 4.3 Volitile的作用

#### 4.3.1 保证可见性

#### 4.3.2 不能保证原子性

#### 4.3.3 保证有序性

### 4.4 Volitile的原理

#### 4.4.1 可见性

#### 4.4.2 有序性

### 4.5 Volitile的应用场景

## 5 Java并发集合

### 5.1 ArrayBlockingQueue

#### 5.1.1 并发实现原理

#### 5.1.2 继承关系

### 5.2 LinkedBlockingQueue

#### 5.2.1 并发实现原理

#### 5.2.2 和ArrayBlockingQueue对比

### 5.3 ConcurrentHashMap

#### 5.3.1 实现原理

#### 5.3.2 特点




























































