---
文章标题: "[[5_类初始化的主动引用和被动引用]]" 
文章作者: Dakkk
文章概要: |
  文章详述JVM类初始化阶段，明确区分了导致类被初始化的五种“主动引用”情况（如new指令、反射调用、父类初始化、主类启动等），以及不会触发类初始化的三种“被动引用”场景（如子类引用父静态、数组定义、常量优化），是理解JVM类生命周期的核心内容。
tags:
- "JVM"
- "类加载"
- "类初始化"
- "主动引用"
- "被动引用"
- "Java虚拟机"
- "字节码"
相关文章:
- "[[2_Java代码编译和执行的整个过程]]"
- "[[2_Java基础之JVM]]"
- "[[1_基础概念与常识]]"
- "[[9_Java语法糖详解]]"
- "[[16_语法糖]]"
文章分类: "💻 编程语言"
文章路径: "02-💻 编程语言/01-☕ Java技术栈/05-💡 实用技巧/5_类初始化的主动引用和被动引用.md"
文章难度: 中级 🌳
目前阶段: ✅ 已完成
重要性: ⭐⭐⭐⭐ 核心能力
创建时间: 2024-08-11 18:15:12
修改时间: 2025-05-27 21:53:49
---


- 补充知识点，属于JVM的范畴内容

## 1 概述

- 类从被加载到虚拟机内存中开始，到卸载出内存为之，它的整个周期为：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using） 、卸载（Unloading） 7个阶段
- 其中验证、准备和解析3个部分统称为连接（Linking）


加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程  
必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定） 。

对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”（ 而加载、 验证、 准备自然需要在此之前开始）：


- `主动引用`
	1.  遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。
	2.  使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
	3.  当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
	4.  当虚拟机启动时，用户需要指定一个要执行的主类（ 包含main()方法的那个类），虚拟机会先初始化这个主类。
	5.  当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄， 并且这个方法句柄所对应的类没有进行过初始化， 则需要先触发其初始化。

这五种情况称为对一个类进行`主动引用`。其余情况都不会触发初始化，称为`被动引用`。

  - `被动引用`
	1. 子类引用父类的静态属性，只会除法子类的加载、父类的初始化，不会导致子类初始化
	2. 通过数组定义来引用类，不会触发此类的初始化
	3. 常量在编译阶段会进行常量优化，将常量存入**调用类**的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化