
## 1 RDB本质是什么？（问本质说本质，不要拖沓）

分析：
- 很多人被问到这个问题，都说一堆特性，其实回归到本质，RDB就是快照，存储的是二进制文件。

回答：
- RDB本身是`二进制式的快照`

## 2 如何开启/触发RDB（熟悉）

分析：
- 看你对RDB的熟悉程度，同时顺带考察你回答问题的完整性
- 提示：
	- 主从全量复制发送RDB文件
	- 主动FLUASHALL
- 这两个情况实际也会触发RDB，前者其实为了从节点复制内容，其实目的不是持久化
- 后者优点偏门，可以不主动说，主动说也许还会让人觉得这题你肯定背过

回答：
- RDB可以`通过配置定时触发`，触发时用的是后台持久化方式
- 也可以save命令，bgsaeve命令主动触发，save底层用的是阻塞式持久化，bgsave用的是后台持久化
- 实际生产中，很少会自己主动执行命令（这句话实力强点，有底气才说）
- 最后，Redis正常关闭，是会执行阻塞式持久化的。

## 3 RDB对主流程有什么影响？（比较了解）

分析：
- 主要从RDB的整个流程来寻找一些明显 或 潜在 的风险

回答：
- 当执行阻塞式持久化（save指令）的时候，有主进程进行RDB快照保存，会阻塞主进程
- 当执行后台持久化时，由fork出的子进程来进行RDB快照保存
	- 如果数据量比较大的时候，会`导致fork子进程这个操作比较耗时`，从而阻塞主进程
	- 由于采用了 `写时复制技术`，如果在进行RDB快照保存的时候，有`大量写入操作执行`，会导致`主进程多拷贝一份数据，消耗大量额外的内存`。

## 4 RDB执行流程是怎么样的？

分析：
- 核心是![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/20f2fc1fda93a00f4949880b79ae482e.png)
- 熟悉源码的话，另一种思路也可以将细一点，但是不见得有用，同时如果说得不清晰，反而减分

回答1（推荐，只讲核心，点到即止，有追问再说更多）：
- 首先，Fork出一个子进程来专门做RDB持久化
- 接着，子进程写数据到临时的RDB文件
- 最后，新的RDB文件替换旧的RDB文件

回答2（非常熟悉源码可以说，也能加一点分，效果看表述能力）：
- 打开一个临时的RDB文件（c语言库函数fopen）
- 将执行命令这一时刻数据库数据写入到IO缓存区（c语言库函数fwrite）
	- 会将这一时刻的数据，按照RDB对应的版本格式 进行写入
- 执行fflush（将IO缓冲区里的数据刷新到内核缓冲区）
- 执行fsync（可以将内核缓冲区里的数据刷到磁盘）
- 执行fclose（关闭这个临时文件）
- 修改临时文件名字，并让后台线程BIO_LAZY_FREE去删除旧的RDB（到此，一次RDB过程结束）
- 简单来说RDB的流程就是 触发RDB持久化时，让主进程或子进程（区分条件）来 将这一时刻的数据库数据写到一个新的RDB文件中
## 5 从源码看，RDB持久化什么时候会触发（有精力再学，基本不会这么考）

分析：
- 从源码来看，RDB持久化函数整体上再几个地方会被使用
	- Redis Shutdown（Redis关闭之前进行一次持久化）
	- 客户端发送save命令
	- 客户端发送bgsave命令
	- 每一次事件循环ServerCron检查是否需要bgsave（判断我们的RDB配置）
	- 主从全量复制发送RDB文件（也进行一次RDB持久化）
	- 客户端执行数据库情况命令FLUSHALL

- 虽然RDB的触发条件很多，但实际执行过程很简单，而区别点在于是子进程来执行 还是 主进程来执行这个流程
	- 打开一个临时的RDB文件（c语言库函数fopen）
	- 将执行命令这一时刻数据库数据写入到IO缓存区（c语言库函数fwrite）
		- 会将这一时刻的数据，按照RDB对应的版本格式 进行写入
	- 执行fflush（将IO缓冲区里的数据刷新到内核缓冲区）
	- 执行fsync（可以将内核缓冲区里的数据刷到磁盘）
	- 执行fclose（关闭这个临时文件）
	- 修改临时文件名字，并让后台线程BIO_LAZY_FREE去删除旧的RDB（到此，一次RDB过程结束）
	- 简单来说RDB的流程就是 触发RDB持久化时，让主进程或子进程（区分条件）来 将这一时刻的数据库数据写到一个新的RDB文件中


回答：
- 根据分析 理清楚RDB流程是怎样的，触发条件大致有哪些，酌情回答（无须细究源码，大概了解就行）
