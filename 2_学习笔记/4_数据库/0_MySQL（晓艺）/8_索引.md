
- `是SQL优化非常重要的手段，也是最主要的手段`

## 一、索引的概念

### 1.1 磁盘的相关知识

- `系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的`，位于同一个磁盘块中的数据会被一次性读取出来，InnoDB存储引擎中，`页`是其磁盘管理的最小单位，`默认16K`, 而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次读磁盘空间时都会`读若干地址连续磁盘块（总共大小16KB）`。

- 假设一行数据大小为16B，那么一次能1000行，如果表中有1000万行，那就要读1万次，耗费的时间将巨大。（一般一条sql耗时控制在100毫秒内）

- 要想提高查询效率，就得减少磁盘I/O次数，如何减少I/O次数呢，那就`需要快速定位数据记录的位置`。

### 1.2 索引是什么

​- MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构。可以简单理解为`排好序的快速查找的数据结构`。

- 索引这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。

- 一般来说索引本身也很大，不可能全部存储在内存中，因此`索引往往以索引文件的形式存储的磁盘上`。

### 1.3 索引优缺点

**优势：**

- 提高数据检索的效率，降低数据库的IO成本。（快）
- 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。（快）

**劣势：**

- 虽然索引大大提高了查询速度，同时却会`降低更新表的速度`，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要更新一下索引文件。
- 实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的。

## 二、Mysql 的索引结构

- Mysql默认`存储引擎InnoDB`就是用`B+Tree实现其索引结构`。

- B+Tree是一种`多路平衡查找树`。
	- 多路：一个节点可以有多个子节点
	- 平衡：任意的节点的所有子树高度差不大于1
	- 在B+Tree中，`所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上`，而非叶子节点上只存储primary key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。

- B+Tree特点：
	1.     `每个节点可以有多个子节点`----**矮从而减少IO次数--随机查找快**
	2.     `非叶子节点只存储键值信息`
	3.     页与页之间是`双向链表相连`，每页中`行数据是以单向链表相连`---利于范围查询
	4.     `数据记录都存放在叶子节点中`
	5. 注意的是，此处的叶子节点是索引读取数据的最小单位（页）

![[Pasted image 20230626222637.png]]

- 扩展知识点：
	- 三层B+树最多可索引多少行数据？
	- `指针占6个字节`，主`键为bigInt类型占8个字节`，假设每行数据约占1KB，
	- 一个页可以存放的（指针加键值）个数为$16*1024=16384/14=1170$个，所以共可以索引$1170*1170*16=21902400$行记录
- 所以，三次I/O即可找到我们需要的数据
  

## 三、 聚簇索引和非聚簇索引

- `聚簇索引（一般是主键索引）`：数据行和索引主键值存储在一起，即索引结构B+树叶子节点`既存储主键值和数据行`

- `非聚簇索引`：数据行和索引主键值不存储在一起，即索引结构B+树叶子节点`只存储索引字段值和主键值，不存储数据行`

![[Pasted image 20230626222716.png]]

- `聚簇索引的好处`：
	1. 数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此<font color="#d83931">从聚簇索引中获取数据比非聚簇索引更快</font>
	2. 聚簇索引对于主键的排序查找和范围查找速度非常快

- `聚簇索引的限制`：
	1. 对于 mysql 数据库目前只有 innodb 数据引擎支持聚簇索引，而 Myisam 并不支持聚簇索引。
	2. 由于数据物理存储排序方式只能有一种，所以`每个 Mysql的表只能有一个聚簇索引`。一般情况下就是`该表的主键`。

- `注意`：
	- 为了充分利用聚簇索引的聚簇的特性，所以 innodb 表的`主键列尽量选用有序的id`，而不建议用无序的 id，比如 uuid 这种。（乱序键值的插入可能会造成B+树的拆分，即页分裂，从而导致数据存储不连续）

  
## 四、 Mysql 索引分类

### 4.1 主键索引

- 概念：设定为主键后数据库会自动建立索引，innodb为聚簇索引

- 随表一起建索引

```mysql
CREATE TABLE customer(
id INT(10) UNSIGNED AUTO_INCREMENT ,
customer_no VARCHAR(200),
customer_name VARCHAR(200),
PRIMARY KEY(id)
);
```

- 单独建主键索引：

```mysql
ALTER TABLE customer add PRIMARY KEY customer(customer_no);
```

- 删除建主键索引：

```mysql
ALTER TABLE customer drop PRIMARY KEY;
#注意删除有自增的主键索引，要先删除自增！！！
```

- 修改建主键索引：
	- 必须先删除掉(drop)原索引，再新建(add)索引

### 4.2  普通索引

- 概念：即一个索引只包含单个列，一个表可以有多个普通索引语法：
- `可以不唯一，也可以是null`

- 随表一起创建：

```mysql
CREATE TABLE customer
VARCHAR(200),
PRIMARY KEY(id),
KEY (customer_name)
);
```

- 单独建单值索引：

```mysql
CREATE INDEX idx_customer_name ON customer(customer_name);

alter table customer add index mycu(customer_no);
```

### 4.3 唯一索引

- 概念：索引列的值必须唯一，但允许有空值

- 随表一起创建

```mysql
CREATE TABLE customer    (
id  INT(10) UNSIGNED AUTO_INCREMENT      ,
customer_no VARCHAR(200),
customer_name  VARCHAR(200), 
PRIMARY KEY(id),                     
UNIQUE (customer_no)                                    
);  
```

- 单独建唯一索引：

```mysql
CREATE UNIQUE index idx_customer_no  ON  customer (customer_no);

Alter Table customer add unique myunique(customer_no);
```

 
### 4.4 联合索引

- 概念：即一个索引包含多个列

- 随表一起建索引：

```mysql
CREATE TABLE customer (
id INT(10) UNSIGNED AUTO_INCREMENT ,
customer_noVARCHAR(200),
customer_name VARCHAR(200),
PRIMARY KEY(id),
KEY (customer_name),
UNIQUE (customer_name),
KEY (customer_no,customer_name)                       

);    
```

- 单独建索引：

```mysql
CREATE INDEX idx_no_name ON customer(customer_no,customer_name);
```

- `联合索引的最左匹配原则：`
	- `首先根据联合索引中最左边的、也就是第一个字段进行排序，在第一个字段排序的基础上，再对联合索引中后面的第二个字段进行排序，依此类推`

	- 示例：在t表创建了联合索引（a,b,c），相当于创建了(a),(a,b),(a,b,c) 三个索引。

![[Pasted image 20230626234734.png]]

- 其中WHERE b = ‘123’ ， 此联合索引不会起作用！！！

### 4.5 基本语法

```mysql
#创建     
CREATE [UNIQUE] INDEX [indexName] ON TABLE_NAME (column))

#删除
DROP INDEX [indexName] ON mytable;

#查看
SHOW INDEX FROM TABLE_NAME\G

#也可以使用ALTER来添加索引

ALTER TABLE TABLE_NAME ADD PRIMARY KEY (column_list) : 
#该语句添加一个主键，这意味着索引值必须是唯一的，且不能为 NULL。

ALTER TABLE TABLE_NAME ADD INDEX index_name (column_list)
#添加普通索引，索引值可出现多次。

ALTER TABLE TABLE_NAME ADD UINQUE INDEX index_name(column_list)
#添加唯一索引。

ALTER  TABLE  TABLE_NAME  DROP  PRIMARY  KEY; 
#删除主键，之前先删除自增属性，AlTER 
TABLE TABLE_NAME  MODIFY COLUMN id INT;
```

## 五、索引的创建时机

### 5.1 适合创建索引的情况

1. `主键自动建立唯一索引`；

2. `频繁作为查询条件的字段`应该创建索引

3. `查询中排序的字段`，排序字段若通过索引去访问将大大提高排序速度

- 举例:使用vote_record表，有几百万条数据
```mysql
#uesr_id有普通索引
SELECT * FROM vote_record WHERE user_id = 'WaPtJ4Ywy0cRwRy4weqh'; #0.014s
SELECT * FROM vote_record ORDER BY user_id LIMIT 100;		#0.032s

#user_id没有普通索引
SELECT * FROM vote_record WHERE user_id = 'WaPtJ4Ywy0cRwRy4weqh'; #1.916s
SELECT * FROM vote_record ORDER BY user_id LIMIT 100;		#2.119s
```

### 5.2 不适合创建索引的情况

1. `表记录太少`

2. `经常增删改的表或者字段`

3. `Where 条件里用不到的字段`不创建索引

4. `过滤性不好的字段`不适合建索引

### 5.3 explain关键字

- explain 是用来分析 SELECT 查询语句的，可以观察索引是否被使用到。

```mysql
EXPLAIN SELECT * FROM tb_student
```

![[Pasted image 20230626222834.png]]

- 重点关注字段：

	- `type`：访问类型，要是显示 ALL ，那你可要小心了，这是全表扫描的意思，性能最差，说明你的查询有很大的优化余地，如果显示的是 index ，说明会使用索引来优化查询。

![[Pasted image 20230626222843.png]]

- `key`：具体使用的索引名，这里没有。

- `rows`：扫描的行数。

### 5.4 索引失效的场景

1. 如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)。要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引

2. 对于联合索引，不是使用的第一部分，则不会使用索引`（靠左原则）`

3. like查询以%开头的列索引会失效

4. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引

5. 不等于(！= ，<> )，EXISTS，not in，is  not null等会导致索引失效（订正，视频中课件此处有点错误，以本条为准，>和<不会导致索引失效）

6. 如果mysql估计使用全表扫描要比使用索引快,则不使用索引