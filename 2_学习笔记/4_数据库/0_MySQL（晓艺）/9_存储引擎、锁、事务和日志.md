第9课时--存储引擎、锁、事务和日志

## 一、存储引擎

### 1.1  mysql架构

![[Pasted image 20230627012903.png]]

### 1.2 存储引擎分类

- `Myisam`   内置计数器，count()特别快，不支持事务，支持表锁

- `Innodb`   支持事务，支持表锁和行锁，支持MVCC（多版本并发控制）

## 二、事务

### 2.1 事务的概念：

- 一个或一组sql语句组成一个执行单元，`这个执行单元要么全部执行，要么全部不执行`。

- `为什么要用事务呢？`

- `案例：转账`

	1. 小明账户余额  1000
	
	2. 小芳账户余额   1000
	
	3. 小明给小芳转500元，正常情况下需要执行sql1和sql2
	
	4. sql1 :  update 表 set 小明的余额=500 where name='小明'
	
	5. `执行完sql1还没来得及执行sql2，发生错误或服务器宕机`，
	
	6. sql2  : update 表 set 小芳的余额=1500 where name='小芳'
	
	7. 此时的结果就变成了
	
	8. 小明账户余额  500
	
	9. 小芳账户余额     1000
	
	10. `少了500去哪里了？`
	
	11. `为了解决这个问题，就要用到事务，将sql1和sql2放在同一个事务中，要么全部成功，要么全部失败`

### 2.2 事务的特性：

- `ACID`
	- `原子性（Atomic）`：一个事务不可再分割，要么都执行要么都不执行
	- `一致性(consistence)`：一个事务执行会使数据从一个一致状态切换到另外一个一致状态
	- `隔离性(isolation)`：一个事务的执行不受其他事务的干扰
	- `持久性(durability)`：一个事务一旦提交，则会永久的改变数据库的数据.

### 2.3 事务的操作

- 事务是`默认开启`并且`自动提交`的

- 比如select、insert、update、delete语句，一条语句执行开始前会开启事务，语句执行完就会结束事务。

```mysql
#1.开始事务
#2.执行sql
DELETE FROM account WHERE id = 2;
#3.结束事务
```

- `那如何才能把多条sql语句放在一个事务里呢？`
	- 我们也可以显示的开启事务和结束事务。

```mysql
#步骤1：开启事务
	#方式一：设置当前会话自动提交功能为禁用（autocommit默认为1表示自动提交）
set autocommit=0;
#查看mysql事务自动提交状态。
SHOW VARIABLES LIKE 'autocommit'

	#方式二：执行开启事务语句
start transaction或begin

#步骤2：编写事务中的sql语句(select insert update delete)

语句1;
语句2;
...

#步骤3：结束事务
commit;提交事务
rollback;回滚事务


#步骤1
SET autocommit = 0;
SHOW VARIABLES LIKE 'autocommit';
#步骤2
DELETE FROM account WHERE id = 2;
DELETE FROM account WHERE id = 3;
#步骤3
COMMIT #提交事务，此时不可以回滚
ROLLBACK #回滚初始状态

#步骤1
SET autocommit = 1;
SHOW VARIABLES LIKE 'autocommit';


BEGIN;
DELETE FROM account WHERE id = 2;
DELETE FROM account WHERE id = 3;
COMMIT #提交事务，此时不可以回滚
ROLLBACK #回滚初始状态
```

### 2.4 常见的几种读现象：

- `脏读`就是指`事务A读取到了另外一个事务B修改后但未提交的数据`，因为事务B可能回滚，所以这个数据是不准确的。

- `不可重复读`是指在事务A内，按照同样的查询条件，`两次读到的数据内容不一样`，因此称为是不可重复读（原因是其它事务`修改了`符合条件的数据）。

- `幻读`是指在事务A内，按照同样的查询条件，`两次读到的数据条目不一样`，因此称为幻读（原因是其它事务`新增或删除了`符合条件的数据）。

- **为避免上述现象，mysql可以设置为不同的隔离级别**

### 2.5 事务的隔离级别：

| |脏读|不可重复读|幻读|
|--|--|--|--|
|read uncommitted（未提交读）：|√|√|√|
|read committed（提交读）： |×|√|√|
|repeatable read（可重复读）：|×|×|×|
|serializable（串行化）:|×|×|×|

- mysql中默认隔离级别 `repeatable read`
- 查看隔离级别
- select @@transaction_isolation;
- 设置当前会话隔离级别
- `set session transaction isolation level 隔离级别;`

- `注意`
	- 事务是在多个会话是存在隔离级别，假设有两个会话，他们的事务分别是A和B
		- 未提交读：那么B事务即使没有提交的任何操作，都会影响到A事务
		- 提交读：B事务没有提交的任何操作，都不会影响到A事务（不会脏读），但是如果B事务提交了任何操作，就会影响到A事务（会不可重复度和幻读）；
		- 可重复读和串行化：B事务提交的任何操作，都不会影响到A事务

## 三、锁（基于Innodb引擎）

- 锁其实就是对资源使用制定的一种规则

- 从粒度来分可以分为`表锁、行锁`

- 从排他性角度来分可以分为`读锁（共享锁）、写锁（排他锁）`

- 读锁和写锁的共存关系

|   |   |   |
|---|---|---|
|A事务       B事务|读锁|写锁|
|读锁|√|X|
|写锁|X|X|

- √表示同时存在，X表示不能同时存在。

- 举例：

- 某记录被A事务加上了读锁，其他事务还可以再对该记录加读锁，但是不能再加写锁。（注意：`A事务可以对该事务继续加写锁`）
- 某记录被A事务加上了写锁，其他事务不可以再对该记录加读锁或写锁。（注意：A事务可以对该事务继续加读锁）

### 3.1  表锁

锁住整张表

```mysql
#加读锁
LOCK TABLES 表名 READ;

#加写锁
LOCK TABLES 表 WRITE;

#解锁：
UNLOCK TABLES;
```

- 注意：LOCK TABLES 表 WRITE; 给表加上写锁后，会阻塞其它事务对该表的的读和写，包括非锁定读，这个机制和下文的for update对表加的写锁不一样，后者不会阻塞其它事务的非锁定读，特此说明！

### 3.2 行锁、间隙锁

（1）`Record Lock`: 行锁，加在行记录本身的锁

（2）`Gap Lock`:间隙锁，锁定一个范围，但不包含记录本身

（3）Next-Key Lock  :Gap Lock+Record Lock 锁定记录本身，并锁定一定范围

- 注意：
	- mysql默认会对增删改操作加写锁，对读不加锁（`仅在serializable隔离级别会加读锁`），但是我们对读操作可以显示的加读锁或写锁
	- 如果一个事务在读的时候显示的加上了读锁，那么另外一个事务就无法进行增删改操作，因为增删改操作默认增加写锁！！！
	- 在串行化隔离级别时，如果一个事务是查询操作，那么另外一个事务也无法进行增删改操作，因为在此级别下，查询操作默认增加读锁；

```mysql
Select * from t  where id =1  FOR  UPDATE; 加写锁

Select * from t  where id =1   LOCK IN SHARE MODE;加读锁
```

- `写操作自动添加写锁，不需要显示加锁；`

```mysql
Delete from t  where id =1   (默认已经加了写锁)
```

- `问题？`
- `我们的操作什么时候会是表锁？什么时候是行锁？`

通过索引操作数据的时候，因为<font color="#d83931">通过索引可以找到具体的行，这个时候加的是行锁</font>，如果<font color="#d83931">没有通过索引去操作</font>，那么可能操作的范围不确定，为了保证数据的安全，<font color="#d83931">这个时候会使用表锁</font>

- 以下sql语句都会使用表锁：

```mysql
Select * from t  FOR  UPDATE;

Select * from t  LOCK IN SHARE MODE

Select * from t  where name =`sds`  FOR  UPDATE;

Select * from t  where name =`sds`  LOCK IN SHARE MODE
```

### 3.3 进阶知识点： 

- 可重复读隔离级别下，不同筛选字段下的加锁情况

1、筛选字段是`唯一索引`情况下，如果`命中索引`，A事务的`增删改和锁定读`会阻塞B事务对共同操作记录的增删改，但是不阻塞B事务的非锁定读。--即`只有行锁`

A事务：select * from t where id =2 FOR UPDATE;

B事务：delete from t where id =2；阻塞

B事务：select * from t where id =2  FOR  UPDATE;阻塞

B事务：select * from t where id =2 LOCK IN SHARE MODE;阻塞

B事务：select * from t where id =2；不阻塞

注意：`如果A事务的锁定读是读锁，不会阻塞B事务以读锁的方式锁定读。`

2、筛选字段是`唯一索引`情况下，如果`未命中索引`，A事务的增删改和锁定读会阻塞B事务对该筛选字段所在间隙的的`插入操作`（间隙的范围是从该筛选值的上一个键值到下一个键值）--`即只有间隙锁`

id - [1,2,6,7,9]  间隙锁范围为[2,6]

A事务：select * from t where id =4  FOR  UPDATE; 不阻塞

B事务：delete from t where id =3；不阻塞

B事务：select * from t where id =3  FOR  UPDATE; 不阻塞

B事务：select * from t where id =3 LOCK IN SHARE MODE; 不阻塞

B事务：select * from t where id =3；不阻塞

3、筛选字段是`非唯一索引`下，如果`命中索引`，A事务的增删改和锁定读会阻塞B事务对`共同操作记录的增删改`及对`该筛选字段所在间隙的插入操作`，但是不阻塞B事务的非锁定读。（间隙的范围是从该筛选值的上一个键值到下一个键值）--`即有行锁和间隙锁`

uid - [1,3,7,10,13]  间隙锁范围为[3,10]  行锁为 7

A事务：select * from t where uid =7 FOR  UPDATE;

B事务：delete from t where uid =7；阻塞

B事务：select * from t where uid =7  FOR  UPDATE;阻塞

B事务：select * from t where uid =7 LOCK IN SHARE MODE;阻塞

B事务：insert into t values (8,5,'sds');阻塞

B事务：insert into t values (8,9,'sds');阻塞

B事务：select * from t where uid =4；不阻塞

4、筛选字段是`非唯一索引`下，如果`未命中索引`，A事务的增删改和锁定读会阻塞B事务对该筛选字段所在间隙的插入操作，但是不阻塞B事务的非锁定读。（间隙的范围是从该筛选值的上一个键值到下一个键值）--`即只有间隙锁`

uid - [1,3,7,10,13]  间隙锁范围为[3,7] 

A事务：select * from t where uid =5 FOR  UPDATE;

B事务：insert into t values (10,5,'sds');阻塞

B事务：：insert into t values (11,4,'sds');阻塞

B事务：insert into t values (12,6,'sds');阻塞

B事务：select * from t where uid =3；不阻塞

5、筛选字段是`非索引下`，A事务的增删改会阻塞B事务对整张表的的增删改。A事务的显示读锁会阻塞B事务对整张表的的增删改。--`即表锁`

- `总结：什么时候会出现间隙锁？`

1、在筛选字段是`唯一索引下，如果未命中，会锁住`从该筛选值的上一个键值到下一个键值的范围

2、在筛选字段是`非唯一索引下，不管命不命中，会锁住从该筛选值的上一个键值到下一个键值`（如果命中，间隙锁不包括该该行，但是命中的行会被加上行锁）的范围

`间隙锁的作用：阻止该范围内插入新数据`

### 3.4 MVCC（多版本并发控制）

#### 3.4.1 一些概念和定义

- 事务的隔离级别依赖锁，但是不完全依赖于锁。

- innodb存储引擎在RR和RC隔离级别不是简单的采用锁，还同时实现了MVCC（多版本并发控制）

- 目的：为了`避免加锁导致读写阻塞，提升并发性能`
- MVCC的实现依赖于：`隐藏字段、Undo log(版本链)、Read View`

- 原理：
	- InnoDB 会在每行记录后面`增加三个隐藏字段`： 
		- DB_ROW_ID：`行号`，随着插入新行而单调递增，如果有主键，则不会包含该列。
		- DB_TRX_ID：记录插入或更新该行的事务的`事务ID`
		- DB_ROLL_PTR：`回滚指针`，指向 undo log 记录，即上一个版本。



![](https://image-for.oss-cn-guangzhou.aliyuncs.com/for-obsidian/Java_Study/2_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_Java%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83/1_Java%E5%9F%BA%E7%A1%80/1_Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230922073653331.png)



- 随着不同的事务的操作,该行记录可能有不同的版本

![](https://image-for.oss-cn-guangzhou.aliyuncs.com/for-obsidian/Java_Study/2_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_Java%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83/1_Java%E5%9F%BA%E7%A1%80/1_Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230922073655532.png)



- 行记录不同的版本会被链接成一个链表----`版本链`

- `注意：事务的id，在读的操作下为0，在增删改的操作下，是大于所有活跃事务的`

#### 3.4.2 RR级别

- 只在事务开始时生成一次ReadView（记录当前活跃的事务id），之后一直使用该ReadView;

![](https://image-for.oss-cn-guangzhou.aliyuncs.com/for-obsidian/Java_Study/2_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_Java%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83/1_Java%E5%9F%BA%E7%A1%80/1_Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230922073657835.png)



1. 如果`当前的事务ID是数据事务id`，是可见的；
2. 如果`当前的事务id小于当前readview中的最小事务id`，表示生成该版本的事务在当前事务生成readview前已经提交了，是可以访问的
3. 如果当前的`事务id大于当前readview中的最大事务id`，表示生成该版本的事务在当前生成readview后才开启，所以该版本不可以被当前事务访问
4. 如果`当前的事务id在readview最大和最小事务id之间`
	1. `如果在`，说明创建readview时，生成该版本的事务还是活跃的，`不可以访问`
	2. `如果不在`，说明创建readview时，生成该版本的事务已经提交了，所以`可以被访问`

#### 3.4.3 RC级别

每次查询都会生成一次ReadView（记录当前活跃的事务id）

（1）、如果数据的事务ID是当前事务，是可见的；

（2）、如果数据的事务ID不存在于ReadView中，说明该事务已经提交，是可见的；

（3）、如果数据的事务ID存在于ReadView中，说明该事务未提交，是不可见的；

#### 3.4. 4 快照读和当前读

- `快照读：普通的select就是快照读`

例子：t表原有2条数据

A事务：Select  *  from t; 能看到2条数据

B事务：往 t表插入1条数据

A事务：Select  *  from t ; 能看到2条数据

当前读：

- `读取数据的最新的版本`，常见的delete，insert，update，还有select for update，select in share mode都是当前读；

例子：t表原有2条数据

A事务：Select  *  from t; 能看到2条数据

B事务：往 t表插入1条数据

A事务：Select  *  from t  for update; 能看到3条数据

### 3.5 MVCC举例说明

- 假设现在student表中只有一条由`事务id为8`的事务插入的一条记录；
![](https://image-for.oss-cn-guangzhou.aliyuncs.com/for-obsidian/Java_Study/2_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_Java%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83/1_Java%E5%9F%BA%E7%A1%80/1_Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230922073701571.png)



- MVCC只能在 READ COMMITTER 和 REPEATABLE READ 两个隔离级别下工作。接下来看下一下他们两删除ReadView的时机不同到底不同在哪里。

#### 3.5.1 READ COMMITTED

- `READ COMMITTED 每次读取数据前都生成一个ReadView`
- 现在又两个`事物id`分别为`10、20`的事务在执行
```mysql
# Transaction 10
BEGIN;
UPDATE student SET name="李四"WHERE id=1:
UPDATE student SET name=”王TE” WHERE id=1;

# Transaction 20
BEGIN;
#更新了一些别的表的记录
....
```

>说明：事务执行过程中，只有在第一次真正修改记录时（比如使用INSERT、DELETE、UPDATE语句），才会被分配一个单独的事务id，这个事务i是递增的。所以我们才在事务2中更新一些别的表的记录，目的是让它分配事务id。

- 此时，表student中id为1的记录得到的版本链如下所示：
![](https://image-for.oss-cn-guangzhou.aliyuncs.com/for-obsidian/Java_Study/2_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_Java%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83/1_Java%E5%9F%BA%E7%A1%80/1_Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230922073708653.png)



- 假设现在有一个使用READ COMMITTED隔离级别的事务开始执行：
```mysql
# 使用READ COMMITTEDM离级别的事务
BEGIN:
#SELECT1:Transaction10、20未提交
SELECT +FROM student WHERE id = 1；#得到的列name的值为‘张三'
```

- 这个`SELECT1`的执行过程如下：
	- 步骤1：在执行`SELECT`语句时会先生成一个`ReadView`，ReadView的trx_ids列表的内容就是`[10,20]`，up_limit_id为10,`low_limit_id为21`,`creator_trx_id为0`.

	- 步骤2：从版本链中挑选可见的记录，从图中看出，最新版本的name的内容是‘王五，该版本的trx_id值10,在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。

	- 步骤3：下一个版本的列name的内容是‘李四，该版本的trx_id值也为10，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本。

	- 步骤4:下一个版本的列name的内容是‘张三'，该版本的trx_id值为8,小于ReadView中的up_limit_id值10，所以这个版本是符合要求的，`最后返回给用户的版本就是这条列name为‘张三’的记录。`

- 之后，我们把事务id为10的事务提交一下：
```mysql
# Transaction 10
BEGIN:
UPDATE student SET name="李四"WHERE id=1;
UPDATE student SET name="王五" WHERE id=1;
COMMIT:
```

- 然后再到事务id为20的事务中更新一下表student中id为1的记录：
```mysql
# Transaction 20
BEGIN;
#更新了一些别的表的记录
UPDATE student SET name="钱七" WHERE id=1;
UPDATE student SET name="宋八" WHERE id=1;
```

- 此刻，表student中id为1的记录的版本链就长这样：
![](https://image-for.oss-cn-guangzhou.aliyuncs.com/for-obsidian/Java_Study/2_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_Java%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83/1_Java%E5%9F%BA%E7%A1%80/1_Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230922073715042.png)



这个`SELECT1`的执行过程如下：
	- 步骤1：在执行`SELECT`语句时会先生成一个`ReadView`，ReadView的trx_ids列表的内容就是`[20]`，up_limit_id为20,`low_limit_id为21`,`creator_trx_id为0`.
- 步骤2：从版本链中挑选可见的记录，从图中看出，最新版本的name的内容是‘宋八，该版本的trx_id值20,在trx_ids列表内，所以不符合可见性要求，根据roll_pointer跳到下一个版本。
- 步骤3：下一个版本的列name的内容是‘钱七，该版本的trx_id值也为20，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本。
- 步骤4:下一个版本的列name的内容是‘王五'，该版本的trx_id值为10,小于ReadView中的up_limit_id值20，所以这个版本是符合要求的，`最后返回给用户的版本就是这条列name为‘王五'的记录。`

#### 3.5.2 REPEATABLE READ

- 使用REPEATABLE READ隔离级别的事务来说，`只会在第一次执行查询语句时生成一个ReadView`，之后的查询就不会重复生成了。
- 比如，系统里有两个事务id分别为10、20的事务在执行：
```mysql
# Transaction 10
BEGIN;
UPDATE student SET name="李四"WHERE id=1;
UPDATE student SET name="王五"WHERE Id=1;

# Transaction 20
BEGIN;
#更新了一些别的表的记录
```
- 此刻，表student 中id为1的记录得到的版本链表如下所示：
![](https://image-for.oss-cn-guangzhou.aliyuncs.com/for-obsidian/Java_Study/2_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_Java%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83/1_Java%E5%9F%BA%E7%A1%80/1_Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20230922073740067.png)



- 假设事务10和事务20未提交
- 此时readview [10,20] 新事务的select读的是‘张三’
- 假设事务10已经提交，事务20未提交
- 此时readview[10,20]，新事务的select读的还是‘张三’

#### 3.5.3 如何解决幻读


## 四、日志

- 日志本身也是一种文件，mysql是`先写日志再写磁盘`

- 日志空间`缓存在内存`中

### 4.1 二进制日志（bin log） 

- 记录数据库的`所有变化`，可以用来复制传输（`mysql主从复制`---主服务器上的数据同步到子服务器上）

### 4.2  错误日志（error log）

- `记录错误信息`

### 4.3 慢查询日志（slow log）

- `记录查询超过指定时间`的日志

### 4.4  重做日志（redo log）★

- 事务核心日志，`前滚功能`，记录数据`修改之后的值`

### 4.5 回滚日志（undo log）★

- 事务核心日志，`回滚功能`，记录事务数据`修改前的状态`

- `一条更新语句执行的顺序`

```mysql
update test set name=`Neymar` ,age=29  where id=7;
```

a)   `执行器先找引擎取 id=7这一行`。id 是主键，引擎直接用树搜索找到这一行。如果 id=7 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存。

b)  `执行器拿到引擎给的行数据，进行修改，得到新的一行数据`，再调用引擎接口写入这行新数据。

c)   引擎将这行新数据`更新到内存中`，同时将这个`更新操作记录到 redo log 里面`，`在undo log中记录该修改前得数据`，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。

d)  如果此时`rollback，则根据undo log中记录回滚数据`。如果此时`commit，进行后续操作`。

e)   执行器`生成这个操作的 binlog，并把 binlog 写入磁盘`。

f)    执行器调用引擎的提交事务接口，引擎`把刚刚写入的 redo log 改成提交（commit）状态，更新完成`。

- 注意：
	- 在e步骤的时候，可能发生故障，导致磁盘上没有写入数据
	- 这个时候redo log可以起到`修复数据的作用`
	- 因为在MySQL服务重启的时候，会检查redo log有哪些没有同步到磁盘上的，就会重写同步到磁盘上