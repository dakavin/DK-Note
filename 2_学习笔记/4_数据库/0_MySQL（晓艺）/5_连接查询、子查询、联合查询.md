

## 一、连接查询

### 1.1 按功能分类：

- 内连接：where/inner join

- 左连接（左外连接）：left  join on / left  outer join on

- 右连接（右外连接）：right  join on / right  outer join on

- 全连接：union

### 1.2 内连接

```mysql
#where

语句：select * from a_table , b_table where a.a_id = b.b_id;

#inner  join   on

语句：select * from a_table a inner join b_table b on a.a_id = b.b_id;
```

说明：组合两个表中的记录，返回关联字段相符的记录，也就是返回两个表的交集（阴影）部分。



Boy表



Girl表


```mysql
SELECT boy.hid,boy.bname,girl.gname FROM boy INNER JOIN girl ON girl.hid = boy.hid;
```



- `注意：如果内连接没有筛选条件，则查询结果为两表的笛卡尔乘积。`

- `内连接有一个特殊情况---自连接`

```mysql
案例2：查询employees表中员工名和上级的名称

SELECT e.employee_id,e.last_name,m.employee_id,m.last_name

FROM employees e,employees m

WHERE e.`manager_id`=m.`employee_id`;
```

### 1.3 左连接  

```mysql
SELECT  * 
FROM a_table a left join b_table b 
ON a.a_id = b.b_id;
```

说明： left join 是left outer join的简写，它的全称是左外连接，是外连接中的一种。 左(外)连接，左表(a_table)的记录将会全部表示出来，而右表(b_table)只会显示符合搜索条件的记录。右表记录不足的地方均为NULL。



```mysql
SELECT boy.hid,boy.bname,girl.gname 
FROM boy LEFT JOIN girl 
ON girl.hid = boy.hid;
```
### 1.4 右连接  

```mysql
SELECT  * 
FROM a_table a right outer join b_table b 
on a.a_id = b.b_id;
```

说明：right join是right outer join的简写，它的全称是右外连接，是外连接中的一种。与左(外)连接相反，右(外)连接，左表(a_table)只会显示符合搜索条件的记录，而右表(b_table)的记录将会全部表示出来。左表记录不足的地方均为NULL。



```mysql
SELECT boy.hid,boy.bname,girl.gname 
FROM boy RIGHT JOIN girl 
ON girl.hid = boy.hid;
```

提高点：经典7种join查询



### 1.5 全连接

```mysql
(select colum1,colum2...columN from tableA ) 
union #去除重复项
(select colum1,colum2...columN from tableB )

或 

(select colum1,colum2...columN from tableA ) 
union all #不去除重复项
(select colum1,colum2...columN from tableB )；
```

a表



b表



```mysql
(SELECT id,num FROM a) UNION (SELECT id,num FROM b)

(SELECT id,num FROM a) UNION ALL(SELECT id,num FROM b)
```

## 二、子查询

- 子查询就是指的在一个完整的查询语句之中，嵌套若干个不同功能的小查询

### 2.1 where或having后面

`案例1：谁的工资比 Adam高?`

```mysql
#查询Adam的工资

SELECT salary
FROM employees
WHERE last_name = 'Adam'

#查询员工的信息，满足 salary大于上述结果

SELECT *
FROM employees
WHERE salary>(
      SELECT salary
      FROM employees
      WHERE last_name = 'Adam'
);
```

`案例2：查询最低工资大于(50号部门最低工资)的部门id和其最低工资`

```mysql
#①查询50号部门的最低工资
SELECT  MIN(salary)
FROM employees
WHERE department_id = 50

#②查询每个部门的最低工资
SELECT MIN(salary),department_id
FROM employees
GROUP BY department_id

#③ 在②基础上筛选，满足min(salary)>①
SELECT MIN(salary),department_id
FROM employees
GROUP BY department_id
HAVING MIN(salary)>(
      SELECT  MIN(salary)
      FROM employees
      WHERE department_id = 50
);
```

### 2.2 select后面

案例：查询每个部门的员工个数

```mysql
SELECT d.*,(
      SELECT COUNT(*)
      FROM employees e
      WHERE e.department_id = d.`department_id` ) 个数
 FROM departments d;
```

### 2.3 from后面

- 将子查询结果充当一张表，要求必须起别名

案例：查询每个部门的平均工资的工资等级

```mysql
#①查询每个部门的平均工资

SELECT AVG(salary),department_id
FROM employees
GROUP BY department_id

SELECT * FROM grade;

#②连接①的结果集和grade表，筛选条件平均工资 between lowest_sal and highest_sal

SELECT  ag_dep.*,g.`grade_level`
FROM (
      SELECT AVG(salary) ag,department_id
      FROM employees
      GROUP BY department_id
) ag_dep   INNER JOIN grade g
ON ag_dep.ag BETWEEN lowest_sal AND highest_sal;
```

### 2.4  IN 、ANY、ALL后面

- In (数据列)  ：括号里的值提供给外层查询语句比较操作

案例：查询有员工的部门名

```mysql
SELECT department_name
FROM departments d
WHERE d.`department_id` IN(
      SELECT department_id
      FROM employees
)
```


- 比较运算符 +  ANY ( )  ：括号里的值提供给外层查询语句比较操作

案例：查询其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary
```mysql

#①查询job_id为‘IT_PROG’部门任一工资
SELECT DISTINCT salary
FROM employees
WHERE job_id = 'IT_PROG'

#②查询员工号、姓名、job_id 以及salary，salary<(①)的任意一个
SELECT last_name,employee_id,job_id,salary
FROM employees
WHERE salary<ANY(
      SELECT DISTINCT salary
      FROM employees
      WHERE job_id = 'IT_PROG'
) AND job_id<>'IT_PROG';
```


- 比较运算符 +  ALL ( )  ：括号里的值提供给外层查询语句比较操作
- 与ANY 不同需要满足所有的字段

案例：返回其它部门中比job_id为‘IT_PROG’部门所有工资都低的员工的员工号、姓名、job_id 以及salary

```mysql
SELECT last_name,employee_id,job_id,salary
FROM employees
WHERE salary<ALL(
      SELECT DISTINCT salary
      FROM employees
      WHERE job_id = 'IT_PROG'
) AND job_id<>'IT_PROG';
```

##  三、分页查询

- 应用场景：当要显示的数据，一页显示不全，需要分页提交sql请求

### 3.1 语法：

```mysql
select 查询列表
      from 表1
      【join type join 表2
      on 连接条件
      where 筛选条件
      group by 分组字段
      having 分组后的筛选
      order by 排序的字段】
      limit 【offset,】size;
      offset要显示条目的起始索引（起始索引从0开始）
      size 要显示的条目个数
```

### 3.2 特点：

- limit语句放在查询语句的最后

- 公式

```mysql
#要显示的页数 page，每页的条目数size

select 查询列表
from 表
limit  (page-1)*size,  size;

size=10
page  offset
1        0
2        10
3        20
```

### 3.3 案例

案例1：查询前五条员工信息

```mysql
SELECT * FROM  employees LIMIT 0,5;

SELECT * FROM  employees LIMIT 5;
```

案例2：查询第11条——第25条

```mysql
SELECT * FROM  employees LIMIT 10,15;
```

案例3：查询有奖金的员工信息，并且工资较高的前10名

```mysql
SELECT  *
FROM
    employees
WHERE commission_pct IS NOT NULL
ORDER BY salary DESC
LIMIT 10 ;
```

  
## 四、SQL执行顺序

```mysql
(7) SELECT (8)DISTINCT<select_list>

(1) FROM <left_table>

(3) <join_type> JOIN <right_table>

(2) ON <join_condition>

(4) WHERE <where_condition>

(5) GROUP BY <group_by_list>

(6) HAVING <having_condition>

(9) ORDER BY <order_by_list>

(10) LIMIT <limit_number>
```

解析：

(1) FROM:对FROM子句中的左表`<left_table>`和右表`<right_table>`执行笛卡儿积，产生虚拟表VT1;
(2) ON: 对虚拟表VT1进行ON筛选，只有那些符合`<join_condition>`的行才被插入虚拟表VT2;
(3) JOIN: 如果指定了`OUTER JOIN`(如LEFT OUTER JOIN、RIGHT OUTER JOIN)，那么保留表中未匹配的行作为外部行添加到虚拟表VT2，产生虚拟表VT3。如果FROM子句包含两个以上的表，则对上一个连接生成的结果表VT3和下一个表重复执行步骤1~步骤3，直到处理完所有的表;
(4) WHERE: 对虚拟表VT3应用WHERE过滤条件，只有符合`<where_condition>`的记录才会被插入虚拟表VT4;
(5) GROUP By: 根据GROUP BY子句中的列，对VT4中的记录进行分组操作，产生VT5;
(6) HAVING: 对虚拟表VT6应用HAVING过滤器，只有符合`<having_condition>`的记录才会被插入到VT7;
(7) SELECT: 第二次执行SELECT操作，选择指定的列，插入到虚拟表VT8中;
(8) DISTINCT: 去除重复，产生虚拟表VT9;
(9) ORDER BY: 将虚拟表VT9中的记录按照`<order_by_list>`进行排序操作，产生虚拟表VT10;
(10) LIMIT: 取出指定行的记录，产生虚拟表VT11，并返回给查询用户