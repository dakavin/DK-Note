
## 1、Redis交互协议

`Redis自定义了一种客户端和服务器的文本交互协议，叫RESP`，即Redis Serialization Protocol。官方表示RESP协议是三个目标的折中

```shell
RESP is a compromise between the following thing:
Simple to implement
Fast to parse
Human readable
```

即综合考虑`实现简单`、`解析速度快`、`可读性强`这三个目标，设计了这个协议

RESP能序列化不同的数据类型，包括整型、字符串、数组等。

请求从客户端以字符串数组的形式发送到redis服务器，这些字符串表示要执行的命令的参数。Redis用特定于命令的数据类型回复。 

## 2、网络层

连接Redis服务器的客户端建立了一个特定端口的TCP连接，Redis默认端口号是6379。

所以`实际上，在Redis的交互上，该协议仅用TCP连接`，当然，官方说RESP在技术上不特定于TCP，但是实际上也没有很实际的生产案例，也没有其他知名组件或者公司真的去用RESP协议。

## 3、请求-响应模型

一般来说，都是由客户端发送消息给服务端，服务端收到命令之后进行处理，处理完成返回给客户端，在消息返回前客户端出于等待状态，直到收到返回，就可以结束或发下一条消息。

但是这里也有两种模式比较例外：
1. Redis支持管道Pipelining。所以，`客户端可以一次发送多个命令，然后在等待应答`；
2. 当一个Redis客户端订阅一个频道，那么协议会改变语义并变成`push模式`，也就是说，这种情况下`服务器会主动发送消息给客户端`

## 4、RESP协议解释

RESP协议在Redis1.2被引入，直到Redis2.0才成为和Redis服务器通信的标准。这个协议需要再各个Redis客户端均有实现。

RESP是一个支持多种数据类型的序列化协议：简单字符串（Simple Strings）、错误（Error）、整型（Integers）、多行字符串（Bulk Strings）、和数组（Arrays）

RESP在Redis中作为一个`请求--响应协议有如下使用方式`:
- 客户端以==大容量字符串RESP数组==的方式==发送==命令给服务器端
- 服务器端根据命令的具体事项==返回== ==某一种RESP数据类型==。

在RESP中，数据类型依赖于首字节：
- 整型（Integers）：响应的首字节是`":"`
- 简单字符串（Simple Strings）：响应的首字节是`"+"`，这个类型是为了简单字段串，比如常见的"OK"
- 多行字符串（Bulk Strings）：响应的首字节是`"\$"`，这个类型就是正常的返回字符串
- 数组（Arrays）：响应的首字节是`"*"`
- 错误（Error）：响应的首字节是`"-"`

RESP协议的不同部分总是以`"\r\n"(CRLF)`结束

下面我们来具体介绍一下RESP各种数据编码。

## 5、Integers

最简单就是整数类型，整数类型是由冒号开头，CRLF结尾，组件是字符串形式表示的数字。

例如：
- `":0\r\n"`
- `":1000\r\n"`
都是整数回复，前者表示0，后者表示1000

很多Redis命令返回整数，比如INCR，LLEN
## 6、Simple Strings

比较简单的字符串，比如"OK"这种，不会由换行等字符的字符串，所以也不需要二进制安全，可以更节省空间。

Simple String编码方法：加号后面跟着一个不包含回车或换行符的字符串（不允许出现换行），以CRLF结尾。

例如，许多Redis命令在成功时回复"OK"，即简单字符串用以下5个字节编码：
```shell
"+OK\r\n"
```
为了发送二进制安全的字符串，需要使用RESP大大字符串Bulk Strings替代

## 7、BUlk Strings

Bulk Strings被用来表示普通的字符串返回，最大长度为512MB，`相比于Simple String，它是二进制安全的`，Bulk Strings的编码方式：
- 美元符`"\$"`后面跟着组成字符串的字节数（前缀长度），并以CRLF结尾。
- 实际的字符串数据
- 结尾是CRLF

字符串"city"编码如下:
```shell
"$4\r\ncity\r\n"
```

空字符串编码格式：
```shell
"$0\r\n\r\n"
```

也可以使用一个特殊的用来表示空值的格式表示不存在的值。在这种格式里长度值为-1，数据部分不存在，所以空（Null）用如下方式表示：
```shell
"$-1\r\n"
```

## 8、Array

客户端可以使用数组发送命令到Redis服务端。同样的，某些命令的应答使用数组返回元素的集合给Redis客户端。LRANGE命令返回元素列表就是一个例子。

使用如下格式发送：
- 以星号`"*"`为首字符，接着是表示数组中元素个数的十进制数，表示有返回的元素个数，最后以CRLF结尾。
- 外加数组中每个RESP类型的元素。

空数组表示：
```shell
"*0\r\n"
```

有两个RESP BulkString "foo"和"bar"元素的RESP数组：
```shell
"*2\r\n$3\r\nfoo\r\n$3\r\nbar\r\n"
```


在前缀`*<count>CRLF`的后面，组成数组的其他数据类型一个接在另外一个后面。例如包含三个整数的数组编码方式：
```shell
"*3\r\n:1\r\n:2\r\n：3\r\n"
```

`数组可以包含混合类型`，不一定必须得同一种类型。例如，4个整型和1个Bulk Strings编码方式：
```shell
*5\r\n
:1\r\n
:2\r\n
:3\r\n
:4\r\n
$6\r\nfoobar\r\n
```

第一行表示`*5\r\n`说明后面有5个应答。这些应答组成一个大的应答一起发送。
空数组的概念也是存在的，另一个表示空值的方式（通常使用多行空字符串，历史遗留导致有两种格式）。
例如，当BLPOP命令超过时，它会返回一个空数组，数组的计数器是-1：
```shell
"*-1\r\n"
```

当Redis返回一个空数组的时候，Redis客户端库API应该返回一个空对象而不是返回一个空数组。这对区分空列表和其他不同情况（像BLPOP命令超时情况）是必要的。

数组的数组也是可行的。例如，一个含有两个数组元素的数组编码方式：
```shell
*2\r\n
*3\r\n
:1\r\n
:2\r\n
:3\r\n
*2\r\n
+Foo\r\n
-Bar\r\n
```

上面的RESP数据类型包含两个数组，一个数组包含三个整数1、2、3，另一个是简单字符串和一个错误类型。

## 9、RESP错误

RESP有特殊类型来处理错误。errors类型处理首字符是减号`'-'`不是加号以外，其他跟简单字符串一样。

RESP中简单字符和错误的真正区别是：错误被客户端当做异常处理，组成错误类型的字符串是错误消息自身。

基本格式如下：
```shell
"-Error message\r\n"
```

## 10、发送命令到Redis服务器

至此，我们已经很熟悉RESP序列化格式，写一个Redis客户端库的事项会变得很容易。我们可以进一步说明客户端和服务端交互工作：
- 客户端发送包含只用Bulk Strings的数组给Redis服务器；
- Redis服务器给客户端发送任意有效的RESP数据类型作为应答

下面是一个典型的交互过程例子：
客户端发送命令`LLEN mylist`来获取存储在==mylist==键中列表的长度，然后服务端返回整数应答
```shell
C: *2\r\n
C: $4\r\n
C: LLEN\r\n
C: $6\r\n
C: mylist\r\n

S: :48293\r\n
```

为了方便理解我们用换行符把协议分成不同部分，实际上客户端发送的是一个整体没有换行的：

`*2\r\n$4\r\nLLEN\r\n$6\r\nmylist\r\n`

## 11、Redis协议的高性能解析器

虽然Redis协议是非常容易被人阅读和实现的，但是它可以类似于二进制协议的性能来实现。

RESP使用带前缀长度来传输多行数据，因此不需要像使用JSON那样扫描有效负载以查找特殊字符，也不需要引用需要发送到服务的有效负载。

多行和多个多行长度可以使用代码进行处理，代码对每个字符执行单个操作，同时扫描CR字符，如以下C代码：
![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/5017c51cbe07d9a9a26ed2311ec1cf7f.png)

在识别出第一个CR`（"\r\n"）`之后，可以跳过它和下面的LF，而不需要任何处理。

然后，可以使用不以任何方式检查有效负载的单个读取操作读取大容量数据。

最后，剩余的CR和LF字符将被丢弃，而不进行任何处理。

Redis协议有着与二进制协议可比的性能，更重要的是易于在大多数高级语言中实现，从而减少客户端软件中的错误数量。
## 12、总结

`Redis实现了一个文本解析协议，该协议综合考虑了实现简单、解析速度快、可读性强这三个目标`，我们不需要逐字逐句地记下协议内容，只需要有个整体认知即可。