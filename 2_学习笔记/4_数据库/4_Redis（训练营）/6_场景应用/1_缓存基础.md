
## 1、Redis做缓存

Redis由于性能高效，通常可以做数据库存储的缓存，比如给MySql当缓存就是常见的玩法，具体而言，就是将MySql的热点数据存储在Redis中，通常业务都满足二八原则， 80%的流量在20%的热点数据之上，所以`缓存是可以很大程度提升系统的吞吐量`。
## 2、怎么做

一般而言，缓存分为服务器端缓存，和客户端缓存：

- 服务端缓存，即服务端将数据存入Redis，
	- 可以在访问DB之后将数据缓存
	- 或者在回包时将回包内容以请求参数为Key缓存。

- 客户端缓存就是对服务端远程调用之后，将结果存储在客户端，这样下次请求相同的数据时就能直接拿到结果，不会再远程调用，提高性能节省网络带宽。

用服务端还是客户端呢？

- 其实是需要分析具体瓶颈在哪里，当然，如果按通常的经验，从服务角度来看，在目前的微服务架构下，每个服务其实都应该缓存一些热点数据，以减轻热点数据频繁请求给自己带来的压力，毕竟微服务也要有一定的互不信任原则。

- 至于客户端缓存，这个就更看场景，频繁请求的数据，就有必要做缓存。
	- 如Cookie

## 3、缓存的几种模式

缓存一般有如下几种模式

- Cache-Aside Pattern：旁路缓存模式
- Read Through Cache Pattern：读穿透模式
- Write Through Cache Pattern：写穿透模式
- Write Behind Pattern：又叫Write Back，异步缓存写入模式
### 3.1 Cache Aside

Cache Aside，即旁路缓存模式，是最常见的模式，应用服务把缓存当做数据库的旁路，直接和缓存进行交互。

读操作的流程如下：
- 应用服务收到查询请求后，先查询数据是否在缓存上，如果在，就用缓存数据直接打包返回，如果不存在，就去访问数据库，从数据库查询，并放到缓存中，除了查库后加载这种模式，如果业务有需要，还可以预加载数据到缓存。![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/77942dfa2781c7e168f666b4532c9e03.png)

写操作的流程如下：
- 在写操作的时候，Cache Aside模式一般是先更新数据库，然后直接删除缓存，![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/a3c1f84485e6d0cd97b5d6a94ff8d611.png)
- 为什么不直接更新呢？因为更新相比删除会更容易造成时序性问题，举个例子：
	- thread1更新mysql为5 --- thread2更新mysql为3 --- thread2 更新缓存为3 --- thread1 更新缓存为5
	- 最终正确的数据因为时序性被覆盖了

`Cache Aside适用于读多写少的场景，比如用户信息、新闻报道等，一旦写入缓存，几乎不会进行修改`。该模式的缺点是可能会出现缓存和数据库不一致的情况。
### 3.2 Read Through

Read Through，读穿透模式，和Cache Aside模式的`区别主要在于应用服务不再和缓存直接交互，而是直接访问数据服务，这个数据服务可以理解为一个代理，即单独起这么一个服务`，由它来访问数据库和缓存，作为使用者来看，不知道里面到底有没有缓存，数据服务会自己来根据情况查询缓存或数据库。

查询的时候，和Cache Aside一样，也是缓存中有，就用缓存中获得的数据，没有就查DB，只不过这些有数据服务托管保存，而对应用服务是透明的。

相比Cache Aside，Read Through的`优势是缓存对业务透明，业务代码更简洁`。缺点是缓存命中时性能不如Cache Aside，相比直接访问缓存，还会多一次服务间调用。

> 透明：对底层细节不清楚，完全忽视

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/b45ab6e1aeea0d00477cd2ea7589f610.png)
### 3.3 Write Through

在Cache Aside中，应用程序需要维护两个数据存储：一个缓存，一个数据库。这对于应用程序来说，更新操作比较麻烦，还要先更新数据库，再去删除缓存。

Write Through模式相当于做了一层封装：

- 由这个存储服务`先写入MySql，再同步写入Redis`，这样及时加载或更新了缓存数据。
- 可以理解为，应用程序只有一个单独的访问源，而存储服务自己维护访问逻辑。

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/27aa12f9898dd24ddd9277b9a1ffb98a.png)

当使用Write Through时，一般都配合使用Read Through来使用。`Write Through的潜在使用场景是银行系统`。

Write Through适用情况有：

- `对缓存及时性要求更高`（写入就加载了缓存，当然这种模式可能会有时序性问题）
- `不能忍受数据丢失`（相对Write-Behind而言）和数据不一致，但是Cache Aside也是如此

在使用Write Through时要特别注意的是缓存的有效性管理，否则会导致大量的缓存占用内存资源，因为这种模式下只要写入数据就加载了缓存。

### 3.4 Write Behind

Write Behind和Write Through相同点都是`写入时会更新数据库，也会更新缓存`

不同点在于Write Through会把数据立即写入数据库中，然后写缓存，安全性很高。

而Write Behind是`先写缓存`，然后`异步把数据 一起写入数据库`，这个异步写操作是Write Behind的最大特点。

数据库写操作可以用不同的方式完成：  

- 一种是时间上的灵活性，其中一个方式就是收集写操作并在某一时间点（比如数据库复杂低的时候）慢慢写入。
- 另一种方式就是合并几个写操作成为一个批量操作，一起批量写入
- 两者是可以根据业务情况结合的

异步写操作极大地降低了请求延迟并减轻了数据库的负担，但是代价是安全性不够，比如先写入了Redis，更新操作先放在存储服务内存中，但是还没异步写入MySql之前，存储服务器崩溃了，那么数据也就丢失了。

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/709b98398f3001a5351be0341956a5e9.png)

## 4、4种模式怎么选择

各有优势，但是Cache-Aside Pattern，旁路缓存模式是最场景，最易用的，在业务开发中，其他模式很少会用到。

## 5、总结

本节我们讲解了缓存的四种使用方式，其中旁路缓存模式是在生产环境应用最广的，后续我们的一些分析，也会围绕着旁路缓存模式来进行。