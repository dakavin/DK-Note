
## 1 什么是秒杀

秒杀通常指因为某种活动瞬时产生巨大流量的场景，比如双十一0点抢10000个苹果折扣手机，这种活动通常会吸引几十万甚至数百万人参与，而且大家都盯着0点，等0点一到就是海量的请求。

针对这种秒杀活动，我们需要注意一下几个问题：

`第一点，海量请求，服务要能抗住`
- 秒杀活动一开始，瞬间会有海量流量涌入，热点的商品甚至会有几百万人来抢。这个规模的流量砸下来，服务可能就挂了，活动也就GG了，收货的只有骂声。
- 怎么让服务能打能抗，是需要考虑的问题

`第二点，不能超卖`
- 因为秒杀有时候就是赔本赚吆喝，价格可能比成本还低。而这时候要是比原计划的数量卖多了，那到底发不发货呢？
- 发货会超预算亏损，要是超卖数量过多，说不定厂子都要倒闭了；不发货会被投诉，影响商家声誉；不管怎样，都是硬伤，只能找程序员赔钱

`第三点，避免少卖`
- 少卖会比超卖好一些，商家不存在经济上的损失。但是要被眼尖的消费者发现的话，也是免不了麻烦的。所以我们还是要尽可能避免这种情况。

`第四点，保证触达到用户而不是黄牛`
- 黄牛可能是开脚本，一次发很多请求过来，抢到之后再转卖。但做活动，希望就是回馈客户，进而响应用户，而不是去让黄牛赚外快。因此，我们要尽量挡住黄牛的魔爪，黄牛的恶劣影响，很多时候是被低估了。
- 不仅仅是侵害了正常用户的权益，同时由于黄牛善于使用脚本，很容易造成大量的恶意请求，让本不富裕的服务器资源，雪上加霜。
- 通过来说，为了打击黄牛，最常见的方式是限购，一个用户最多只能抢到N份，这样可以打打保障正常用户的权益
- 具体怎么做呢？为了性能，我们还是将限制逻辑加入到Redis中，所以我们的Lua脚本中，第一步查询库存，第二步扣减库存，需要`优化为第一步查询库存，第二步查询用户已购买个数，第三步扣减库存，第四步记录用户购买数`![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/e81b189f2d75e5c0b524b541acafada2.png)
- 这里需要注意的是，如果使用Redis集群，那么Redis的数据分片，需要根据用户来分Key，不然用户数据会查询不到

- 有了限购，我们可以保证货品不会被黄牛占据太多，那么还剩下一个问题，黄牛大多是通过代码来抢购，点击速度比人惦记快得多，这样就导致了竞争不公平。
- 作为追求极致的coder，我们希望还能更进一步，做到竞争公平
- 怎么解决呢？某个用户请求接口次数过于频繁，一般说明是用脚本在跑，可以只针对该用户做限制。
- 针对IP做限制也是常见的做法，但这样容易误杀，主要考虑到使用同一个网络的用户，可能都是一个出口IP。限制IP，会导致正常用户也受到影响
- 更好用的方案是加上一个验证码验证。验证码符合91原则，90%的时间，都用在验证码输入上，所以使用脚本点击的影响会降到很低。
- 当然，我们要明白没有银弹，这种方式缺点在于降低了用户的体验感
## 2 怎么高并发

秒杀活动的主要思路是削峰、限流、异步、补偿。

异步这一步可以通过消息队列来实现，将抢和购解耦，还可以很方便地限频，不至于让MySQL过度承压。

抢的话使用Redis来处理，因为Redis处理简单的扣减请求是非常快的，而直接到MySQL是比较力不从心。（Redis可是单机支撑每秒几万的写入，并且可以做成集群，提高扩展能力的）

我们可以先将库存名额预加载到Redis，然后在Redis中进行扣减，扣减成功在通过消息队列，传递到Mysql做真正的订单生成。
![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/c03253cb2abe281f96c237d8a712c856.png)

我们说回Redis，如果请求量超过6W/s，就需要考虑使用多个Redis来分流。预计有100W请求量，我们就可以临时调度20个Redis实例来支持，一个5W/s，留点Buffer。

这种模式倒是不需要使用Redis Cluster的做法，直接接个Nginx负载均衡就可以了。
![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/0bcc989eb861417209b9b5c1ffaf9d03.png)


## 3 拒绝超卖

解决了高并发问题，再来看看怎么防止超卖。既然我们将库存名额加载到了Redis，那就需要精确计数。

我们抢购场景最核心的，有两个步骤：
- 第一步，判断库存名额是否充足；
- 第二步，减少库存名额，扣减成功就是抢到。

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/47332e99a993427b2a562410af5e765b.png)

这里有一个问题要考虑，如果第一步判断的时候还有库存，但是由于是并发操作，实际调用的时候，可能已经没有库存了，这样就会导致超卖。

所以第一步和第二步都是需要原子操作的。但是Redis没有直接提供这种场景原子化的操作，

仔细想一想，Redis还有个特性，专门整合原子操作---`Lua`

Redis + Lua ，可以说是专门为了解决原子问题而生，在Lua脚本中调用Redis的多个命令，这些命令整体上会作为原子操作来进行。

有了这套机制之后，我们看下访问Redsi扣减库存时各种异常情况会怎样：
1. 正常业务错误，比如库存用完，这种情况符合预期，直接返回给用户即可
2. 访问Redis错误，这种情况返回给用户，让其重试即可
3. 访问Redis超时，这种情况下，其实可能库存已经扣减成功，此时不用再重试，避免产生更多的无效扣减，虽然多了一次扣减，但是总数是不变的，只会少卖不会多卖。
## 4 避免少卖

少卖什么情况会出现呢？库存减少了，但用户订单没有生成。

1. 上面提到的，减少库存操作超时，但实际是成功的，因为超时并不会进入生成订单流程；
2. 在Redis操作成功，但是向消息队列中间件发送消息失败，这种情况也会白白消耗Redis中的库存。

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/a87a59146bd4e5eeb1c9f463807be0ea.png)

作为一个很专业的程序员，只要知道问题是什么、怎么发生的，问题就解决了一半。

说白了，我们只需要`保证Redis库存 + 消息队列消耗的最终一致性`。但是一致性问题，一直是分布式场景的恶龙，要对付并不容易

- 第一种，也是简单的方式，在投递消息队列失败的情况下，增加渐进式重试；

- 第二种，更安全一点，就是在第一种的基础上，将这条消息记录在磁盘上，慢慢重试；

- 第三种，写磁盘之前就可能失败，可以考虑走WAL路线，但是这样做下去说不定就做成MySQL的undo log，redo log这种WAL计数了，会相当复杂，没有必要。

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/49125f0926edd92ff5c80dac85dd62c0.png)

针对少卖这种极端场景可接受的问题，一般选择第二种方式即可，毕竟是异常情况的小概率时间，真出问题了大不了人工介入。
## 5 Redis角色

Redis扮演扣减库存的角色，这个主要源自Redis比关系型存储高很多的处理性能。

实际上，除了扣减库存，Redis有时候也可以扮演队列的角色，请求过来先记录在Redis，虽然不如传统消息队列可靠，但胜在轻量。
