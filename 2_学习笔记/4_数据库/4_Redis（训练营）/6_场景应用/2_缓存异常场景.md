
## 1、缓存穿透

### 1.1 问题背景

缓存穿透是指`缓存和数据库中都没有的数据`，而用户不断发起请求。由于缓存是不命中时被动写的（即缓存没有去数据库找，找到后数据库写入缓存），并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。

在流量大时，可能DB就挂掉了，要是有人利用不存在的Key频繁攻击我们的应用，这就是漏洞。

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/431326381a27a4f3ad5cf980ff956062.png)

如发起id为“-1”的数据或id为特别大，不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。

### 1.2 解决方案

1. 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；
2. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对 写为 key-null，缓存有效时间可以设置短点，如30s（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击；
3. 布隆过滤器。bloomfilter就类似于一个HashSet，用于快速判断某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小

可以用布隆过滤器来应对，布隆过滤器是一种比较巧妙的概率型数据结构，特点是高效地插入和查询，可以用来告诉我们“`某样东西一定不存在或者可能存在`”

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/ddb0120a402fcb98bd97e1d5531d783a.png)

布隆过滤器原理：
- 布隆过滤器底层是一个64位的整型，将字符串用多个Hash函数映射不同的二进制位置（index），将整型中对应位置（桶位）设置为1
- 在查询的时候，如果一个字符串所有Hash函数映射的值都存在，那么数据可能存在。为什么说可能呢，就是因为其他字符可能占据改值，提前点亮

可以看到，布隆过滤器优缺点都很明显，优点是空间、时间消耗都很小，缺点是结果不是完全准确的

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/86ceffdb60086a181e744518c0f65969.png)


## 2、缓存击穿

### 2.1 问题背景

缓存击穿是指`缓存中没有但数据库中有的数据`（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没有读到数据，又同时去数据库读取数据，引起数据库压力瞬间增大，造成过大压力。

缓存击穿，一般指是热键在过期失效的一瞬间，还没来得及重新产生，就有海量数据，直达数据库
### 2.2 解决方案

1. 热点数据支持续期，持续访问的数据可以不断续期，避免因为过期失效而被击穿
2. （互斥锁）发现缓存失效，重建缓存加互斥锁，当线程查询缓存发现缓存不存在就会尝试加锁，线程争抢锁，拿到锁的线程就会查询数据库，然后重建缓存，争抢锁失败的线程，可以加一个睡眠然后循环重试。
3. （逻辑过期）把过期时间设置在value中，查询缓存中的数据时，如果发现逻辑时间已过期，尝试获取锁，开启一个异步的方法进行缓存的更新操作，先返回过期的数据。

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/9ccecf66e0be22ced8ced13d554bfb84.png)

## 3、缓存雪崩

### 3.1 问题背景

缓存雪崩，是指大量的应用请求因为异常无法在Redis缓存中进行处理，像雪崩一样，直接打到数据库。

这里异常的原因，也可以说雪崩的原因，主要是：
缓存中`数据大批量过期，而查询数据量巨大，引起数据库压力过大甚至宕机`

其实在一些资料里，会把Redis宕机算进来，原因是Redis宕机了也就无法处理缓存请求，但这里会觉得有些牵强，如果这里能算，缓存击穿不也可以算？所以这里建议是不把Redis宕机考虑到雪崩里去。

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/77b359987bc6d62491a8e457c0b80dbb.png)

和缓存击穿不同的是，缓存击穿指一条热点数据在Redis没得到及时重建，缓存雪崩是一大批数据在Redis同时失效
### 3.2 解决方案

1. 缓存数据的过期时间设置随机，分支同一时间大量数据过期现象发生
2. 重建缓存加互斥锁，当线程拿到缓存发现缓存不存在就会尝试加锁，线程争抢锁，拿到锁的线程就会进行查询数据库，然后重建缓存，争抢锁失败的线程，可以加一个睡眠然后循环重试


## 4、总结

本节梳理了几个常见的缓存异常场景，这几个场景特殊面试中常问的，下一节我们来讲讲缓存一致性怎么保证。