
## 1 分布式锁实现要点是什么（其实就是怎么加锁、怎么解锁、怎么用）？

分析：
- 这里其实就是问怎么加锁、怎么解锁、怎么用

回答：
- 加锁时候要`设置owner`和`过期时间`，前者是便于解锁时进行拥有者判断，后者是作为异常情况的兜底
- 解锁时候要先判断owner，是自己的再释放，这里还要注意这两步操作的原子性，可以用lua脚本来进行保证

## 2 为什么需要引入owner的概念呢？

分析：
- 这个问题本事是问为什么分布式锁要这种对称性，对称性也就是说同一个锁，加锁和解锁 必须是同一个竞争者。不能把其他竞争者持有的锁给释放了（超时自动释放除外）。
- 回答没有对称性会怎么样，举个场景说明

回答：
- `分布式锁需要保存对称性`，假设没有这种对称性，会有问题
- 举个例子，服务A获取了锁，由于业务流程比较长，或者网络延迟、GC卡顿等原因，导致锁过期，而业务还会继续进行
- 这时候，业务B已经拿到了锁，准备去执行，这个时候服务A恢复过来并做完了业务，就会释放锁，而B却还在继续执行，等B完成下次释放的可能有所别人的锁，这种情况是需要避免的。

## 3 你提到了lua，用lua一定能保证原子性吗？

分析：
- 考察lua的掌握情况![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/de7b657a0d5b3d0993bc6aedfa00f8b3.png)

回答：
- `lua本身不具备原子性`，上面提到用lua来保证原子性是`因为Redis是单线程执行`，一个流程放进lua来执行，相当于是打包在一起，Redis执行它的过程中不会被其他请求打断，所以说保证了原子性。
- 这里我们也提到，我们是在释放的时候将查询key，删除key打包到一起，其中只有最后删除是写操作，所以这个流程本身是保证了原子性的

## 4 分布式锁是完全可靠的吗？

分析：
- 完全可靠是不存在的，因为网络不可靠
- 有些面试官任务RedLock几乎是可靠的，这也没啥大问题，RedLock通过集群的方式确实更可靠，但是完全可靠说不上

回答：
- `没有完全可靠的分布式锁`，在使用分布式锁的时候就要考虑到这一点，`关键业务还是需要幂等来兜底`。
- 当然我们`可以使用RedLock集群化的分布式锁`，这种模式出问题的概率就微乎其微了

## 5 RedLock是什么？（问到的概率很小，有时候主动吹牛用到，尚未了解一下即可）

分析：
- 了解RedLock即可

回答：
- Redis的RedLock，是集群化部署的思路，大概的思路就是多个机器，通常是奇数个，`达到一半以上同意加锁才算加锁成功`，这样，可靠性会向ETCD靠近。
- 现在假设有5个Redis主节点，基本保证它们不会同时宕机，获取锁和释放锁的过程中，客户端会执行一下操作：
	1. 向5个Redis申请加锁
	2. 只要超过一半，也就是3个Redis返回成功，那么就是获取到了搜索。如果超过一半失败，需要向每个Redis发送解锁命令
	3. 由于向5个Redis发送请求，会有一定时耗，所以锁剩余持有时间，需要减去请求时间。这个可以作为判断依据，如果剩余时间已经为0，那么也是获取锁失败
	4. 使用完成之后，向5个Redis发送解锁请求

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/b99ffee85da7cfa519780439b661179d.png)
- 这种模式的好处在于，如果挂了2台Redis，整个集群还是可用的，给了运维更多时间来修复

