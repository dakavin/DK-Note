
## 1、面试考点分析

跳表是Redis有序集合使用都的一种底层数据结构，是比较热门的考察内容。

考点集中在操作流程、数据结构、层高等细节

## 2、面试题

### 2.1 跳表是什么，和普通的链表有什么区别？

分析：
- 跳表的本质上还是链表，普通的链表结构如下：![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/d7a76e4d5d3850c368dd3a98b98420a7.png)
- 这种结构虽然简单清晰，但是查询某个节点的效率比较低，而在有序集合场景，无论是查找还是添加删除元素，我们是需要能快速通过score定位到具体位置，如果用链表那时间复杂度就是O(N)，N是节点个数
- 为了提升查找的性能，Redis就引入了跳表，跳表在链表的基础上，给链表增加了多级索引，通过索引可以一次实现多个节点的跳跃，提高性能；

回答：
- 跳表也算链表，不过相对普通链表，`增加了多级索引`，通过索引可以`实现O(logn)的元素查找效率`

### 2.2 聊聊跳表的查找过程

分析：
![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/72d33ba2be0176c5d31fc564d1c386aa.png)

回答：
- 从`高级索引`往后查找，如果下个节点的数值比目标节点小，则继续找，否则不跳过去，而是用下级索引继续向后查找，直到找到为止
- 若当前索引找不到，则在下级索引找；

### 2.3 跳表查询节点总数的平均时间复杂度是多少？

分析：
- 这个问题是对Redis跳表数据结构的考察，首先我们可以想象跳表的表头结构![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/aaef10781f0e5ce977307644695430ba.png)
- 跳表的表头结构中定义了保存节点数量的字段 `length`，所以对Redis跳表查询节点总数的平均时间复杂度应该为`O(1)`。我们也可以进一步查看相关API底层源码：![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/eab926447ec4e63955bed5783e70bf60.png)
- 查询有序集合成员总数的API是`zsetLength`，而当前编码模式是`REDIS_ENCODING_SKIPLIST`，源码中会直接返回跳表表头结构的length字段，平均时间复杂度是`O(1)`

回答：
- 跳表编码模式下，查询节点总数的平均时间复杂度是`O(1)`，因为==跳表的表头结构中定义了一个保存节点数量的字段length==，源码中调用查询节点总数的API时会直接返回这个字段；

### 2.4 跳表中一个节点的层高是怎么决定的？

分析：
- 这个问题是对跳表这种数据结构本身的考察，跳表中插入一个节点之前会选择一个随机化的层数，因为如果跳表的层数从上至下呈一定的比例关系，那么后期插入和删除的时候就又需要去维护这种比例关系，会使时间复杂度退化。所以跳表选择在插入节点的时候，选择一个随机化的层数。
- 但是生成的随机层数得遵循一个算法，使得生成小数值层数的概率很大，而生成大数值层数的概率很小，这个`算法就是幂次定律`。跳表`在插入新节点之前，会利用这个幂次定律算法生成一个随机层数`。

回答：
- 跳表在插入新节点之前会计算一个随机层高，具体来说，跳表的每一个节点一开始默认都是1层，然后`每增加一层的概率是25%`，在5.0.5版本最高为64层 

### 2.5 跳表插入一条数据的平均时间复杂度是多少？

分析：
- 这个问题同样是对跳表这种数据结构本身的考察，跳表实际上就是在一维链表上建立多层索引的二维链表，多出来的层数可以让跳表实现类似二分查找的算法。所以跳表的插入平均时间复杂度是O(logn)

回答：
- 跳跃表是一种支持多级索引的结构，查找效率可以媲美二分查找，它插入一条数据的平均时间复杂度是`O(logn)`。

### 2.6 跳表插入数据会影响其他节点层高吗？

分析：
- 如果答不对说明对跳表掌握很不足

回答：
- 不会，节点层高是创建时就确认了，不会被新插入节点影响
- 新插入节点只会影响每一层前一跳、后一跳的关联指针