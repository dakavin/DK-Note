
## 1、面试考点分析

String作为最基础的对象，很容易收到比较多的关注。面试的考察点集中在String常规操作和底层实现，`常规操作必须熟练掌握`，`底层实现要了解三种编码方式，以及需要清楚SDS的细节`。

## 2、面试题

### 2.1 Set一个已有的数据会发生什么？

分析：
- 常用操作考察。

回答：
- 如果是`同种类型`，会覆盖原有的值，同时会覆盖或者擦除键的过期时间
- （`非同种类型`）set命令还可以直接把key抹除，例如原本有一个列表键mylist，可以直接set mylist abc 来覆盖这个列表键。类似隐式的del（或者unlink）mylist + set

### 2.2 浮点型在String是用什么表示？

分析：
- 基础知识考察，只有三种编码方式，INT只针对于整型，所以浮点型必然是字符串存储。

回答：
- 要将一个浮点数放入字符串对象里面，需要`先将这个浮点数转换成字符串值，然后再保存转换所得到的字符串值`，比如浮点数3.14，对应就变成了“3.14”这个字符串。
- 所以浮点数在字符串对象里面是用字符串表示的。

### 2.3 String可以有多大？

分析：
- 基础知识考察，需要指导明确的数值，更进一步需要来源背书，再进一步需要思考为什么是这个数值。

回答：
- 一个Redis字符串最大为512MB，官网有明确注明，我用的5.0.5版本源码里也是直接写死的。![](assets/Pasted%20image%2020231015171310.png)
>现在可以通过配置项 `proto-max-bulk-len`来修改这个限制，不过要6.0及之后的版本才支持修改这个配置

### 2.4 Redis字符串是怎么实现的？

分析：
- 这个问题，首先需要分情况说出编码类型，分别应用于什么场景
- EMBSTR编码和RAW编码的选择阈值也比较重要，回答的时候，可以先说自己用的Redis版本的数值，面试官会感觉你确实有关注过编码的阈值
- 如果能记得3.2版本之前是39，3.2版本及之后才是44，也可以说出来，有一定程度的加分，但是说了这个差别可能会引导面试官追问为什么，如果记不清就不要说版本差别了。

回答：
- Redis字符串底层是String对象，String对象有三种编码方式：INT类型，EMBSTR类型和RAW类型。
- 如果存一个整型，可以用long表示的整数就以INT编码存储；
- 如果存字符串，当字符串长度小于一个阈值，使用EMBSTR编码；
- 字符串大于阈值，则用RAW编码
- 在我用的5.0.5版本，这个阈值是44字节

### 2.5 为什么EMVSTR的阈值是44？（超级冷门）

分析：
- 这个问题是上个问题的追问，有一下几个要点
	1. Redis默认使用的是jemalloc作为内存分配器；
		- 可以通过`info memory`命令来查看`mem_allocator`
	2. jemalloc是以64字节作为内存单元做内存分配，如果超过了64字节就超过了一个内存单元，尽量在一个内存单元，是为了减少内存寻址，又不会消耗分配过多没用到的内存。简单来说，局部性访问原理，在一起就不需要跳转了。超过64的话则会用到RAW编码；反之，如果小于等于64字节，就会认为是一个小字符串，会用到EMBSTR编码。
	3. 围绕64字节的关键分界来分析版本变化，Redis的字符串对象是由redisObject和sdshdr这两部分组成，`redisObject大小为 4(对象类型) + 4（编码类型） + 24（LRU淘汰时间） + 32（引用计数） + 64（指向实际数据结构的指针） = 128bits = 16bytes`，这个是一直没变过的，注意其中prt的大小是为了方便在各种编译器和目标平台上都能用，所以取了64位为最大值

![](assets/Pasted%20image%2020231015171840.png)

- 回顾sdshdr结构：![](assets/Pasted%20image%2020231015171859.png)
	- sdshdr8占用的内存大小：`1byte(使用多少空间) + 1byte（分配多少空间） + 1byte（sds类型） + 内联数组的大小（字符串内容大小）`，由于内联数组中还有一个`'/0'`占位一个字节，所以能用的大小为 `64 - 16(redisObject) - 3(sdshdr非内容属性) - 1（'/0'） = 44`

|不等式|类型|字符串长度|
|:--:|:--:|:--:|
|20 + 字符串长度 > 64|大字符串|大于44|
|20 + 字符串长度 <= 64|小字符串|小于等于44|
回答：
- Redis是使用jemalloc内存分配器，Redis以64字节为阈值区分大小字符串
- 所以EMBSTR的边界数值，其实是受64这个阈值影响
- redis对象占用的内存大小有redisObject和sdshdr这两部分组成，redisObject是16字节，sdshdr中已分配、已申请、标记三个字段固定占了3个字节，`'/0'`占位1个字节，能存放的数据就是 `64 - （16+4） = 44`

### 2.6 为什么EMBSTR曾经的阈值是39？（超级冷门）

分析：
- 实际上一般面试官不会主动这么问，一般聊到这个还是要问在上面问题提到了版本差异。要回答的话，要从SDS结构来分析，sdshdr3.2之前版本结构如下：![](assets/Pasted%20image%2020231015200724.png)
- 当时都是通用的SDS结构，非数据字段移动占据了8个字节，为了节约内存，就在3.2版本之后将SDS分为sdshdr5（这个结构不被使用）、sdshdr8、sdshdr16、sdshdr32、sdshdr64，EMBSTR使用sdshdr8节约了6个字节，但多引入了一个flags字段占据1字节，所以相比3.2版本之前的SDS多了5个字节，从这一点也能看出Redis也是不断在优化内存和性能的。
- 之前的sds数据结构占用空间为：`4byte（所占空间大小） + 4byte（剩余空间大小） + 字符串实际内容 + 1byte（0字符）`

回答：
- 3.2之后的版本，SDS结构进行了拆分，EMBSTR用的sdshdr8，总容量和已使用容量字段减少了6个字节，但由于增加了一个flags字段，所以最终节约了5个字节

### 2.7 SDS有什么用？

分析：
- Redis是用C语言写的，SDS可以说是对C字符串的封装，一般对比普通C字符串。可以从计算长度、扩容、缩容、二进制存储这几个场景来描述。

回答：
- 主要有三点：
	1. SDS包含已使用容量字段，O(1)时间快速返回有效字符串长度，相比之下，C原生字符串需要O(n)
	2. 有预留空间，在扩容时如果预留空间足够，就不用再重新分配内存，节约性能，缩容时也可以将减少的空间先保留下来，后续可以在使用
	3. 不再以`'/0'`作为字符串结束判断标准，二进制安全，可以很方便地存储一些二进制数据

![](assets/Pasted%20image%2020231015202008.png)


### 2.8 EMBSTR和RAW的区别

前置知识：
- 对于EMBSTR类型的字符串的RedisObjetc和SDS在内存是连续的，而RAW是通过RedisObject中的指针成员指向SDS

所以：
1. EMBSTR只需要一次malloc，而RAW需要两次内存分配；同样，前者只需要一次free，后者需要两次free；
2. EMBSTR读取性能更好（只需要寻址一次），内存碎片率更低；
3. 如果修改EMBSTR（append操作），那么就会将EMBSTR转换为RAW（重新分配内存空间，从设计上来说EMBSTR用于只读）