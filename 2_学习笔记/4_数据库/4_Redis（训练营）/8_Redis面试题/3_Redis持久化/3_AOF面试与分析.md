## 1、AOF是默认开启的吗？

分析:
- 考察AOF基础知识掌握

回答：
- 不是，RDB是默认开启的，AOF需要手动开启
## 2、AOF重写是解决什么问题？

分析:
- 考察AOF基础知识掌握

回答：
- 重写是用于`解决AOF不断膨胀问题`，随着命令越来越多，AOF文件越来越大，但是很多数据其实不一定都是还有意义的，比如原来set a 3 ，后面又有个set a 100 ，那么前者就不需要再继续了
- 重写就是通过当前状态，`重新生成最新的AOF操作命令记录的过程`。


## 3、简单描述AOF重写流程（很重要，务必要学）

分析:
- 可以将AOF重写 流程 记为`“一次拷贝，两处日志”`
	- 一次拷贝：重写发生时，主进程会fork出一个子进程，让子进程将这些Redis数据 写入 重写日志
	- 两处日志：重写发生时，我们需要 注意 AOF缓冲 和 AOF重写缓冲；当重写时，有新的写入命令执行，会由主进程 分别 写入AOF缓冲 和AOF重写缓冲；
		- AOF缓冲用于保证此时发生宕机，原来的AOF日志也是完整的，可以用于恢复。
		- AOF重写缓冲 用于保证 新的AOF文件 也不会丢失 最新的写入操作

回答：
- 我将AOF重写流程理解为“`一次拷贝，两处缓冲`”
- `一次拷贝`：重写发生时，主进程 会 fork出一个子进程，子进程和主进程共享Redis物理内存，让子进程将这些 内存 写入 重写日志。
- `两处缓冲`：当重写时，有新的写入命令执行，会由主进程 分别 写入`AOF缓冲` 和`AOF重写缓冲`；AOF缓冲用于保证此时发生宕机，原来的AOF日志也是完整的，可以用于恢复。AOF重写缓冲 用于保证 新的AOF文件 也不会丢失 最新的写入操作。

## 4、AOF对主流程有什么影响?（几乎不需要了解）

分析:
- 明显的影响：使用AOF持久化，如果我们使用always策略，每当Redis命令执行之后，需要由主进程进行write + fsync的操作，如果数据过大的话，主进程就会花费比较大的时间 用于写AOF日志，对后续请求影响较大（阻塞，直到写AOF完成，才能响应客户端执行成功）
- 潜在的影响
	- 如果我们选择everysecond策略，虽然fsync是交给后台线程BIO_AOF_FSYNC来完成，但是主进程还需要进行write操作，如果后台线程上一轮fsync没有完成，那么主进程进write的时候仍然会阻塞（因为write作用在一个正在fsync的fd上，会阻塞），PS：这个太深了，基本没人会问
	- AOF重写是有fork出的子进程进行的，类似于上面提到的风险，fork子进程这个操作有可能阻塞主线程；

回答：
- 当appendfsync使用always，如果AOF写入日志压力过大 会导致主进程无法继续处理其他请求
- 当appendfsync使用everysecond，如果后台线程上一轮的fsync没有完成，会导致我们本轮主线程执行write被阻塞（直到fsync完成）
- 当AOF重写发生时，如果数据量较大，会导致fork子进程这个操作比较耗时，从而阻塞主进程



## 5、源码中，AOF刷盘什么时候会触发（几乎不需要了解，一般不会这么问）

分析:
- 首先一定要弄清楚AOF的流程怎么样的
	- 整个AOF流程可以分为三个过程：命令追加（append到aof_buf）、文件写入（将aof_buf中的数据write到内核缓冲区）、文件同步（fsync让内核缓冲区数据进入磁盘文件）
- 从源码来看，AOF刷盘函数在三个地方会被触发
	- Redis Shutdown的时候
	- 每一次事件循环 钩子函数beforeSleep()
	- 每次时间循环的时间事件对应的handler——serverCron()

回答：
- 根据分析 理清楚AOF流程是怎么样的，不同appendfsync策略是如何执行的，酌情回答



