
[参考文章-Redis IO多路复用技术以及epoll实现原理]([【精选】Redis IO多路复用技术以及epoll实现原理_redis io多路复用的原理和实现_乐乐Java路漫漫的博客-CSDN博客](https://blog.csdn.net/b1303110335/article/details/112309842?app_version=6.1.1&code=app_1562916241&csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22112309842%22%2C%22source%22%3A%22unlogin%22%7D&uLinkId=usr1mkqgl919blen&utm_source=app))

[参考文章-面试官：说说Redis之I/O多路复用模型实现原理]([面试官：说说Redis之I/O多路复用模型实现原理_业余草的博客-CSDN博客](https://blog.csdn.net/xmtblog/article/details/118533110?app_version=6.1.1&code=app_1562916241&csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22118533110%22%2C%22source%22%3A%22unlogin%22%7D&uLinkId=usr1mkqgl919blen&utm_source=app))
## 1、Redis单线程

我们前面说到，Redis核心的请求处理是单线程，通常来说，单线程的处理能力要比多线程差很多，但是Redis却能使用单线程模型达到每秒数万级别的处理能力，这是为什么呢？其实，这是Redis多方面极致设计的一个综合结果。

几个关键点：

第一：Redis大部分操作`在内存上完成`，内存操作本身就很快；

第二：Redis追求极致，选择了`很多高效的数据结构`，并做了非常多的优化，比如ZIPLIST、HASH、跳表，有时候一种对象底层有几种实现来应对不同场景

第三：Redis采用了`多路复用机制`，使其在网络IO操作中能并发处理大量的客户端请求，实现高吞吐量。

第一点很好理解，第二点我们在数据结构部分，已经深入分析过了，Redis对数据结构真是近乎偏执地区优化，这里不做赘述。

接下来，我们重点看第三点多路复用机制。要理解多路复用机制，我们要先理解为什么要多路复用，没有多路复用情况下，那些环节可能发生阻塞，Redis是单线程模型，一旦发生阻塞，整体服务都会慢下来。

下面，我们来分析下Redis是怎么处理请求的。
## 2、I/O可能的潜在点

首先，我们知道Redis是完全在内存中处理数据，所以我们最应该考虑的瓶颈是I/O，我们下面通过分析一次请求，来看一下，一个单线程在一次完整的处理中，会有那些地方可能拖慢整个流程。

Redis的服务端在启动的时候，已经bind了端口，并且用listen操作监听客户端请求，此时客户端就可以发起连接请求。

此时，客户端发起一次处理请求，比如，客户端发来一个GET请求，服务端需要做哪些事情呢？

1. 监听客户端请求（bind/listen）
2. 和客户端建立连接（accpet）
3. 从 socket 中读取请求（recv）
4. 解析客户端发送请求（parse）
5. 根据请求类型读取键值数据（get）；
6. 最后给客户端返回结果，即向 socket 中写回数据（send）

![](https://image-for.oss-cn-guangzhou.aliyuncs.com/for-obsidian/Java_Study/2_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_Java%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83/1_Java%E5%9F%BA%E7%A1%80/1_Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/Pasted%20image%2020231021202834.png)

![](https://image-for.oss-cn-guangzhou.aliyuncs.com/for-obsidian/Java_Study/2_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_Java%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83/1_Java%E5%9F%BA%E7%A1%80/1_Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/Pasted%20image%2020231024204258.png)

我们要知道，`套接字（每一个 socket 网络连接其实都对应一个套接字/文件描述符）是默认阻塞模式的`

这里阻塞可能会发生在两个地方，分别是 accept() 和 recv()
- 当 Redis 监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 accept() 函数这里，导致其他客户端无法和 Redis 建立连接
- 当 Redis 通过 recv() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()

Redis本身定位就是单线程，发生这种阻塞会将整个服务卡住。所以不能让这两个操作阻塞，这里`Redis将套接字设置为非阻塞式的`，这样`accept和recv都可以非阻塞调用`。

非阻塞调用下，如果没有数据，不会阻塞在那里，而是让你返回做其他事情。这样可以解决卡死的问题。但我们也`需要一种机制，能回头看看这些操作是否已经就绪`。

最简单的思路，我们可以通过一个循环来不断轮询，但这种方式显然很低效。好在各个操作系统实现了一种机制，叫I/O多路复用。

什么叫I/O多路复用，简单理解来说，就是有I/O操作触发的时候，就会产生通知，收到通知，再去处理通知对应的事件，`针对I/O多路复用，Redis做了一层包装，叫Reactor模型`。

如下图，本质就是监听各种事件，当事件发生时，将事件分发给不同的处理器。

![](https://image-for.oss-cn-guangzhou.aliyuncs.com/for-obsidian/Java_Study/2_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_Java%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83/1_Java%E5%9F%BA%E7%A1%80/1_Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/Pasted%20image%2020231021203549.png)

这样就不会阻塞在某一个操作上，充分发挥性能，可以I/O多路复用让Redis单线程也有了较大的并发度，注意这里是并发，而不是并行，在这种模式下，Redis单核的性能可以说是被充分的利用了。

## 3、总结

Redis单线程快的原因有3点：内存操作、高效的数据结构、I/O多路复用。

在之前的内容我们已经前两者比较熟悉，本节重点就是搞清楚I/O多路复用，以及熟悉Reactor模型相对宏观的一个架构。

下一节我们会源码分析Redis处理过程，以加深理解。

## 4、补充

### 4.1 非阻塞模式

Socket 网络模型的非阻塞模式设置，主要体现在三个关键的函数调用上，如果想要使用 socket 非阻塞模式，就必须要了解这三个函数的调用返回类型和设置模式。接下来，我们就重点学习下它们。

在 socket 模型中，不同操作调用后会返回不同的套接字类型。
- socket() 方法会返回`主动套接字`
- 然后，调用 listen() 方法，将主动套接字转化为`监听套接字`，此时，可以监听来自客户端的连接请求。
- 最后，调用 accept() 方法接收到达的客户端连接，并返回`已连接套接字`。

![](https://image-for.oss-cn-guangzhou.aliyuncs.com/for-obsidian/Java_Study/2_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_Java%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83/1_Java%E5%9F%BA%E7%A1%80/1_Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/Pasted%20image%2020231024204835.png)

Redis套接字类型与非阻塞设置

针对监听套接字，我们可以设置非阻塞模式：`当 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待。但是，你要注意的是，调用 accept() 时，已经存在监听套接字了`。

虽然 Redis 线程可以不用继续等待，但是总得有机制继续在监听套接字上等待后续连接请求，并在有请求时通知 Redis。

类似的，我们也可以针对已连接套接字设置非阻塞模式：`Redis 调用 recv() 后，如果已连接套接字上一直没有数据到达，Redis 线程同样可以返回处理其他操作。我们也需要有机制继续监听该已连接套接字，并在有数据达到时通知 Redis`。

这样才能保证 Redis 线程，既不会像基本 IO 模型中一直在阻塞点等待，也不会导致 Redis 无法处理实际到达的连接请求或数据。

到此，Linux 中的 IO 多路复用机制就要登场了。

### 4.2 基于多路复用的高性能 I/O 模型

`Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制`。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个`监听套接字`和`已连接套接字`。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。

下图就是基于多路复用的 Redis IO 模型。图中的多个 FD 就是刚才所说的多个套接字。`Redis 网络框架调用 epoll 机制，让内核监听这些套接字`。此时，Re dis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性。

![](https://image-for.oss-cn-guangzhou.aliyuncs.com/for-obsidian/Java_Study/2_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_Java%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83/1_Java%E5%9F%BA%E7%A1%80/1_Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/Pasted%20image%2020231024204843.png)

基于多路复用的Redis高性能IO模型

`为了在请求到达时能通知到 Redis 线程，select/epoll 提供了基于事件的回调机制，即针对不同事件的发生，调用相应的处理函数`。

那么，回调机制是怎么工作的呢？其实，select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。

这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。这样一来，Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时，Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升 Redis 的响应性能。

为了方便你理解，再以连接请求和读数据请求为例，具体解释一下。
- 这两个请求分别对应 Accept 事件和 Read 事件，Redis 分别对这两个事件注册 accept 和 get 回调函数。当 Linux 内核监听到有连接请求或读数据请求时，就会触发 Accept 事件和 Read 事件，此时，内核就会回调 Redis 相应的 accept 和 get 函数进行处理。

这就像病人去医院瞧病。在医生实际诊断前，每个病人（等同于请求）都需要先分诊、测体温、登记等。如果这些工作都由医生来完成，医生的工作效率就会很低。所以，医院都设置了分诊台，分诊台会一直处理这些诊断前的工作（类似于 Linux 内核监听请求），然后再转交给医生做实际诊断。这样即使一个医生（相当于 Redis 单线程），效率也能提升。

不过，需要注意的是，即使你的应用场景中部署了不同的操作系统，多路复用机制也是适用的。因为这个机制的实现有很多种，既有基于 Linux 系统下的 select 和 epoll 实现，也有基于 FreeBSD 的 kqueue 实现，以及基于 Solaris 的 evport 实现，这样，你可以根据 Redis 实际运行的操作系统，选择相应的多路复用实现。