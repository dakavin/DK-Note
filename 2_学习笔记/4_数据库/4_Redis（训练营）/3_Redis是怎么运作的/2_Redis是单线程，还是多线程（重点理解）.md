
Reids是一个能高效处理请求的组件，一般而言，对这种组件，我们都需要了解其并发模型是怎么样的，比如Nginx是多进程模型，Mysql是多线程模型，那Redis是什么呢？多线程模型吗？

先说结论，`核心处理逻辑，Redis一直都是单线程的`，其他辅助模块也会有一些`多线程、多进程`的功能，比如：持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。

某些异步流程从4.0开始用的多线程，例如：UNLINK、FLUSHALL ASYNC、FLUSHDB ASYNC等非阻塞的删除操作。

网络I/O解包从6.0开始用的多线程；

但是这种分支模块，都只是辅助，最核心的还是处理架构，这块Redis始终是单线程的。

`Redis采用Reactor模型的网络模型，对于一个客户端请求，主线程负责一个完整的处理过程`：![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/9d2018ff45769084125050ffd6f33b8a.png)
## 1、Redis为何选择单线程？

Redis的核心处理模块选择用单线程来实现，这可能会让人很疑惑，毕竟多线程可以利用多核的优势，而Redis官方对于此的回答是：
>For instance, using pipelining Redis running on an average Linux system can deliver even 1 million requests per second, so if your application mainly users O(N) or O(logn) commands, it is hardly going to use too much CPU.

意思就是Redis的定位，是内存k-v存储，是做短平快的热点数据处理，一般来说执行会很快，执行本身不应该成为瓶颈，而瓶颈通常在网络I/O，处理逻辑多线程并不会有太大收益。

同时，Redis本身秉持简介高效的理念，代码的简单性、可维护性是Redis一直以来的追求，引入多线程带来的复杂性远比想象的要大，而且多线程本身也会引入额外成本，下面我们分析一下：
### 1.1 多线程引入的复杂性是极大的

`多线程下面临着共享资源并发访问控制的问题`

首先，多线程引入之后，`1. Redis原来的顺序执行特性就不复存在`，为了支持事务的原子性，隔离性，Redis就不得不引入一些很复杂的实现；

其次，Redis的数据结构，可以说是及其高效，在单线程模式下做了很多特性的优化，如果引入多线程，那么所有`2. 底层数据结构都要改造为线程安全`，这会是极其复杂的工作；

而且，多线程模式也使得程序调试更加复杂和麻烦，会`3. 带来额外的开发成本和运营成本，也更容易犯错`，这是一张很形象的图：![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/2131d68a22e5b7601743013776a87bec.png)
所以，引入多线程，会带来很大的复杂度，对于追求简介的Redis而言，这是一个需要非常谨慎的事；

事实上，Reids6.0之后为I/O处理引入了多线程来提高性能，核心处理逻辑还是保留单线程，但是即使这样，6.0之后的复杂性还是多了许多，更别说完全改成多线程处理了。

### 1.2 多线程带来额外的成本

除了引入复杂度，多线程还会带来额外的成本。包括：

1. `上下文切换成本，多线程调度需要切换线程上下文`，这个操作先存储当前线程的本地数据、程序指针等，然后载入来一个线程数据，这种内核操作的成本不可忽视。

2. `同步机制的开销，一些公共资源`，在单线程模式下直接访问就行了，多线程需要通过加锁等方式进行同步，这也是不可忽视的CPU开销；

3. `一个线程本身也占据内存大小`，对Redis这种内存数据库而言，内存非常珍贵，多线程本身带来的内存使用的成本也需要谨慎决策。

所以综合来看，多线程其实会带来非常多的成本，如果将处理模块改为多线程，即使在性能上，可能也很难有一个很高的预期，毕竟Redis单线程的处理，已经够快了。

## 2、总结

我们上面看到，多线程会引入额外的复杂度和成本，而Redis是追求简洁高效的存储组件。

最终Redis选择单线程，其实是综合考虑成本和收益之后的决策，事实也证明，虽然是单线程处理架构，Redis性能还是经受住了考研，并以快而闻名。

下一节，会详细介绍Redis是怎么在单线程架构下，还能做到高性能，高并发。