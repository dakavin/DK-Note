## 1、压缩列表是什么？

上一节其实已经提过，压缩列表，顾名思义，就是排列紧凑的列表。

压缩列表在Redis中有两种编码方式，一种是ZIPLIST，平常说的压缩列表其实一般就是指ZIPLIST，一种是LISTPACK，LISTPACK是在Redis 5.0引入，直到Redis 7.0完全替换了ZIPLIST，可以说是ZIPLIST的进阶版本

## 2、压缩列表解决什么问题？

上一节讲解List的时候，我们说到压缩列表是List的底层数据结构，压缩列表主要用做为底层数据结构提供紧凑型的数据存储方式，能`节约内存`（节省链表指针的开销），小数据量的时候`遍历访问性能好`（连续+缓存命中率友好）。

## 3、ZIPLIST整体结构

我们先看一下ZIPLIST，虽然已经有LISTPACK，但实际面试中聊得比较多的，还是ZIPLIST。

Redis代码注释中，非常清晰地描述了ZIPLIST的结构：
```C
* The general layout of the ziplist is as follows:
*
* <zlbytes> <zltail> <zllen> <entry> <entry> .. <entry> <zlend>
```

比如，这就是有3个节点的ziplist结构：
![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/3acaaa07468926dc8c950d05cabbaa61.png)

我们来看看，各字段的含义：
- `zlbytes`：表示该ZIPLIST一共占了多少字节数，这个数字是包含zlbytes本身占据的字节的。
- `zltail`：ZIPLIST 尾巴节点 相对于ZIPLIST的开头（起始指针），偏移的字节数。
	- 通过这个字段可以`快速定位到尾部节点`，例如现在有一个ZIPLIST， zl指向它的开头，如果要获取tail尾巴节点，即ZIPLIST里的最后一个节点，可以 zl + zltail 的值，这样定位到它。如果没有尾节点，就定位到zlend。
- `zllen`：表示有多少个数据节点，在本例中就有3个节点
- `entry1~entry3`：表示压缩列表数据节点
- `zlend`：一个特殊的entru节点，表示ZIPLIST的结束

## 4、ZIPLIST节点结构

ZIPLIST ENTRIES定义如下：
```C
<prevlen> <encoding> <entry-data>
```

同样的，我们来看看，各字段的含义：
- `prevlen`：表示==上一个节点的数据长度==
	- 通过这个字段可以定位上一个节点的起始位置（或者说开头）也就是 p - prevlen 可以跳到前一个节点的开头位置，实现从后往前操作，所以压缩列表才可以从后往前遍历
	- 如果前一节点的长度，也就是`前一个entry的大小，小于254字节，那么prevlen属性需要用1字节长的空间来保存这个长度值`，255是特殊字符，被zlend使用了
	- 如果`前一节点的长度，大于等于254字节，那么prevlen属性需要用5字节长的空间来保存这个长度值`，注意5个字节中第一个字节为11111110，也就是254，表示这是个5字节的prevlen信息，剩下4字节来表示大小
- `encoding`：==编码类型==。
	- 还==包含了一个entry的长度信息==，可用于正向遍历
- `entry-data`：==实际的数据==

注意：prevlen记录是上个节点（entry）的总长度，encoding记录的是（entry-data）数据长度

### 4.1 encoding说明

encoding字段是一个整型数据，其二进制编码由`内容数据的类型`和`内容数据的字节长度`两部分组成，根据内容类型有如下几种情况：

`字符串类型`：

|编码|大小|类型|
|:-:|:-:|:-|
|00ppppp|1字节|String类型，且字符串长度小于2^6，即小于等于63|
|01pppppp qqqqqqqq|2字节|String类型，长度小于2^14，即小于等于16383|
|10000000 qqqqqqqq rrrrrrrr ssssssss tttttttt|5字节|String类型，长度小于2^32|
|11000000|1字节|2个字节的int16类型|
|11010000|1字节|4个字节的int32类型|
|11111110|1字节|8个字节的int64类型|
|1111xxxx|1字节|xxxx从1到13一共13个值，这时就用这13个值来表示真正的数据。注意，这里是表示真正的数据，而不是数据长度，这里种情况`<entry-data>`就没有了|
注意，如果是String类型，那么encoding有两部分，一般是前几位表示类型，后几位表示长度。

但如果是int类型，整体1字节编码，就表示了类型，为什么没有大小呢，因为int的具体类型就自带了大小，比如int32，就是32位，4字节的大小，不需要encoding特表表示。

encoding的编码规则比较复杂，我们其实只需要理解它的核心实现，`面试中能讲清楚怎么区分不同类型即可`，不用去背它的这些具体编码，这个很难记住，也没有必要去记。
## 5、ZIPLIST查询数据

我们聚焦看两个关键的查询操作，来理解ZIPLIST是如何运作的。
### 5.1 查询ZIPLIST的数据总量

由于ZIPLIST的header定义了记录节点数量的字段zllen，所以通常是可以在O(1)时间复杂度直接返回的，为什么说通常呢？

当zllen大于65534时，zllen就存不下了，此时zllen等于65535，所以真实的节点数量需要遍历来得到。

这样设计的原因是Redis中应用ZIPLIST都是为了节点个数少的场景，所以将zllen设计得较少，节约内存空间。

### 5.2 在ZIPLIST中查询指定数据的节点

在ZIPLIST中查询指定数据的节点，需要遍历这里压缩列表，平均时间复杂度是O(N)

## 6、ZIPLIST更新数据

ZIPLIST的更新就是增加、删除数据，ZIPLIST提供头尾增减的能力，但是操作平均时间复杂度是O(N)，因为在头部增加一个节点会导致后面的节点都往后移动，所以更新的平均时间复杂度，可以看做O(N)

其中要注意的是`更新操作可能会带来连锁更新`。注意上面所说的增加节点导致后移，不是连锁更新。`连锁更新是指这个后移，发生了不止一次，而是多次`。

比如增加一个头部新节点，后面依赖它的节点，需要prevlen字段记录它的大小，原本只用1字节记录，因为更新可能膨胀为5字节，然后这个entry的大小也就膨胀了。所以，当这个新数据插入导致的后移完成之后，还需要逐步迭代更新。这种现象就是连锁更新，时间复杂度是O(N^2)，6.2已经优化为O(N）；

大家可能会比较担心连锁更新带来的性能问题，但在实际的业务中，很少会刚好遇到需要迭代更新超过2个节点的情况，所以ZIPLIST更新平均时间复杂度，还是可以看做O(N)。不过，`ZIPLIST最大的问题还是连锁更新导致性能不稳定`。

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/1fb1856f874ef340382e2552ccb48ec6.png)

## 7、LISTPACK优化

### 7.1 连锁更新原因分析

LISTPACK是为了解决ZIPLIST最大的痛点——连锁更新，ZIPLIST的问题本源。

我们知道ZIPLIST需要支持LIST，LIST是一种双端访问结构，所以需要能从后往前遍历，上面有讲，ZIPLIST的数据节点的结构是这样的：
```C
<prevlen> <encoding> <entry-data>
```

其中，prevlen就表示上一个节点的数据长度，通过这个字段可以定位上一个节点的数据，可以说，连锁更新的问题就是因为prevlen导致的。

### 7.2 对症下药

我们需要一种不记录prevlen，并且还能找到上一个节点的起始位置的办法，Redis使用了很巧妙的一种方式。

我们直接看LISTPACK的节点定义
```C
<encoding-type> <element-data> <element-tot-len>
```

encoding-type是编码类型，element-data是数据内容，`element-tot-len存储整个节点除了它自身之外的长度`。找到上一个节点的秘密就藏在element-tot-len：

- element-tot-len所占用的每个字节的第一个bit用于标识是否结束。0是结束，1是继续，剩下7个bit来存储数据大小。当我们需要找到当前节点的上一个节点时，我们可以`从后往前依次查找每个字节`，找到上一个entry的element-tot-len字段的结束标识，就可以算出上一个节点的首位置了。

举个例子：
- 如果上个节点的element-tot-len为 00000001 10000100，每个字节的第一个bit标识是否结束，所以这里的element-tot-len一共就两个字节，大小为00000001 10000100，即132字节。

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/84cd8ae434965680d5f5587fc162becb.png)

 
## 8、总结

本次我们的重点是搞清楚压缩列表是节约内存的一种数据结构，它采用了将数据紧密排列的形式来压缩空间，同时我们需要理解ZIPLIST基本操作是怎样的。

针对ZIPLIST，比较重要的是能理解它节约内存的思路，一些细枝末节，比如具体到字符串/整型的编码标记这种有个大概印象即可。