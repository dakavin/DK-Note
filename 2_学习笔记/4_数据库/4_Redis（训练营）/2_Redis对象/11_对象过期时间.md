
## 1、对象过期时间是什么

Redis的过期时间是给一个Key，指定一个时间点，等达到这个时间，数据就被认为是过期数据，可以由Redis进行回收。

## 2、为什么要过期时间

如果不是需要常驻的数据，设置过期时间，可以有效地节约内存。

另外，有些场景功能也需要过期时间支持，比如缓存，如果存在时间过久，就可能导致和数据源数据差距过大，而设置过期时间，可以很方便的清除缓存以便后续再次加载进去。

又比如分布式锁，就是需要一定时间之后，数据自动消失，以实现最大占据时间的特性。

## 3、怎么设置过期时间

如果是简单的字符串对象，可以使用如下语法：

- `SET key value EX seconds`：设置多少秒之后过期
- `SET key value PX milliseconds`：设置多少毫秒之后过期
- `TTL key`：查看还有多久过期

```shell
127.0.0.1:6379> set tmpkey data ex 5
OK
127.0.0.1:6379> ttl tmpkey
(integer) 2
127.0.0.1:6379> get tmpkey
(nil)

127.0.0.1:6379> set tmpkey data px 5000
OK
127.0.0.1:6379> ttl tmpkey
(integer) 2
127.0.0.1:6379> get tmpkey
(nil)
```

更通用的过期命令是EXPIRE，它可以对所有数据对象设置过期时间，EXPIRE也分秒和毫秒：

- `EXPIRE key seconds`：设置一个key的过期时间，单位为秒
- `PEXPIRE key milliseconds`：设置一个key的过期时间，单位为毫秒

`设置过期时间之后会有个字典，专门记录这些Key和过期时间的关系，这里不展开说，后面在将Redis内存的时候会详细分析`。

## 4、键过期了多久删除

过期之后的键实际上`不是立刻删除的`，一般过期键清除策略有三种，分别是`定时删除`、`定期删除`和`惰性删除`

定时删除：
- 在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作
- 定时删除对内存比较友好，但是对CPU不友好，如果某个时间段比较多的Key过期，可能会影响命令处理性能

定期删除：
- 每个一段时间，程序就对数据库进行一次检查，每次删除一部分过期键，这属于一种渐进式兜底策略

惰性删除：
- 指使用的时候，发现Key过期了，此时再继续删除，这个策略的思路是对应用而言，只要不访问，过期不过期业务都无所谓，但是这样的 代价就是如果某些key一直不来访问，那本该过期的key，就变成了常驻key。
- 这种策略对CPU最友好，对内存不太友好。


定时删除实现起来没有想象的容易，主要考虑是如果出现异常，有Key遗漏了怎么办，以及如果程序重启，原来的定时器就随重启消失了，那就需要再启动时对过期键进行一些操作，可能是重建定时器，这些都是额外的工作，而且引入了多余的复杂度。

从实际功能而言，其实并不需要那么实时，所以惰性删除是可以考虑的，但是出于应删尽删的考虑，要保证最终没有漏网之鱼，那就需要假设定期删除多为兜底。

所以`Redis过期采用的是惰性删除+定期删除二者结合的方式`进行删除的

![](https://image-for.oss-cn-guangzhou.aliyuncs.com/for-obsidian/Java_Study/2_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_Java%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83/1_Java%E5%9F%BA%E7%A1%80/1_Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/Pasted%20image%2020231021143438.png)

惰性删除不用再多说，Redis每次访问Key前都会进行检测，如已过期就删除。

定期删除就需要关注两个问题：

1. 定期删除的频率；
	- 这个其实取决于Redis周期任务的执行频率，周期任务里面会做关闭过期客户端、删除过期Key的一系列任务，可以用INFO查看周期任务频率
```shell
127.0.0.1:6379> info
# Server
redis_version:5.0.14.1
redis_git_sha1:ec77f72d
redis_git_dirty:0
redis_build_id:5627b8177c9289c
redis_mode:standalone
os:Windows
arch_bits:64
multiplexing_api:WinSock_IOCP
atomicvar_api:pthread-mutex
process_id:1472
run_id:506646579c2e883911a4282efc9d5b674c96cbf9
tcp_port:6379
uptime_in_seconds:618
uptime_in_days:0
hz:10
configured_hz:10
lru_clock:3293941
executable:g:\redis\redis-x64-5.0.14.1\redis-server.exe
config_file:
```

hz就是频率，默认是10，也就是每秒触发10次周期任务

2. 每次删除的数量。
	- 每次检测的数量是写死在代码里的，每次20个，但是这里还会检查过期key数量占比，大于25%，则再抽取20个来检查，重复流程，这里是一个循环
	- Redis为了保证定期删除不会出现循环过去，导致线程卡死现象，为此增加了定期删除循环流程的时间上限，默认不会超过25ms。
```shell
#define ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP 20
/* Loopups per loop */
```

