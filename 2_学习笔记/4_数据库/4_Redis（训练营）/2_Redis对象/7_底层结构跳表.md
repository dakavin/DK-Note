
[推荐参考文章 Skip List--跳表](https://www.jianshu.com/p/9d8296562806)
## 1 跳表是什么

跳表是Redis有序集合ZSet底层的数据结构，也是ZSet的灵魂所在，之前的章节都是先讲操作对象，再聊设计的底层结构，但ZSet中跳表占的比重太大，同时跳表也不像HASHTABLE三言两语可以有一个直观认识，所以这里就先讲跳表了。

跳表的本质上还是链表，普通链表结构如下：![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/b80eb8a5cad608757e4066738cc0882f.png)
这种结构虽然简单清晰，但是查询某个节点的效率比较低，而在有序集合场景，无论是查找还是添加删除元素，我们是需要能快速通过score定位到具体位置，如果链表那时间复杂度其实就是O(N)，N是节点个数。

为了提升查找的性能，Redis就引入了跳表，跳表在链表的基础上，给链表增加了多级的索引，通过索引可以一次实现多个节点跳跃，提高性能。

`跳表的思想，用“空间换时间”，通过给链表建立索引，提高了查找的效率。`
## 2 跳表的结构

可能说到现在，也只是大概有了个模糊的认识，下面我们来看看跳表具体结构是怎么样的，我们先看这个示意图：![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/fc5335b79b881cf6354005dcd34a09f0.png)
可以看到，这个图某些节点不光只有一层，如果只用普通链表，只能一步步往后走，如果用这种有高层的节点，那是不是可以一次多走几步，理论上，层次越高平均步长越大，但并不完全像示意图一样是绝对均衡的，节点的层高其实是概率随机的，这个我们下面会分析，我们暂时初步理解即可。

为了理解这个结构有什么好处，我们分几个场景来分析

- 场景一：`查找`分数为35的数据
	- 如果只有原始链表，那需要走4步，如果有图中的二级索引，只用走一步，那如果找45呢，其实就是从第1个节点触发，通过二级索引走到35，在查看到下一个节点是65，已经超过了，所以降低到下方的索引，也就是一级索引，往后走一次就可以找到45。

- 场景二：`插入`一条score为36的数据
	- 首先，定位到第一个比score大的位置，这里是45，查找方式和查询类似，不再赘述
	- 然后，构造一个新的节点，这里我们假设节点层高随机到3，具体随机算法我们后面会介绍，目前不用太关注
	- 最后，将各层链表补齐，其实就是在每一层进行连接，效果如图![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/59aaecd9376b7345610f4ab8d6bf4083.png)

标准的跳表（Redis不是用的标准跳表，下面会讲）有如下限制：
1. `score值不能重复`
2. `只有向前指针，没有回退指针`

在Redis中，跳表是用来支持有序集合的，所以Redis就对跳表做了一些优化，就包括`score可以重复`，`增加回退指针`，下面我们来看看Redis的跳表

## 3 Redis的跳表实现

我们直接看这个示意图，score可以重复并且我们的每个节点多了一下回退指针。
![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/6d07e94708031833fb3c2aaac0fa301a.png)

下面我们结合源码，来和示意图对照学习，以加深理解，这是Redis跳表单个节点的定义：
```C
// from Redis 7.0.8
/* ZSETs use a specialized version of Skiplists */
typedef struct zskiplistNode{
	sds ele;
	double score;
	struct zskiplistNode *backward;
	struct zskiplistLevel{
		struct zskiplistNode *forward;
		unsigned long span；
	} level[]; 
} zskiplistNode;
```

我们来看看字段含义：
- ele：很熟悉的SDS结构，用来存储数据
- score：节点的分数，浮点型数据
- backward：指向上一个节点的回退指针，支持从表尾向表头遍历，也就是ZREVRANGE这个命令
- level：是个zskiplistLevel结构体数组，zskiplistLevel这个结构体包含了两个字段，一个是forward，指向该层下个能跳到的节点，span记录了距离下个节点的步数，数组结构就表示每个节点都可能是个多层结构。

以上字段，其实和我们的示意图就是完全匹配的。这里再贴一张示意图：![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/89404b834720c7eeb7df839854485301.png)
下面，我们来探讨下几个关键的细节

## 4 Redis跳表单个节点有几层

层次的决定，需要比较随机，才能在各个场景表现出较为平均的性能，这里Redis使用概率均衡的思路来确定新插入节点的层数；

`Redis跳表决定每一个节点，是否能增加一层的概率为25%，而最大层数限制在Redis5.0是64层，在Redis7.0是32层`。

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/494d74db679108e2bcc80fbaafc18e6f.png)
## 5 Redis跳表的性能优化了多少

这个其实可以很容易想到，跳表的查找过程，其实是走高层，行得通跳过去，行不通走相对下层，很想二叉树的另一种表现形式，实际上他们性能也是差不多的，`平均复杂度都是O(logn)`，区别是二叉树最坏情况下也是O(logn)比较稳定，而`跳表最坏时间复杂度是O(N)`。当然，实际的生产过程中，体现出来的基本都是跳表的平均时间复杂度。

前面也提到，有序集合无论是查找、还是增加删除元素，都是需要先查询到数据为止，所以跳表将这个三个操作的时间复杂度，都从O(N)降低到O(logn)

## 6 总结

本节我们认识了跳表这个实现上非常巧妙的数据结构，也分析了跳表的结构和优化的效果。下一节，我们将会分析跳表相关的面试知识，完成之后我们再加入到有序集合的学习。