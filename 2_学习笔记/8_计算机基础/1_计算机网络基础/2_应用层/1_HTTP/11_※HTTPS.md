
确保Web安全的HTTPS

在 HTTP 协议中有可能存在信息窃听或身份伪装等安全问题。使用 HTTPS 通信机制可以有效地防止这些问题。本章我们就了解一下 HTTPS。

## 1、HTTP的缺点

到现在为止，我们已了解到 HTTP 具有相当优秀和方便的一面，然而 HTTP 并非只有好的一面，事物皆具两面性，它也是有不足之处的。 

HTTP 主要有这些不足，例举如下。 
- `通信使用明文（不加密）`，内容可能会被窃听 
- `不验证通信方的身份`，因此有可能遭遇伪装 
- `无法证明报文的完整性`，所以有可能已遭篡改

这些问题不仅在 HTTP 上出现，其他未加密的协议中也会存在这类问 题。 

除此之外，HTTP 本身还有很多缺点。而且，还有像某些特定的 Web 服务器和特定的 Web 浏览器在实际应用中存在的不足（也可以说成是脆弱性或安全漏洞），另外，用 Java 和 PHP 等编程语言开发的 Web 应用也可能存在安全漏洞。

### 1.1 通信使用明文可能会被窃听

由于 HTTP 本身不具备加密的功能，所以也无法做到对通信整体（使用 HTTP 协议通信的请求和响应的内容）进行加密。即，HTTP 报文使用明文（指未经过加密的报文）方式发送。

`TCP/IP 是可能被窃听的网络`
- 如果要问为什么通信时不加密是一个缺点，这是因为，按 TCP/IP 协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视。 
- 所谓互联网，是由能连通到全世界的网络组成的。无论世界哪个角落的服务器在和客户端通信时，在此通信线路上的某些网络设备、光缆、计算机等都不可能是个人的私有物，所以不排除某个环节中会遭到恶意窥视行为。 
- 即使已经过加密处理的通信，也会被窥视到通信内容，这点和未加密的通信是相同的。只是说如果通信经过加密，就有可能让人无法破解报文信息的含义，但加密处理后的报文信息本身还是会被看到的。![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/71ac73438d121d2d856f290d4881e48e.png)
- 窃听相同段上的通信并非难事。只需要收集在互联网上流动的数 据包（帧）就行了。对于收集来的数据包的解析工作，可交给那些抓包（Packet Capture）或嗅探器（Sniffer）工具。 

- 下面的图片示例就是被广泛使用的抓包工具 Wireshark。它可以 获取 HTTP 协议的请求和响应的内容，并对其进行解析。 

- 像使用 GET 方法发送请求、响应返回了 200 OK，查看 HTTP 响应报文的全部内容等一系列的事情都可以做到。![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/a00cca1cca692a59de3171fceb5ce5d4.png)
`加密处理防止被窃听`
在目前大家正在研究的如何防止窃听保护信息的几种对策中，最为普及的就是加密技术。加密的对象可以有这么几个。 
- 通信的加密 
	- 一种方式就是`将通信加密`。
		- HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security，安全层传输协议）的组合使用， 加密 HTTP 的通信内容。 
		- 用 SSL建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。`与 SSL组合使用的 HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）或 HTTP over SSL`![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/8730b4cb700eab5bea7c699c769e9fec.png)
	- 还有一种将参与通信的`内容本身加密`的方式。
		- 由于 HTTP 协议中 没有加密机制，那么就对 HTTP 协议传输的内容本身加密。即把 HTTP 报文里所含的内容进行加密处理。
		- 在这种情况下，客户端需要对 HTTP 报文进行加密处理后再发送 请求。![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/429baee99571d441846f1b62d74370fa.png)
		- 诚然，为了做到有效的内容加密，前提是要求客户端和服务器同 时具备加密和解密机制。主要应用在 Web 服务中。有一点必须引起注意，由于该方式不同于 SSL或 TLS 将整个通信线路加密处理，所以内容仍有被篡改的风险。稍后我们会加以说明。
### 1.2 不验证通信方的身份就可能遭遇伪装

HTTP 协议中的请求和响应不会对通信方进行确认。也就是说存在“服务器是否就是发送请求中 URI 真正指定的主机，返回的响应是否真的返回到实际提出请求的客户端”等类似问题

`任何人都可发起请求`
- 在 HTTP 协议通信时，由于不存在确认通信方的处理步骤，任何 人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的 IP 地址和端口号没有被 Web 服务器设定限制访问的前提下）![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/1950d21de9e3c31f86034ff1726313df.png)
- HTTP 协议的实现本身非常简单，不论是谁发送过来的请求都会 返回响应，因此不确认通信方，会存在以下各种隐患。
	- 无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有`可能是已伪装的 Web 服务器`。
	- 无法确定响应返回到的客户端是否是按真实意图接收响 应的那个客户端。有`可能是已伪装的客户端`。
	- 无法确定正在通信的对方是否具备访问权限。因为某些 Web 服务器上保存着重要的信息，只想发给特定用户通 信的权限。
	- 无法判定请求是来自何方、出自谁手。
	- 即使是无意义的请求也会照单全收。无法阻止海量请求 下的 DoS 攻击（Denial of Service，拒绝服务攻击）。

`查明对手的证书`
- 虽然使用 HTTP 协议无法确定通信方，但如果使用 SSL则可以。 ==SSL不仅提供加密处理，而且还使用了一种被称为证书的手段， 可用于确定方==。
- 证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外，伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方（服务器或客户端）持有的证书， 即可判断通信方的真实意图。![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/fdbce27ad02544f792b83e7775b21687.png)
- 通过使用证书，以证明通信方就是意料中的服务器。这对使用者个人来讲，也减少了个人信息泄露的危险性。
- 另外，客户端持有证书即可完成个人身份的确认，也可用于对 Web 网站的认证环节。
### 1.3 无法证明报文完整性，可能已遭篡改

所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味 着无法判断信息是否准确。

`接收到的内容可能有误`
- 由于 HTTP 协议无法证明通信的报文完整性，因此，在请求或响 应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。
- 换句话说，没有任何办法确认，发出的请求 / 响应和接收到的请 求 / 响应是前后相同的。![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/d27a5a1040a1b80519670a9dc4cbb442.png)
- 比如，从某个 Web 网站上下载内容，是无法确定客户端下载的 文件和服务器上存放的文件是否前后一致的。文件内容在传输途 中可能已经被篡改为其他的内容。即使内容真的已改变，作为接收方的客户端也是觉察不到的。
- 像这样，请求或响应在传输途中，遭攻击者拦截并篡改内容的攻 击称为`中间人攻击（Man-in-the-Middle attack，MITM）`。![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/4ef5f9763742f6eb34cb3f433ea387ec.png)
`如何防止篡改`
- 虽然有使用 HTTP 协议确定报文完整性的方法，但事实上并不便 捷、可靠。其中常用的是 MD5 和 SHA-1 等散列值校验的方法， 以及用来确认文件的数字签名方法。![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/d1cda28f55f2c8205e400dede0c24ea3.png)
- 提供文件下载服务的 Web 网站也会提供相应的以 PGP（Pretty Good Privacy，完美隐私）创建的`数字签名`及 MD5 算法生成的`散列值`。PGP 是用来证明创建文件的数字签名，MD5 是由单向函数生成的散列值。不论使用哪一种方法，都需要操纵客户端的用户本人亲自检查验证下载的文件是否就是原来服务器上的文件。 浏览器无法自动帮用户检查。
- 可惜的是，用这些方法也依然无法百分百保证确认结果正确。因 为 PGP 和 MD5 本身被改写的话，用户是没有办法意识到的。
- 为了有效防止这些弊端，有必要使用 HTTPS。SSL提供认证和加 密处理及摘要功能。仅靠 HTTP 确保完整性是非常困难的，因此 通过和其他协议组合使用来实现这个目标。下节我们介绍 HTTPS 的相关内容。

## 2、HTTP + 加密 + 认证 + 完整性保护 = HTTPS

### 2.1 HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS

如果在 HTTP 协议通信过程中使用未经加密的明文，比如在 Web 页 面中输入信用卡号，如果这条通信线路遭到窃听，那么信用卡号就暴 露了。 

另外，对于 HTTP 来说，服务器也好，客户端也好，都是没有办法确认通信方的。因为很有可能并不是和原本预想的通信方在实际通信。 并且还需要考虑到接收到的报文在通信途中已经遭到篡改这一可能 性。

为了统一解决上述这些问题，需要在 HTTP 上再加入加密处理和认证 等机制。我们把添加了加密及认证机制的 HTTP 称为 HTTPS（HTTP Secure）。![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/cfba1e8250531c7d3c21dcc7eaf9cb73.png)
经常会在 Web 的登录页面和购物结算界面等使用 HTTPS 通信。使用 HTTPS 通信时，不再用 `http://，而是改用 https://`。另外，当浏览器访 问 HTTPS 通信有效的 Web 网站时，浏览器的地址栏内会出现一个带锁的标记。对 HTTPS 的显示方式会因浏览器的不同而有所改变。
![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/451b941a714e3901927424ba1176d860.png)
### 2.2 HTTPS 是身披 SSL 外壳的 HTTP

HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。

通常，HTTP 直接和 TCP 通信。当使用 SSL时，则演变成先和 SSL通 信，再由 SSL和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL协议这层外壳的 HTTP。
![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/c5b29884bf3889d396cb4de1cfbf4917.png)

在采用 SSL后，HTTP 就拥有了 HTTPS 的`加密`、`证书`和`完整性保护`这些功能。

SSL是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在应 用层的 SMTP 和 Telnet 等协议均可配合 SSL协议使用。可以说 SSL是 当今世界上应用最为广泛的网络安全技术。
### 2.3 相互交换密钥的公开密钥加密技术

在对 SSL进行讲解之前，我们先来了解一下加密方法。`SSL采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式`。

近代的加密方法中加密算法是公开的，而密钥却是保密的。通过这种 方式得以保持加密方法的安全性。 

加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说， 任何人只要持有密钥就能解密了。如果密钥被攻击者获得，那加密也 就失去了意义。

`共享密钥加密的困境`
- 加密和解密同用一个密钥的方式称为共享密钥加密（Common key crypto system），也被叫做对称密钥加密。![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/6addbfad587747f3fe13e91448ddccb3.png)
- 以共享密钥方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落入攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/fb2799a4bc7a92511914c26bf8d36b95.png)
`使用两把密钥的公开密钥加密`
- 公开密钥加密方式很好地解决了共享密钥加密的困难。
- 公开密钥加密使用一对非对称的密钥。一把叫做==私有密钥== （private key），另一把叫做==公开密钥==（public key）。顾名思 义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发 布，任何人都可以获得。
- 使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。
- 另外，要想根据密文和公开密钥，恢复到信息原文是异常困难的，因为解密过程就是在对离散对数进行求值，这并非轻而易举就能办到。退一步讲，如果能对一个非常大的整数做到快速地因式分解，那么密码破解还是存在希望的。但就目前的技术来看是不太现实的。![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/9e43f81f7df5e97a01133919b3ece80f.png)

`HTTPS 采用混合加密机制`
- HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。
- 所以应充分利用两者各自的优势，将多种方法组合起来用于通信。在`交换密钥环节使用公开密钥加密方式`，之后的`建立通信交换报文阶段则使用共享密钥加密方式`。![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/3efd6df2011a26055fa7362ee2555d23.png)
### 2.4 证明公开密钥正确性的证书

遗憾的是，公开密钥加密方式还是存在一些问题的。那就是无法证明 公开密钥本身就是货真价实的公开密钥。比如，正准备和某台服务器 建立公开密钥加密方式下的通信时，如何证明收到的公开密钥就是原 本预想的那台服务器发行的公开密钥。或许在公开密钥传输途中，真 正的公开密钥已经被攻击者替换掉了。

为了解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其相关机关颁发的公开密钥证书。 

`数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的 立场上`。威瑞信（VeriSign）就是其中一家非常有名的数字证书认证机构。我们来介绍一下数字证书认证机构的业务流程。
- 首先，服务器的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。 
- 服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端， 以进行公开密钥加密方式通信。
- ==公钥证书也可叫做数字证书或直接称为证书==。 
- 接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事： 一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二， 服务器的公开密钥是值得信赖的。 
- 此处认证机关的公开密钥必须安全地转交给客户端。使用通信方式 时，如何安全转交是一件很困难的事，因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/3d9e2cceac2e9933e1b837afd11b72f2.png)

`可证明组织真实性的 EV SSL 证书`
- 证书的一个作用是用来==证明作为通信一方的服务器是否规范==，另外一个作用是可==确认对方服务器背后运营的企业是否真实存在==。 拥有该特性的证书就是 EV SSL证书（Extended Validation SSL Certificate）。 
- EV SSL证书是基于国际标准的认证指导方针颁发的证书。其严格规定了对运营组织是否真实的确认方针，因此，通过认证的 Web 网站能够获得更高的认可度。 
- 持有 EV SSL证书的 Web 网站的浏览器地址栏处的背景色是绿色 的，从视觉上就能一眼辨别出。而且在地址栏的左侧显示了 SSL 证书中记录的组织名称以及颁发证书的认证机构的名称。
- 上述机制的原意图是为了防止用户被钓鱼攻击（Phishing），但 就效果上来讲，还得打一个问号。很多用户可能不了解 EV SSL 证书相关的知识，因此也不太会留意它。

`用以确认客户端的客户端证书`
- HTTPS 中还可以使用客户端证书。以客户端证书进行客户端认 证，证明服务器正在通信的对方始终是预料之内的客户端，其作用跟服务器证书如出一辙。 
- 但客户端证书仍存在几处问题点。其中的一个问题点是证书的获取及发布。 
- 想获取证书时，用户得自行安装客户端证书。但由于客户端证书是要付费购买的，且每张证书对应到每位用户也就意味着需支付 和用户数对等的费用。另外，要让知识层次不同的用户们自行安装证书，这件事本身也充满了各种挑战。 
- 现状是，安全性极高的认证机构可颁发客户端证书但仅用于特殊用途的业务。比如那些可支撑客户端证书支出费用的业务。 
- 例如，银行的网上银行就采用了客户端证书。在登录网银时不仅要求用户确认输入 ID 和密码，还会要求用户的客户端证书，以 确认用户是否从特定的终端访问网银。
- 客户端证书存在的另一个问题点是，客户端证书毕竟只能用来证明客户端实际存在，而不能用来证明用户本人的真实有效性。也就是说，只要获得了安装有客户端证书的计算机的使用权限，也 就意味着同时拥有了客户端证书的使用权限。

`认证机构信誉第一`
- SSL机制中介入认证机构之所以可行，是因为建立在其信用绝对可靠这一大前提下的。然而，2011 年 7 月，荷兰的一家名叫 DigiNotar 的认证机构曾遭黑客不法入侵，颁布了 google.com 和 twitter.com 等网站的伪造证书事件。这一事件从根本上撼动了 SSL的可信度。 
- 因为伪造证书上有正规认证机构的数字签名，所以浏览器会判定该证书是正当的。当伪造的证书被用做服务器伪装之时，用户根 本无法察觉到。 
- 虽然存在可将证书无效化的证书吊销列表（Certificate Revocation List，CRL）机制，以及从客户端删除根证书颁发机构（Root Certificate Authority，RCA）的对策，但是距离生效还需要一段时间，而在这段时间内，到底会有多少用户的利益蒙受损失就不得而知了。

`由自认证机构颁发的证书称为自签名证书`
- 如果使用 OpenSSL这套开源程序，每个人都可以构建一套属于 自己的认证机构，从而自己给自己颁发服务器证书。但该服务器证书在互联网上不可作为证书使用，似乎没什么帮助。 
- 独立构建的认证机构叫做自认证机构，由自认证机构颁发的“无用”证书也被戏称为自签名证书。 
- 浏览器访问该服务器时，会显示“无法确认连接安全性”或“该网站的安全证书存在问题”等警告消息。
- 由自认证机构颁发的服务器证书之所以不起作用，是因为它无法消除伪装的可能性。自认证机构能够产生的作用顶多也就是自己对外宣称“我是○○”的这种程度。即使采用自签名证书，通过 SSL 加密之后，可能偶尔还会看见通信处在安全状态的提示，可那也是有问题的。因为就算加密通信，也不能排除正在和已经过伪装的假服务器保持通信。 
- 值得信赖的第三方机构介入认证，才能让已`植入在浏览器内的认证机构颁布的公开密钥发挥作用`，并借此证明服务器的真实性。
- 中级认证机构的证书可能会变成自认证证书 
- 多数浏览器内预先已植入备受信赖的认证机构的证书，但也有一小部分浏览器会植入中级认证机构的证书。 
- 对于中级认证机构颁发的服务器证书，某些浏览器会以正规的证书来对待，可有的浏览器会当作自签名证书。
### 2.5 HTTPS 的安全通信机制

为了更好地理解 HTTPS，我们来观察一下 HTTPS 的通信步骤。
![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/6f92fbd627366bbbed8ee53963a20c78.png)

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/7ca943ecb0e89bd7f8648b63d4c57b59.png)

- 步骤 1： 客户端通过发送 Client Hello 报文开始 SSL通信。报文中包含==客户端支持的 SSL的指定版本==、==加密组件（Cipher Suite）列表==（所使用的加密算法及密钥长度等）。 

- 步骤 2： 服务器可进行 SSL通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 ==SSL版本==以及==加密组件==。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。 

- 步骤 3： 之后服务器发送 Certificate 报文。报文中包含==公开密钥证书==。 

- 步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，`最初阶段的 SSL握手协商部分结束`。 

- 步骤 5： SSL第一次握手结束之后，客户端以 Client Key Exchange报文作为回应。报文中==包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密==。 

- 步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在==此报文之后的通信会采用 Pre-master secret 密钥加密==。 

- 步骤 7： 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。 

- 步骤 8： 服务器同样发送 Change Cipher Spec 报文。 步骤 9： 服务器同样发送 Finished 报文。 

- 步骤 10： `服务器和客户端的 Finished 报文交换完毕之后，SSL连接就算建立完成`。当然，通信会受到 SSL的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。 

- 步骤 11： 应用层协议通信，即发送 HTTP 响应。 

- 步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify 报 文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。 

在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。 

下面是对整个流程的图解。图中说明了从仅使用服务器端的公开密钥 证书（服务器证书）建立 HTTPS 通信的整个过程。
![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/0b234d0cdc16f57a8fa9f127de3f627e.png)

### 2.5.1 SSL 和 TLS

HTTPS 使用 SSL（Secure Socket Layer） 和 TLS（Transport Layer Security）这两个协议。 

SSL技术最初是由浏览器开发商网景通信公司率先倡导的，开发过 SSL3.0之前的版本。目前主导权已转移到 IETF（Internet Engineering Task Force，Internet 工程任务组）的手中。

IETF 以 SSL3.0 为基准，后又制定了 TLS1.0、TLS1.1 和 TLS1.2。TSL是以 SSL为原型开发的协议，有时会统一称该协议为 SSL。当前主流的版本是 SSL3.0 和 TLS1.0。 

由于 SSL1.0 协议在设计之初被发现出了问题，就没有实际投入 使用。SSL2.0 也被发现存在问题，所以很多浏览器直接废除了 该协议版本。
### 2.5.2 SSL 速度慢吗

HTTPS 也存在一些问题，那就是当使用 SSL时，它的处理速度 会变慢。![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/e92c48fde0052a0816896616ef3b071b.png)
SSL的慢分两种。一种是指`通信慢`。另一种是指由于大量消耗 CPU 及内存等资源，导致`处理速度变慢`。 

和使用 HTTP 相比，网络负载可能会变慢 2 到 100 倍。除去和 TCP 连接、发送 HTTP 请求 • 响应以外，还必须进行 SSL通信， 因此整体上处理通信量不可避免会增加。 

另一点是 SSL必须进行加密处理。在服务器和客户端都需要进行 加密和解密的运算处理。因此从结果上讲，比起 HTTP 会更多地消耗服务器和客户端的硬件资源，导致负载增强。 

针对速度变慢这一问题，并没有根本性的解决方案，我们会使用 SSL加速器这种（专用服务器）硬件来改善该问题。该硬件为 SSL通信专用硬件，相对软件来讲，能够提高数倍 SSL的计算速 度。仅在 SSL处理时发挥 SSL加速器的功效，以分担负载。

### 2.5.3 为什么不一直使用 HTTPS

既然 HTTPS 那么安全可靠，那为何所有的 Web 网站不一直使用 HTTPS ？ 

其中一个原因是，因为`与纯文本通信相比，加密通信会消耗更多的 CPU 及内存资源`。如果每次通信都加密，会消耗相当多的资源，平 摊到一台计算机上时，能够处理的请求数量必定也会随之减少。 

因此，如果是非敏感信息则使用 HTTP 通信，只有在包含个人信息 等敏感数据时，才利用 HTTPS 加密通信。 

特别是每当那些访问量较多的 Web 网站在进行加密处理时，它们 所承担着的负载不容小觑。在进行加密处理时，并非对所有内容都进行加密处理，而是仅在那些需要信息隐藏时才会加密，以节约资源。

除此之外，想要节约`购买证书的开销也是原因之一`。 

要进行 HTTPS 通信，证书是必不可少的。而使用的证书必须向认 证机构（CA）购买。证书价格可能会根据不同的认证机构略有不 同。通常，一年的授权需要数万日元（现在一万日元大约折合 600 人民币）。 

那些购买证书并不合算的服务以及一些个人网站，可能只会选择采 用 HTTP 的通信方式。

## 3、数字证书

1.

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/0a3c1343033691312369bb255e82859e.png)

鲍勃有两把钥匙，一把是公钥，另一把是私钥。

2.

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/adae32dd7d25f392f28afdad12bfaac2.png)

鲍勃把公钥送给他的朋友们----帕蒂、道格、苏珊----每人一把。

3.

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/59d13a2824992cfaf52c031df9e50294.png)

苏珊要给鲍勃写一封保密的信。她写完后用鲍勃的公钥加密，就可以达到保密的效果。

4.

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/510c5194f1f6d3bc6a704999efd8272d.png)

鲍勃收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要鲍勃的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。

5.

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/0245613083ac77767d44363b5c6b47c7.png)

鲍勃给苏珊回信，决定采用"数字签名"。他写完后先用Hash函数，生成信件的摘要（digest）。

6.

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/49a3f2257dafcc4410d910f7a595593d.png)

然后，鲍勃使用私钥，对这个摘要加密，生成"数字签名"（signature）。

7.

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/94fb9e16abf561e86648545596990904.png)

鲍勃将这个签名，附在信件下面，一起发给苏珊。

8.

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/46f291275a190f6a8fde2c1e541c15a7.png)

苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。

9.

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/6c0350228160873a2c0fce55e59dad0c.png)

苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。

10.

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/cd1b6574f8112d3ba90b951819df4836.png)

复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，用自己的私钥做成"数字签名"，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。

11.

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/974610e3cd453192126b521de2b6e101.png)

后来，苏珊感觉不对劲，发现自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找"证书中心"（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成"数字证书"（Digital Certificate）。

12.

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/f29192a8bcceb8f17214b972473c4934.png)

鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。

13.

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/0bc0eb1463f263afe34745a9c23899c7.png)

苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明"数字签名"是否真的是鲍勃签的。

14.

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/5ae20367e4229e665df68cc91aa50606.jpeg)

下面，我们看一个应用"数字证书"的实例：https协议。这个协议主要用于网页加密。

15.

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/4cdd45cdebee1dbd8ec02525ed22affb.png)

首先，客户端向服务器发出加密请求。

16.

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/1e1d39a0d34ebed4dd30fb85329f1e5c.png)

服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。

17.

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/8474765707f783739a3118a27bfb9483.png)

客户端（浏览器）的"证书管理器"，有"受信任的根证书颁发机构"列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。

18.

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/5bb52cc17d71512b6205349b19751bd1.png)

如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。

19.

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/52d49f4e0b961719af0fd35f97f2afc6.jpeg)

如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。

20.

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/63f0878f2f66e9c4688cd4b47ce6cace.png)

如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。

## 4、HTTPS RSA 握手解析

这次我们再来深入一下 HTTPS，用**实战抓包**的方式，带大家再来窥探一次 HTTPS。

### 4.1 TLS握手过程

HTTP 由于是明文传输，所谓的明文，就是说客户端与服务端通信的信息都是肉眼可见的，随意使用一个抓包工具都可以截获通信的内容。

所以安全上存在以下三个风险：

- _窃听风险_，比如通信链路上可以获取通信内容，用户号容易没。
- _篡改风险_，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。
- _冒充风险_，比如冒充淘宝网站，用户钱容易没。

HTTP**S** 在 HTTP 与 TCP 层之间加入了 TLS 协议，来解决上述的风险。
![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/f24dbe347f7958f75d06c4a50e28cfa7.png)

TLS 协议是如何解决 HTTP 的风险的呢？

- _信息加密_： HTTP 交互信息是被加密的，第三方就无法被窃取；
- _校验机制_：校验信息传输过程中是否有被第三方篡改过，如果被篡改过，则会有警告提示；
- _身份证书_：证明淘宝是真的淘宝网；

可见，有了 TLS 协议，能保证 HTTP 通信是安全的了，那么`在进行 HTTP 通信前，需要先进行 TLS 握手。TLS 的握手过程`，如下图：
![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/2cd97504f2e9c5c1810c952f8241761c.png)

上图简要概述了 TLS 的握手过程，其中每一个「框」都是一个记录（_record_），记录是 TLS 收发数据的基本单位，类似于 TCP 里的 segment。多个记录可以组合成一个 TCP 包发送，所以**通常经过「四个消息」就可以完成 TLS 握手，也就是需要 2个 RTT 的时延**，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。

所以可以发现，HTTPS 是应用层协议，需要先完成 TCP 连接建立，然后走 TLS 握手过程后，才能建立通信安全的连接。

事实上，不同的密钥交换算法，TLS 的握手过程可能会有一些区别。

这里先简单介绍下密钥交换算法，因为考虑到性能的问题，所以双方在加密应用信息时使用的是对称加密密钥，而对称加密密钥是不能被泄漏的，为了保证对称加密密钥的安全性，所以使用非对称加密的方式来保护对称加密密钥的协商，这个工作就是密钥交换算法负责的。

接下来，我们就以最简单的 `RSA` 密钥交换算法，来看看它的 TLS 握手过程。
### 4.2 RSA握手过程

传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 证书部署服务端时，证书文件其实就是服务端的公钥，会在 TLS 握手阶段传递给客户端，而服务端的私钥则一直留在服务端，一定要确保私钥不能被窃取。

在 RSA 密钥协商算法中，客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。

我用 Wireshark 工具抓了用 RSA 密钥交换的 TLS 握手过程，你可以从下面看到，一共经历了四次握手：
![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/9dac1d61a52fdb09492ff2947820372c.png)

对应 Wireshark 的抓包，我也画了一幅图，你可以从下图很清晰地看到该过程：![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/b2e43ccf91fcf88b0bf112af0732a65d.png)
那么，接下来针对每一个 TLS 握手做进一步的介绍。
#### 4.2.1 TLS第一次握手

客户端首先会发一个「**Client Hello**」消息，字面意思我们也能理解到，这是跟服务器「打招呼」。![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/df51584921f073d62f819273bbaf88be.png)消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的**随机数（_Client Random_）**，这个随机数会被服务端保留，它是生成对称加密密钥的材料之一

#### 4.2.2 TLS第二次握手

当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成**随机数（_Server Random_）**。

接着，返回「**Server Hello**」消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件。
![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/5f2957905e74042a1bb6a8e0dd555ae4.png)

可以看到，服务端选择的密码套件是 “Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256”。

这个密码套件看起来真让人头晕，好一大串，但是其实它是有固定格式和规范的。基本的形式是「**密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法**」， 一般 WITH 单词前面有两个单词，第一个单词是约定密钥交换的算法，第二个单词是约定证书的验证算法。比如刚才的密码套件的意思就是：

- 由于 WITH 单词只有一个 RSA，则说明握手时密钥交换算法和签名算法都是使用 RSA；
- 握手后的通信使用 AES 对称算法，密钥长度 128 位，分组模式是 GCM；
- 摘要算法 SHA256 用于消息认证和产生随机数；

就前面这两个客户端和服务端相互「打招呼」的过程，客户端和服务端就已确认了 TLS 版本和使用的密码套件，而且你可能发现客户端和服务端都会各自生成一个随机数，并且还会把随机数传递给对方。

那这个随机数有啥用呢？其实这两个随机数是后续作为生成「会话密钥」的条件，所谓的会话密钥就是数据传输时，所使用的对称加密密钥。

然后，服务端为了证明自己的身份，会发送「**Server Certificate**」给客户端，这个消息里含有数字证书。
![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/53d1ca7236091618e798d79160cc4b1c.png)

随后，服务端发了「**Server Hello Done**」消息，目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。
![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/31f8a0f362ab50f1ad2282b0272e4086.png)
#### 4.2.3 客户端验证证书

在这里刹个车，客户端拿到了服务端的数字证书后，要怎么校验该数字证书是真实有效的呢？

`数字证书和 CA 机构`

在说校验数字证书是否可信的过程前，我们先来看看数字证书是什么，一个数字证书通常包含了：
- 公钥；
- 持有者信息；
- 证书认证机构（CA）的信息；
- CA 对这份文件的数字签名及使用的算法；
- 证书有效期；
- 还有一些其他额外信息；

那数字证书的作用，是用来认证公钥持有者的身份，以防止第三方进行冒充。说简单些，证书就是用来告诉客户端，该服务端是否是合法的，因为只有证书合法，才代表服务端身份是可信的。

我们用证书来认证公钥持有者的身份（服务端的身份），那证书又是怎么来的？又该怎么认证证书呢？

为了让服务端的公钥被大家信任，服务端的证书都是由 CA （_Certificate Authority_，证书认证机构）签名的，CA 就是网络世界里的公安局、公证中心，具有极高的可信度，所以由它来给各个公钥签名，信任的一方签发的证书，那必然证书也是被信任的。

之所以要签名，是因为签名的作用可以避免中间人在获取证书时对证书内容的篡改。

`数字证书签发和验证流程`

如下图图所示，为数字证书签发和验证流程：

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/3d7654f8eff4965518209a0a0d7ac6f5.png)

CA 签发证书的过程，如上图左边部分：

- 首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；
- 然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；
- 最后将 Certificate Signature 添加在文件证书上，形成数字证书；

客户端校验服务端的数字证书的过程，如上图右边部分：

- 首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；
- 通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；
- 最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。

`证书链`

但事实上，证书的验证过程中还存在一个证书信任链的问题，因为我们向 CA 申请的证书一般不是根证书签发的，而是由中间证书签发的，比如百度的证书，从下图你可以看到，证书的层级有三级：

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/6877c7b30aea5dfc1f6a837f9b7459f8.png)

对于这种三级层级关系的证书的验证过程如下：

- 客户端收到 baidu.com 的证书后，发现这个证书的签发者不是根证书，就无法根据本地已有的根证书中的公钥去验证 baidu.com 证书是否可信。于是，客户端根据 baidu.com 证书中的签发者，找到该证书的颁发机构是 “GlobalSign Organization Validation CA - SHA256 - G2”，然后向 CA 请求该中间证书。
- 请求到证书后发现 “GlobalSign Organization Validation CA - SHA256 - G2” 证书是由 “GlobalSign Root CA” 签发的，由于 “GlobalSign Root CA” 没有再上级签发机构，说明它是根证书，也就是自签证书。应用软件会检查此证书有否已预载于根证书清单上，如果有，则可以利用根证书中的公钥去验证 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，如果发现验证通过，就认为该中间证书是可信的。
- “GlobalSign Organization Validation CA - SHA256 - G2” 证书被信任后，可以使用 “GlobalSign Organization Validation CA - SHA256 - G2” 证书中的公钥去验证 baidu.com 证书的可信性，如果验证通过，就可以信任 baidu.com 证书。

在这四个步骤中，最开始客户端只信任根证书 GlobalSign Root CA 证书的，然后 “GlobalSign Root CA” 证书信任 “GlobalSign Organization Validation CA - SHA256 - G2” 证书，而 “GlobalSign Organization Validation CA - SHA256 - G2” 证书又信任 baidu.com 证书，于是客户端也信任 baidu.com 证书。

总括来说，由于用户信任 GlobalSign，所以由 GlobalSign 所担保的 baidu.com 可以被信任，另外由于用户信任操作系统或浏览器的软件商，所以由软件商预载了根证书的 GlobalSign 都可被信任。

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/08c9b201670b8475a4ee9609cf5d3943.png)

操作系统里一般都会内置一些根证书，比如我的 MAC 电脑里内置的根证书有这么多：

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/b8fc25ddde85472ecc14edc0b0443b65.png)

这样的一层层地验证就构成了一条信任链路，整个证书信任链验证流程如下图所示：

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/9282e96a7aea49a4da341b13efe9ace6.png)

最后一个问题，为什么需要证书链这么麻烦的流程？Root CA 为什么不直接颁发证书，而是要搞那么多中间层级呢？

这是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。

#### 4.2.4 TLS第三次握手

客户端验证完证书后，认为可信则继续往下走。

接着，客户端就会生成一个新的**随机数 (_pre-master_)**，用服务器的 RSA 公钥加密该随机数，通过「**Client Key Exchange**」消息传给服务端。

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/bd9d94577a72b96c81853a25804625d5.png)

服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (pre-master)。

至此，**客户端和服务端双方都共享了三个随机数，分别是 Client Random、Server Random、pre-master**。

于是，双方根据已经得到的三个随机数，生成**会话密钥（Master Secret）**，它是对称密钥，用于对后续的 HTTP 请求/响应的数据加解密。

生成完「会话密钥」后，然后客户端发一个「**Change Cipher Spec**」，告诉服务端开始使用加密方式发送消息。

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/40f9afb865f284ae5f9f67ca56781a86.png)

然后，客户端再发一个「**Encrypted Handshake Message（Finishd）**」消息，把之前所有发送的数据做个**摘要**，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信「是否可用」和「之前握手信息是否有被中途篡改过」。

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/cb802145b12a63f77a1ce0aa063aa71a.png)

可以发现，「Change Cipher Spec」之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文。

#### 4.2.5 TLS第四次握手

服务器也是同样的操作，发「**Change Cipher Spec**」和「**Encrypted Handshake Message**」消息，如果双方都验证加密和解密没问题，那么握手正式完成。

最后，就用「会话密钥」加解密 HTTP 请求和响应了

### 4.3 RSA算法缺陷

**使用 RSA 密钥协商算法的最大问题是不支持前向保密**。

因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。

为了解决这个问题，后面就出现了 ECDHE 密钥协商算法，我们现在大多数网站使用的正是 ECDHE 密钥协商算法，