## 1 模板语法

Vue 使用一种基于 HTML 的模板语法，使我们能够声明式地将其组件实例的数据绑定到呈现的 DOM 上。（`如：v-text这些声明，浏览器是看不到的，vue直接将其数据放在DOM上`）

所有的 Vue 模板都是语法层面合法的 HTML，可以被符合规范的浏览器和 HTML 解析器解析。

在底层机制中，Vue 会将模板编译成高度优化的 JavaScript 代码。结合响应式系统，当应用状态变更时，Vue 能够智能地推导出需要重新渲染的组件的最少数量，并应用最少的 DOM 操作。
### 1.1 1 插值表达式和文本渲染

> 插值表达式:最基本的数据绑定形式是文本插值，它使用的是“Mustache”语法 ,即双大括号`{{}}`

+ 插值表达式是将`数据渲染到元素的指定位置的手段之一`
+ 插值表达式`不绝对依赖标签,其位置相对自由`
+ 插值表达式中`支持javascript的运算表达式`
+ 插值表达式中也`支持函数的调用`

``` html
<script setup type="module">
  let msg ="hello vue3"
  let getMsg= ()=>{
    return 'hello vue3 message'
  }
  let age = 19
  let bee = '蜜 蜂'
  // 购物车
  const carts = [{name:'可乐',price:3,number:10},{name:'薯片',price:6,number:8}];
  //计算购物车总金额
  function compute(){
      let count = 0;
      for(let index in carts){
          count += carts[index].price*carts[index].number;
      }
      return count;
  }
</script>

<template>
  <div>
    <!-- 数据渲染到元素的指定位置的手段之一 -->
    <h1>{{ msg }}</h1>

    <!-- 不绝对依赖标签,其位置相对自由 -->
    msg的值为：{{ msg }} <br>
    getMsg返回的值为：{{ getMsg() }} <br>

    <!-- 支持javascript的运算表达式 -->
    是否成年：{{ age>18?"true":"false" }} <br>

    <!-- 支持函数的调 -->
    反转：{{ bee.split(" ").reverse().join(" ") }} <br>
    购物车总金额：{{ compute() }} <br>
    购物车总金额：{{ carts[0].price*carts[0].number +  carts[1].price*carts[1].number}}
  </div>
</template>

<style scoped>

</style>
```

结果：![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/4a5e29423c492c8541e8a1914702f1c2.png)

> 为了渲染双标中的文本,我们也可以选择使用`v-text`和`v-html`命令

+ `v-***` 这种写法的方式`使用的是vue的命令`
+ `v-***` 的命令`必须依赖元素,并且要写在元素的开始标签中`
+ `v-***`指令`支持ES6中的字符串模板`
+ 支持javascript的运算表达式
+ 也支持函数的调用
+ v-text可以`将数据渲染成双标签中间的文本`,但是`不识别html元素结构的文本`
+ v-html可以`将数据渲染成双标签中间的文本`,`识别html元素结构的文本`

``` html
<script setup type="module">
  let msg ='hello vue3'
  let getMsg= ()=>{
    return msg
  }
  let age = 19
  let bee = '蜜 蜂'
  //注意$取值表达式，使用着重号
  let redMsg ='<font color=\'red\'>msg</font>'
  let greenMsg =`<font color=\'green\'>${msg}</font>`
</script>

<template>
  <div>
    <span v-text='msg'></span> <br><!-- 测试v-text标签 -->
    <span v-text="msg"></span> <br>
    <span v-text="getMsg()"></span> <br>
    <span v-text="redMsg"></span> <br>
    <span v-text="greenMsg"></span> <br>
    <span v-text='age>18?"成年":"未成年"'></span> <br>
    <span v-text="bee.split(' ').reverse().join('-')"></span> <br>
    
    <hr>
    
    <!-- 测试v-html标签 -->
    <span v-html="msg"></span> <br>
    <span v-html="getMsg()"></span> <br>
    <span v-html="redMsg"></span> <br>
    <span v-html="greenMsg"></span> <br>
    <span v-html='age>18?"成年":"未成年"'></span> <br>
    <span v-html="bee.split(' ').reverse().join('-')"></span> <br>
  </div>
</template>

<style scoped>
</style>
```

效果如图：![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/cf898fc8a82a911720f21b8fd0a74e15.png)

### 1.2 Attribute属性渲染

> 想要渲染一个元素的 attribute，应该使用 `v-bind`指令

+ 由于插值表达式不能直接放在标签的属性中,所有要渲染元素的属性就应该使用v-bind
+ v-bind可以用于渲染任何元素的属性,语法为 `v-bind:属性名='数据名'`, 可以简写为 `:属性名='数据名'`

``` html
<script setup type="module">
  const data = {
    name:'尚硅谷',
    url:"http://www.atguigu.com",
    logo:"http://www.atguigu.com/images/index_new/logo.png"
  }
</script>

<template>
  <div>

    <a v-bind:href='data.url' target="_self">
        <img :src="data.logo" :title="data.name">
        <br>
        <input type="button" :value="`点击访问${data.name}`">
    </a>

  </div>
</template>

<style scoped>
</style>
```

效果如图：![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/7bfc52113dfc3039de7538fe6788866f.png)
### 1.3 事件的绑定

> 我们可以使用 `v-on` 来监听 DOM 事件，并在事件触发时执行对应的 Vue的JavaScript代码。

+ 用法：`v-on:click="handler"` 或简写为 `@click="handler"`
+ vue中的事件名=原生事件名去掉`on` 前缀   如:`onClick --> click`
+ handler的值可以是`方法事件处理器`,也可以是`内联事件处理器`
+ 绑定事件时,可以通过一些绑定的修饰符,常见的事件修饰符如下
	+ `.once：只触发一次事件。[重点]`
	+ `.prevent：阻止默认事件。[重点]`，主要和原生js对比，用于确定删除吗的情况
	+ .stop：阻止事件冒泡。
	+ .capture：使用事件捕获模式而不是冒泡模式。
	+ .self：只在事件发送者自身触发时才触发事件。

``` html
<script setup type="module">
	import { ref } from 'vue';

    let count = ref(0)
    let addCount = ()=>{
        count.value++
    }

    let incrCount = ()=>{
        count.value++
    }

    let changeUrl = ()=>{
        //通过事件对象阻止组件的默认行为
        event.preventDefault();
    }

    let changeSite =(event)=>{
        let flag = confirm("确定要跳转页面吗？")
        if(!flag){
            event.preventDefault();
        }
    }
</script>

<template>
  <div >

    <h1>count的值是：{{ count }}</h1>

    <!-- 方法事件处理器 -->
    <button v-on:click="addCount">addCount</button> <br>

    <!-- 内联事件处理器 -->
    <button @click="count++">incrCount</button> <br>

    <!-- once表示事件只执行一次 -->
    <button @click.once="count++">addOnce</button> <br>

    <!-- prevent 阻止组件的默认行为 -->
    <a href="http://www.baidu.com" target="_blank" @click.prevent="changeUrl">prevent</a> <br>

    <!-- 原生js方式阻止组件默认行为 (推荐) -->
    <a href="http://www.atguigu.com" target="_blank" @click="changeSite($event)">prevent</a> <br>

  </div>
</template>

<style scoped>

</style>
```
## 2 响应式基础

此处的响应式是指  : 数据模型发生变化时，自动更新DOM树内容，页面上显示的内容会进行同步变化，vue3的数据模型不是自动响应式的，需要我们做一些特殊的处理
### 2.1 需求案例

> 需求：实现 +  - 按钮,实现数字加一减一

```html
<script type="module" setup>
    let counter = 0;
    function show(){
        alert(counter);
    }
</script>

<template>
  <div>
    <button @click="counter--">-</button> 
    {{ counter }} 
    <button @click="counter++">+</button>
    <hr>
    <!-- 此案例,我们发现counter值,会改变,但是页面不改变! 默认Vue3的数据是非响应式的!-->
    <button @click="show()">显示counter值</button>
   </div>
</template> 

<style scoped>

</style>

```
### 2.2 实现关键字ref

> `ref` 可以将一个基本类型的数据（如字符串，数字等）转换为一个响应式对象。 `ref` 只能包裹单一元素

```html
<script type="module" setup>
    /* 从vue中引入ref方法 */
    import {ref} from 'vue'
    let counter = ref(0);
    function show(){
        alert(counter.value);
    }
    /* 函数中要操作ref处理过的数据,需要通过.value形式 */
    let decr = () =>{
      counter.value--;
    }
    let incr = () =>{
      counter.value++;
    }
</script>

<template>
  <div>
    <button @click="counter--">-</button> 
    <button @click="decr()">-</button> 
    {{ counter }} 
    <button @click="counter++">+</button>
    <button @click="incr()">+</button> 
    <hr>
    <button @click="show()">显示counter值</button>
   </div>
</template> 

<style scoped>

</style>
```

+ 在上面的例子中，我们使用 `ref` 包裹了一个数字，在代码中给这个数字加 1 后，视图也会跟着动态更新。
+ 需要注意的是，由于使用了 `ref`
	+ 在script标签块中访问该对象时使用 `.value` 来获取其实际值
	+ 而在template标签中访问该对象，不需要使用 `.value` 来获取其实际值
### 2.3 实现关键字reactive

> 我们可以使用 [reactive()](https://cn.vuejs.org/api/reactivity-core.html#reactive "reactive()") 函数`创建一个响应式对象或数组`：

```html
<script type="module" setup>
    /* 从vue中引入reactive方法 */
    import {ref,reactive} from 'vue'
    let data = reactive({
      counter:0
    })
    function show(){
        alert(data.counter);
    }
    /* 函数中要操作reactive处理过的数据,需要通过 对象名.属性名的方式 */
    let decr = () =>{
      data.counter--;
    }
    let incr = () =>{
      data.counter++;
    }
</script>

<template>
  <div>
    <button @click="data.counter--">-</button> 
    <button @click="decr()">-</button> 
    {{ data.counter }} 
    <button @click="data.counter++">+</button>
    <button @click="incr()">+</button> 
    <hr>
    <button @click="show()">显示counter值</button>
   </div>
</template> 

<style scoped>

</style>
```

> 对比ref和reactive:

+ 使用 `ref` 适用于以下开发场景：
  + 包装基本类型数据：`ref` 主要用于包装基本类型数据（如字符串、数字等），即`只有一个值的数据`，如果你想监听这个值的变化，用 `ref` 最为方便。在组件中使用时也很常见。
  + 访问方式简单：`ref` 对象在访问时与普通的基本类型值没有太大区别，只需要通过 `.value` 访问其实际值即可。

+ 使用 `reactive` 适用于以下开发场景：
  + 包装复杂对象：`reactive` 可以将一个普通对象转化为响应式对象，这样在数据变化时会自动更新界面，特别`适用于处理复杂对象或者数据结构`。
  + 需要递归监听的属性：使用 `reactive` 可以递归追踪所有响应式对象内部的变化，从而保证界面的自动更新。

+ 综上所述，`ref` 适用与简单情形下的数据双向绑定，对于只有一个字符等基本类型数据或自定义组件等情况，建议可以使用 `ref`；而对于对象、函数等较为复杂的数据结构，以及需要递归监听的属性变化，建议使用 `reactive`。当然，在实际项目中根据需求灵活选择也是十分必要的。
### 2.4 扩展响应式关键字 toRefs 和 toRef(了解)

> `toRef基于reactive响应式对象上的一个属性，创建一个对应的 ref响应式数据`。这样创建的 ref 与其源属性保持同步：改变源属性的值将更新 ref 的值，反之亦然。
> 
> `toRefs将一个响应式对象多个属性转换为多个ref数据`，这个普通对象的每个属性都是指向源对象相应属性的 ref。每个单独的 ref 都是使用 [toRef()](https://cn.vuejs.org/api/reactivity-utilities.html#toref "toRef()") 创建的。

案例：响应显示reactive对象属性

```html
<script type="module" setup>
    /* 从vue中引入reactive方法 */
    import {ref,reactive,toRef,toRefs} from 'vue'
    let data = reactive({
      counter:0,
      name:"test"
    })

    // 将一个reactive响应式对象中的某个属性转换成一个ref响应式对象
    let ct =toRef(data,'counter');
    // 将一个reactive响应式对象中的多个属性转换成多个ref响应式对象
    let {counter,name} = toRefs(data)

    function show(){
        alert(data.counter);
        // 获取ref的响应对象,需要通过.value属性
        alert(counter.value);
        alert(name.value)
    }
    /* 函数中要操作ref处理过的数据,需要通过.value形式 */
    let decr = () =>{
      data.counter--;
    }
    let incr = () =>{
      /* ref响应式数据,要通过.value属性访问 */
      counter.value++;
    }
</script>

<template>
  <div>
    <button @click="data.counter--">-</button> 
    <button @click="decr()">-</button> 
    {{ data.counter }} 
    &amp;
    {{ ct }} 
    <button @click="data.counter++">+</button>
    <button @click="incr()">+</button> 
    <hr>
    <button @click="show()">显示counter值</button>
   </div>
</template> 

<style scoped>

</style>


```
## 3 条件和列表渲染

### 3.1 条件渲染

> `v-if` 条件渲染

+ `v-if='表达式' `只会在指令的表达式返回真值时才被渲染

+ 也可以使用 `v-else` 为 `v-if` 添加一个“else 区块”。

+ 一个 `v-else` 元素必须跟在一个 `v-if` 元素后面，否则它将不会被识别。

```html
<script type="module" setup>
    import {ref} from 'vue'
    let awesome = ref(true)
</script>

<template>
  <div>
    <h1 v-if="awesome">Vue is awesome!</h1>
    <h1 v-else>Oh no 😢</h1>
    <button @click="awesome = !awesome">Toggle</button>
  </div>
</template> 

<style scoped>
</style>
```

> `v-show`条件渲染扩展：

+ 另一个可以用来按条件显示一个元素的指令是 `v-show`。其用法基本一样：

+ 不同之处在于 `v-show` 会在 DOM 渲染中保留该元素；`v-show` 仅切换了该元素上名为 `display` 的 CSS 属性。

+ `v-show` 不支持在 `<template>` 元素上使用，也不能和 `v-else` 搭配使用。

``` html
<script type="module" setup>
    import {ref} from 'vue'
    let awesome = ref(true)
</script>

<template>
  <div>
    <h1 id="ha"  v-show="awesome">Vue is awesome!</h1>
    <h1 id="hb"  v-if="awesome">Vue is awesome!</h1>
    <h1 id="hc"  v-else>Oh no 😢</h1>
    <button @click="awesome = !awesome">Toggle</button>
  </div>
</template> 

<style scoped>
</style>

```

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/39a422b0f057a2501eb0c6feb982c917.png)



> **`v-if`**    **vs** **`v-show`**

+ `v-if` 是“真实的”按条件渲染，因为它确保了在切换时，条件区块内的事件监听器和子组件都会被销毁与重建。

+ `v-if` 也是**惰性**的：如果在初次渲染时条件值为 false，则不会做任何事。条件区块只有当条件首次变为 true 时才被渲染。

+ 相比之下，`v-show` 简单许多，元素无论初始条件如何，始终会被渲染，只有 CSS `display` 属性会被切换。

+ 总的来说，`v-if` 有更高的切换开销，而 `v-show` 有更高的初始渲染开销。
	+ 因此，如果需要频繁切换，则使用 `v-show` 较好；
	+ 如果在运行时绑定条件很少改变，则 `v-if` 会更合适。
### 3.2 列表渲染

> 我们可以使用 `v-for` 指令`基于一个数组来渲染一个列表`。

+ `v-for` 指令的值需要使用 `item in items` 形式的特殊语法，其中 `items` 是源数据的数组，而 `item` 是迭代项的**别名**：

+ 在 `v-for` 块中可以完整地访问父作用域内的属性和变量。`v-for` 也支持使用可选的第二个参数表示当前项的位置索引。

```html
<script type="module" setup>
    import {ref,reactive} from 'vue'
    let parentMessage= ref('产品')
    let items =reactive([
      {
        id:'item1',
        message:"薯片"
      },
      {
        id:'item2',
        message:"可乐"
      }
    ])
</script>

<template>
  <div>
    <ul>
      <!-- :key不写也可以 -->
      <li v-for='item in items' :key='item.id'>
        {{ item.message }}
      </li>
    </ul>

    <ul>
      <!-- index表示索引,当然不是非得使用index这个单词 -->
      <li v-for="(item, index) in items" :key="index">
        {{ parentMessage }} - {{ index }} - {{ item.message }}
      </li>
    </ul>
   
  </div>
</template> 

<style scoped>
</style>
```

+ 案例：实现购物车显示和删除购物项

``` html
<script type="module" setup>

    //引入模块
    import { reactive} from 'vue'
    //准备购物车数据,设置成响应数据
    const carts = reactive([{name:'可乐',price:3,number:10},{name:'薯片',price:6,number:8}])

    //计算购物车总金额
    function compute(){
      let count = 0;
      for(let index in carts){
        count += carts[index].price*carts[index].number;
      }
      return count;
    }
    //删除购物项方法
    function removeCart(index){
      carts.splice(index,1);
    }
    
</script>

<template>
    <div>
        <table>
           <thead>
               <tr>
                  <th>序号</th>
                  <th>商品名</th>
                  <th>价格</th>
                  <th>数量</th>
                  <th>小计</th>
                  <th>操作</th>
               </tr>
           </thead>
           <tbody v-if="carts.length > 0">
               <!-- 有数据显示-->
               <tr v-for="cart,index in carts" :key="index">
                  <th>{{ index+1 }}</th>
                  <th>{{ cart.name }}</th>
                  <th>{{ cart.price + '元' }}</th>
                  <th>{{ cart.number }}</th>
                  <th>{{ cart.price*cart.number  + '元'}}</th>
                  <th> <button @click="removeCart(index)">删除</button> </th>
               </tr>
           </tbody>
           <tbody v-else>
               <!-- 没有数据显示-->
               <tr>
                  <td colspan="6">购物车没有数据!</td>
               </tr>
           </tbody>
        </table>
        购物车总金额: {{ compute() }} 元
    </div>
</template> 

<style scoped>
</style>
```
## 4 双向绑定

> `单向绑定和双向绑定`

+ 单向绑定: 响应式数据的变化会更新dom树,但是dom树上用户的操作造成的数据改变不会同步更新到响应式数据

+ 双向绑定: `响应式数据的变化会更新dom树,但是dom树上用户的操作造成的数据改变会同步更新到响应式数据`
	+ 用户通过表单标签才能够输入数据,所以双向绑定都是应用到表单标签上的,其他标签不行
	+ v-model`专门用于双向绑定表单标签的value属性`,语法为 `v-model:value=''`,可以简写为 `v-model=''`
	+ v-model还可以用于各种不同类型的输入，`<textarea>`、`<select>` 元素。

```html
<script type="module" setup>

  //引入模块
  import { reactive,ref} from 'vue' 
  let hbs = ref([]); //装爱好的值
  let user = reactive({username:null,password:null,introduce:null,pro:null})   
  function login(){
    alert(hbs.value);
    alert(JSON.stringify(user));
  }
  function clearx(){
    //user = {};// 这中写法会将数据变成非响应的,应该是user.username=""
    user.username=''
    user.password=''
    user.introduce=''
    user.pro=''
    hbs.value.splice(0,hbs.value.length);;
  }
</script>

<template>
  <div>
      账号： <input type="text" placeholder="请输入账号！" v-model="user.username"> <br>
      密码： <input type="text" placeholder="请输入账号！" v-model="user.password"> <br>
      爱好： 
        吃 <input type="checkbox" name="hbs" v-model="hbs" value="吃"> 
        喝 <input type="checkbox" name="hbs" v-model="hbs" value="喝">
        玩 <input type="checkbox" name="hbs" v-model="hbs" value="玩">
        乐 <input type="checkbox" name="hbs" v-model="hbs" value="乐">
      <br>
      简介:<textarea v-model="user.introduce"></textarea>
      <br>
      籍贯:
          <select v-model="user.pro">
            <option value="1">黑</option>
            <option value="2">吉</option>
            <option value="3">辽</option>
            <option value="4">京</option>
            <option value="5">津</option>
            <option value="6">冀</option>
          </select> 
      <br>
      <button @click="login()">登录</button> 
      <button @click="clearx()">重置</button>
      <hr>
      显示爱好:{{ hbs }}
      <hr>
      显示用户信息:{{ user }}
  </div> 
</template> 

<style scoped>
</style>

```
## 5 属性计算(了解)

> 模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护。
> 
> `比如说，我们有这样一个包含嵌套数组的对象：`

```html
<script type="module" setup>
  //引入模块
  import { reactive,computed} from 'vue'
  const author = reactive({
    name: 'John Doe',
    books: [
      'Vue 2 - Advanced Guide',
      'Vue 3 - Basic Guide',
      'Vue 4 - The Mystery'
    ]
  })
 
</script>

<template>
  <div>
    <p>{{author.name}} Has published books?:</p>
    <span>{{ author.books.length > 0 ? 'Yes' : 'No' }}</span>
  </div>
</template> 

<style scoped>
</style>
```

+ 这里的模板看起来有些复杂。我们必须认真看好一会儿才能明白它的计算依赖于 `author.books`。更重要的是，如果在模板中需要不止一次这样的计算，我们可不想将这样的代码在模板里重复好多遍。

> 因此我们推荐使用**计算属性**来描述依赖响应式状态的复杂逻辑。这是重构后的示例：

```html
<script type="module" setup>
  //引入模块
  import { reactive,computed} from 'vue'
  const author = reactive({
    name: 'John Doe',
    books: [
      'Vue 2 - Advanced Guide',
      'Vue 3 - Basic Guide',
      'Vue 4 - The Mystery'
    ]
  })
  // publishedBooksMessage为一个计算属性 ref
  const publishedBooksMessage = computed(() => {
    //如果author.books不变，这个方法只会执行一次
    //所以对于属性是经过大量、复杂算法运算出来的，使用这个可以节省时间和空间上的资源
	console.log("publishedBooksMessage")
    return author.books.length > 0 ? 'Yes' : 'No'
  })
  // 一个函数
  let hasBooks = ()=>{
	//无论author.books变或不变，这个方法调用就会执行
    console.log("hasBooks")
    return author.books.length > 0?'Yes':'no'
  }

</script>

<template>
  <div>
    <p>{{author.name}} Has published books?:</p>
    <span>{{ author.books.length > 0 ? 'Yes' : 'No' }}</span>
    <!-- 调用方法,每个标签都会调用一次 -->
    <span>{{ hasBooks() }}</span>
    <span>{{ hasBooks() }}</span>

    <p>{{author.name}} Has published books?:</p>
    <!-- 属性计算,属性值不变时,多个个标签只会调用一次 -->
    <span>{{ publishedBooksMessage }}</span>
    <span>{{ publishedBooksMessage }}</span>
  </div>
</template> 

<style scoped>
</style>

```

+ 我们在这里定义了一个计算属性 `publishedBooksMessage`。`computed()` 方法期望接收一个 getter 函数，返回值为一个**计算属性 ref**。和其他一般的 ref 类似，你可以通过 `publishedBooksMessage.value` 访问计算结果。计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 `.value`。

+ Vue 的计算属性会自动追踪响应式依赖。它会检测到 `publishedBooksMessage` 依赖于 `author.books`，所以当 `author.books` 改变时，任何依赖于 `publishedBooksMessage` 的绑定都会同时更新。

> 计算属性缓存 vs 方法

+ 若我们将同样的函数定义为一个方法而不是计算属性，两种方式在结果上确实是完全相同的，然而，不同之处在于**计算属性值会基于其响应式依赖被缓存**。一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着只要 `author.books` 不改变，无论多少次访问 `publishedBooksMessage` 都会立即返回先前的计算结果!
## 6 数据监听器(了解)

> 计算属性允许我们声明性地计算衍生值。然而在有些情况下，我们需要在状态变化时执行一些“副作用”：例如更改 DOM，或是根据异步操作的结果去修改另一处的状态。我们可以使用 [watch](https://cn.vuejs.org/api/reactivity-core.html#watch "watch")[ 函数](https://cn.vuejs.org/api/reactivity-core.html#watch " 函数")`在每次响应式状态发生变化时触发回调函数：`

+ watch主要用于以下场景：
	+ 当`数据发生变化时`需要执行相应的操作
	+ `监听数据变化，当满足一定条件时`触发相应操作
	+ 在`异步操作前或操作后`需要执行相应的操作

> 监控响应式数据（`watch`）：

```html
<script type="module" setup>
  //引入模块
  import { ref,reactive,watch} from 'vue'
 
  let firstname=ref('')
  let lastname=reactive({name:''})
  let fullname=ref('')

  //监听一个ref响应式数据
  watch(firstname,(newValue,oldValue)=>{
    console.log(`${oldValue}变为${newValue}`)
    fullname.value=firstname.value+lastname.name
  })
  
  //监听reactive响应式数据的指定属性
  watch(()=>lastname.name,(newValue,oldValue)=>{
    console.log(`${oldValue}变为${newValue}`)
    fullname.value=firstname.value+lastname.name
  })
  
  //监听reactive响应式数据的所有属性(深度监视,一般不推荐)
  //deep:true 深度监视（监视对象内的所有属性）
  //immediate:true 页面执行前，先执行一次该watch方法
  watch(()=>lastname,(newValue,oldValue)=>{
    // 此时的newValue和oldValue一样,都是lastname
    console.log(newValue)
    console.log(oldValue)
    fullname.value=firstname.value+lastname.name
  },{deep:true,immediate:false})
</script>

<template>
  <div>
    全名:{{fullname}} <br>
    姓氏:<input type="text" v-model="firstname"> <br>
    名字:<input type="text" v-model="lastname.name" > <br>
  </div>
</template> 

<style scoped>
</style>
```

> 监控响应式数据(`watchEffect`)：

+ watchEffect默认监听所有的响应式数据

```html
<script type="module" setup>
  //引入模块
  import { ref,reactive,watch, watchEffect} from 'vue'
 
  let firstname=ref('')
  let lastname=reactive({name:''})
  let fullname=ref('')

  //监听所有响应式数据，将需要监听的数据放入即可
  //不放入元素不会监听
  watchEffect(()=>{
    //默认初始化就加载！
    console.log(firstname.value)
    console.log(lastname.name)
    fullname.value=`${firstname.value}${lastname.name}`
  })
</script>

<template>
  <div>
    全名:{{fullname}} <br>
    姓氏:<input type="text" v-model="firstname"> <br>
    名字:<input type="text" v-model="lastname.name" > <br>
  </div>
</template> 

<style scoped>
</style>
```

> `watch` vs. `watchEffect`

+ `watch` 和 `watchEffect` 都能响应式地执行有副作用的回调。它们之间的主要区别是追踪响应式依赖的方式：
  + `watch` 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。`watch` 会避免在发生副作用时追踪依赖，因此，我们能更加精确地控制回调函数的触发时机。
  + `watchEffect`，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。
## 7 Vue生命周期

### 7.1 简介

> 每个 Vue 组件实例在创建时都需要经历一系列的初始化步骤，比如设置好数据侦听，编译模板，挂载实例到 DOM，以及在数据改变时更新 DOM。在此过程中，它也会运行被称为`生命周期钩子的函数`，让开发者有机会在特定阶段运行自己的代码!

+ 周期图解：（看红色部分对应的钩子函数即可）![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/aa65122673fccafe5ae41228551e3df8.png)
+ 常见钩子函数（组合式中能使用的）
	+ [选项式声明周期钩子函数 | Vue.js (vuejs.org)](https://cn.vuejs.org/api/options-lifecycle.html)
	+ [组合式 API：生命周期钩子 | Vue.js (vuejs.org)](https://cn.vuejs.org/api/composition-api-lifecycle.html)
	+ onMounted()              注册一个回调函数，在组件挂载完成后执行。 
	+ onUpdated()               注册一个回调函数，在组件因为响应式状态变更而更新其 DOM 树之后调用。 
	+ onUnmounted()         注册一个回调函数，在组件实例被卸载之后调用。 
	+ onBeforeMount()       注册一个钩子，在组件被挂载之前被调用。 
	+ onBeforeUpdate()      注册一个钩子，在组件即将因为响应式状态变更而更新其 DOM 树之前调用。 
	+ onBeforeUnmount()  注册一个钩子，在组件实例被卸载之前调用。 
### 7.2 案例

```html
<script setup>

    import {ref,onUpdated,onMounted,onBeforeUpdate} from 'vue'
    
    let message =ref('hello')
   
    // 挂载完毕生命周期
    onMounted(()=>{
      console.log('-----------onMounted---------')
      let span1 =document.getElementById("span1")
      console.log(span1.innerText)
    })
    // 更新前生命周期
    onBeforeUpdate(()=>{
      console.log('-----------onBeforeUpdate---------')
      console.log(message.value)
      let span1 =document.getElementById("span1")
      console.log(span1.innerText)
    })
    // 更新完成生命周期
    onUpdated(()=>{
      console.log('-----------onUpdated---------')
      let span1 =document.getElementById("span1")
      console.log(span1.innerText)
    })
</script>

<template>
  <div>
    <span id="span1" v-text="message"></span> <br>
    <input type="text" v-model="message">
  </div>
  
</template>

<style scoped>
</style>
```
## 8 Vue组件

### 8.1 组件基础

> `组件允许我们将 UI 划分为独立的、可重用的部分，并且可以对每个部分进行单独的思考`。
> 
> 组件就是实现应用中`局部功能代码和资源的集合！`在实际应用中，组件常常被组织成层层嵌套的树状结构：

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/2ae2075a901f2107a0642b5b03fa39f7.png)

+ 这和我们嵌套 HTML 元素的方式类似，Vue 实现了自己的组件模型，使我们可以在每个组件内封装自定义内容与逻辑。

> 传统方式编写应用：

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/7911449bbb7ea7ae4c18fe7816bd8f9b.png)

> 组件方式编写应用：

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/5c760dcd19254016cbe2a2cac56c20d3.png)

+ `组件化`：对js/css/html统一封装,这是VUE中的概念
+ `模块化`：对js的统一封装,这是ES6中的概念

+ `组件化中,对js部分代码的处理使用ES6中的模块化`
### 8.2 组件化入门案例

> 案例需求： 创建一个页面，包含头部和菜单以及内容显示区域，每个区域使用独立组建！

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/5868cc60dc71d949651317502c5fd4ab.png)

> 1 准备vue项目

```shell
npm create vite
cd vite项目
npm install
```

> 2 安装相关依赖

```shell
npm install sass
npm install bootstrap
```

>  3 创建子组件 在src/components文件下 vscode==需要安装Vetur插件==，这样vue文件有快捷提示

+ Header.vue

```html
<script setup type="module">
</script>

<template>
    <div>
        欢迎： xx <a href="#">退出登录</a>
    </div>
</template>

<style>
</style>
```

+ Navigator.vue

```html
<script setup type="module">
</script>

<template>
    <!-- 推荐写一个根标签-->
    <div>
       <ul>
          <li>学员管理</li>
          <li>图书管理</li>
          <li>请假管理</li>
          <li>考试管理</li>
          <li>讲师管理</li>
       </ul>
    </div>
</template>

<style>
</style>
```

+ Content.vue

```html
<script setup type="module">
</script>

<template>
    <div>
        展示的主要内容！
    </div>
</template>

<style>
</style>
```

+ App.vue  入口组件App引入组件

```html
<script setup>
    import Header  from './components/Header.vue'
    import Navigator  from './components/Navigator.vue'
    import Content  from './components/Content.vue'
</script>

<template>
  <div>
     <Header class="header"></Header>
     <Navigator class="navigator"></Navigator>
     <Content class="content"></Content>
  </div>
</template>

<style scoped>
    .header{
       height: 80px;
       border: 1px solid red;
    }

    .navigator{
      width: 15%;
      height: 800px;
      display: inline-block;
      border: 1px blue solid;
      float: left;
    }

    .content{
      width: 83%;
      height: 800px;
      display: inline-block;
      border: 1px goldenrod solid;
      float: right;
    }

</style>
```

> 4 启动测试

```shell
npm run dev
```
### 8.3 组件之间传递数据（偶尔会用）

总结：
- `父传子`
	- 父组件：在含有子组件的html标签中，创建一个v-bind属性  
		- `:msg="需要传递的参数名"`
		- 传递多个值，就创建多个v-bind
	- 子组件：在js标签中，使用defineProps函数接收数据
		- `defineProps({msg:传递的类型,msg1:传递的类型,......})`
- `子传父`
	- 子组件：使用defineEmits函数，定义要发送给父组件的方法(一个/多个)
		- `const emits =defineEmits(['fun1','fun2',...])`
		- 创建一个函数，调用emits，`emits("fun1",传递的数据)`
	- 父组件：
		- 创建一个函数，用于接受数据，`(data)=>{接收数据后的操作}`
		- 在含有子组件的html标签中，`@fun1="上面接收数据的函数"`
- `兄弟传参：要经过上述两个过程`

#### 8.3.1 父传子

> Vue3 中`父组件向子组件传值可以通过 props 进行`，具体操作如下：

1. 首先，在父组件中定义需要传递给子组件的值
2. 接着，在父组件的模板中引入子组件，同时在引入子组件的标签中添加 props 属性并为其设置需要传递的值。

3. 在 Vue3 中，父组件通过 props 传递给子组件的值是响应式的。也就是说，如果在父组件中的传递的值发生了改变，子组件中的值也会相应地更新。

+ 父组件代码：App.vue
+ `将父组件中的值，在子组件标签中，使用v-bind标签绑定`

```html
<script setup>

  import Son from './components/Son.vue'
  import {ref,reactive,toRefs} from 'vue'

  let message = ref('parent data!')
  let title = ref(42)

  function changeMessage(){
    message.value = '修改数据！'
    title.value++
  }
</script>

<template>
  <div>
    <h2>{{ message }}</h2>
    <hr>
    <!-- 使用子组件，并且传递数据！ -->
    <Son :message="message" :title="title"></Son>
    <hr>
    <button @click="changeMessage">点击更新</button>
  </div>
</template>

<style scoped>
</style>
```

+ 子组件代码：Son.vue
+ `使用defineProps函数，获取父组件传递来的值`

```html
<script setup type="module">
    import {ref,isRef,defineProps} from 'vue'
    //声明父组件传递属性值，并注明类型
    defineProps({
        message:String ,
        title:Number
    })
</script>

<template>
    <div>
    <div>{{ message }}</div>
    <div>{{ title }}</div>
    </div>
</template>

<style>
</style>
```

#### 8.3.2 子传父

+ 父组件： App.vue
+ 创建一个函数用于接受子组件传递来的参数
+ 在子组件的标签中，使用@事件名（事件名必须是子组件的方法名）

```html
<script setup>
    import Son from './components/Son.vue'
    import {ref} from 'vue'

    let pdata = ref('')

    const padd = (data) => {
        console.log('2222');
        pdata.value =data;
    }

    //自定义接收，子组件传递数据方法！ 参数为数据！
    const psub = (data) => {
        console.log('11111');
        pdata.value = data;
    }
</script>

<template>
    <div>
        <!-- 声明@事件名应该等于子模块对应事件名！调用方法可以是当前自定义！-->
        <Son @add="padd" @sub="psub"></Son>
        <hr>
        {{ pdata }}
    </div>
</template>



<style>
</style>
```

+ 子组件：Son.vue
+ 使用defineEmits函数，创建传递给父组件的方法名
+ 创建一个自定义函数，在函数中调用上述函数（emites），完成给父组件传参

```html
<script setup>

    import {ref,defineEmits} from 'vue'

    //1.定义要发送给父组件的方法，可以1或者多个
    let emites = defineEmits(['add','sub']);

    let data = ref(1);

    function sendMsgToParent(){
        console.log('-------son--------');

        //2.出发父组件对应的方法，调用defineEmites对应的属性
        emites('add','add data!'+data.value)
        emites('sub','sub data!'+data.value)

        data.value ++;
    }
</script>

<template>
    <div>
      <button @click="sendMsgToParent">发送消息给父组件</button>
    </div>
</template>
  
```
#### 8.3.3 兄弟传参

![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/9fa3790791e5f1c6c65f2d295ba1e10c.png)

+ Navigator.vue: 发送数据到App.vue

```html
<script setup type="module">
    import {defineEmits} from 'vue'
    const emits = defineEmits(['sendMenu']);
    //触发事件，向父容器发送数据
    function send(data){
        emits('sendMenu',data);
    }
</script>

<template>
    <!-- 推荐写一个根标签-->
    <div>
       <ul>
          <li @click="send('学员管理')">学员管理</li>
          <li @click="send('图书管理')">图书管理</li>
          <li @click="send('请假管理')">请假管理</li>
          <li @click="send('考试管理')">考试管理</li>
          <li @click="send('讲师管理')">讲师管理</li>
       </ul>
    </div>
</template>

<style>

</style>
```

+ App.vue: 发送数据到Content.vue

```html
<script setup>
  
  import Header  from './components/Header.vue'
  import Navigator  from './components/Navigator.vue'
  import Content  from './components/Content.vue'

  import {ref} from "vue"
  //定义接受navigator传递参数
  var navigator_menu = ref('ceshi');

  const receiver = (data) =>{
    navigator_menu.value = data;
  }
</script>

<template>
  <div>
      <hr>
      {{ navigator_menu }}
      <hr>
     <Header class="header"></Header>
     <Navigator @sendMenu="receiver" class="navigator"></Navigator>
     <!-- 向子组件传递数据-->
     <Content class="content" :message="navigator_menu"></Content>
    </div>
</template>

<style scoped>
    .header{
       height: 80px;
       border: 1px solid red;
    }

    .navigator{
      width: 15%;
      height: 800px;
      display: inline-block;
      border: 1px blue solid;
      float: left;
    }

    .content{
      width: 83%;
      height: 800px;
      display: inline-block;
      border: 1px goldenrod solid;
      float: right;
    }

</style>
```

+ Content.vue

```html
<script setup type="module">
    defineProps({
        message:String
    })
</script>

<template>
    
    <div>
        展示的主要内容！
        <hr>
        {{ message }}
    </div>
</template>

<style>
</style>
```