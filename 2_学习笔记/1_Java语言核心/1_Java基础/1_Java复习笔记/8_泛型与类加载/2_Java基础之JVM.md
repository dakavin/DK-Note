## 目录

- [1 JVM简介](#1%20JVM%E7%AE%80%E4%BB%8B)
	- [1.1 JVM是什么](#1.1%20JVM%E6%98%AF%E4%BB%80%E4%B9%88)
	- [1.2 JVM由那些部分组成](#1.2%20JVM%E7%94%B1%E9%82%A3%E4%BA%9B%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90)
- [2 JVM的加载机制](#2%20JVM%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6)
	- [2.1 什么是类的加载机制](#2.1%20%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6)
	- [2.2 加载.class文件的方式](#2.2%20%E5%8A%A0%E8%BD%BD.class%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E5%BC%8F)
	- [2.3 类的生命周期](#2.3%20%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F)
	- [2.4 类加载器](#2.4%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8)
	- [2.5 双亲委派机制](#2.5%20%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6)
- [3 JVM内存模型](#3%20JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B)
	- [3.1 Java堆（Heap）](#3.1%20Java%E5%A0%86%EF%BC%88Heap%EF%BC%89)
	- [3.2 Java栈（Stack）](#3.2%20Java%E6%A0%88%EF%BC%88Stack%EF%BC%89)
	- [3.3 本地方法栈（Native Method Stacks）](#3.3%20%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%88Native%20Method%20Stacks%EF%BC%89)
	- [3.4 方法区（Method Area）](#3.4%20%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88Method%20Area%EF%BC%89)
	- [3.5 程序计数器（Program Counter Register）](#3.5%20%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88Program%20Counter%20Register%EF%BC%89)
- [4 GC算法 垃圾收集器](#4%20GC%E7%AE%97%E6%B3%95%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8)
	- [4.1 垃圾收集器（标记 - 清除算法）](#4.1%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E6%A0%87%E8%AE%B0%20-%20%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%EF%BC%89)
	- [4.2 垃圾收集器（标记 - 复制收集器）](#4.2%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E6%A0%87%E8%AE%B0%20-%20%E5%A4%8D%E5%88%B6%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%89)
	- [4.3 垃圾收集器（标记 - 压缩算法）](#4.3%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E6%A0%87%E8%AE%B0%20-%20%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%EF%BC%89)
	- [4.4 垃圾收集器（分代收集算法- 常用）](#4.4%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95-%20%E5%B8%B8%E7%94%A8%EF%BC%89)
	- [4.5 垃圾回收器（串行垃圾回收）](#4.5%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E4%B8%B2%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89)
	- [4.6 垃圾回收器（并行垃圾回收）](#4.6%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E5%B9%B6%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89)
	- [4.7 垃圾回收器（并发标记扫描垃圾回收）](#4.7%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E6%89%AB%E6%8F%8F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89)
	- [4.8 垃圾回收器（G1垃圾回收）](#4.8%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89)
	- [4.9 垃圾收集算法小结](#4.9%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E5%B0%8F%E7%BB%93)
- [5 GC分析 命令调优](#5%20GC%E5%88%86%E6%9E%90%20%E5%91%BD%E4%BB%A4%E8%B0%83%E4%BC%98)
	- [5.1 JVM调优目标](#5.1%20JVM%E8%B0%83%E4%BC%98%E7%9B%AE%E6%A0%87)
	- [5.2 JVM调优的常见命令工具](#5.2%20JVM%E8%B0%83%E4%BC%98%E7%9A%84%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7)
	- [5.3 JVM常见的调优参数](#5.3%20JVM%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B0%83%E4%BC%98%E5%8F%82%E6%95%B0)
- [6 JVM其他知识](#6%20JVM%E5%85%B6%E4%BB%96%E7%9F%A5%E8%AF%86)
	- [6.1 Java引用的四种状态](#6.1%20Java%E5%BC%95%E7%94%A8%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%8A%B6%E6%80%81)
	- [6.2 Java堆内存划分](#6.2%20Java%E5%A0%86%E5%86%85%E5%AD%98%E5%88%92%E5%88%86)
- [7 7、JVM的参考文献](#7%207%E3%80%81JVM%E7%9A%84%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE)

## 1 JVM简介

### 1.1 JVM是什么

JVM，即Java Virtual Machine，Java虚拟机。它通过模拟一个计算机来到达一个计算机所具有的计算功能。JVM能够跨计算机体系结构来执行Java字节码，主要是由于JVM屏蔽了与各个计算机平台相关的软件或硬件之间的差异，使得与平台相关的耦合统一由JVM提供者来实现。

### 1.2 JVM由那些部分组成

JVM体系总体分四大块
1. 类的加载机制
2. JVM内存结构
3. GC算法 垃圾回收
4. GC分析 命令调优

## 2 JVM的加载机制

### 2.1 什么是类的加载机制

类的加载是指将类的class文件的二进制读入内存中，将其放入运行时数据的方法区内，然后在堆区常见一个java.lang.class对象，用来封装类在方法区的数据结构。

类加载不需要等某个类被用到的时候再加载，jvm允许类加载器在预料到某个类将要被使用的时候就预先加载。如果加载遇到.class文件缺失或者存在错误，类加载器就必须在程序中主动使用该类的时才报告错误。如果该类一直没有被使用，那么该类加载器就不会报告错误。

### 2.2 加载.class文件的方式

1. 从本地系统中直接加载
2. 通过网络下载.class文件
3. 从zip,jar等归档文件中加载.class文件
4. 从专有的数据库中提取.class文件
5. 将Java源文件动态编译成.class文件
### 2.3 类的生命周期

![](https://image-for.oss-cn-guangzhou.aliyuncs.com/for-obsidian/Java_Study/2_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_Java%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83/1_Java%E5%9F%BA%E7%A1%80/1_Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240227204842371.png)

其中类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。
1. 加载：查找并加载类的二进制数据，在Java堆中也常见一个java.lang.Class类的对象
2. 连接：连接有包含三块内容（验证、准备、解析）
	- 验证：文件格式、元数据、字节码、符号引用验证
	- 准备：为类的静态变量分配内存，并将其初始化为默认值
	- 解析：把类中的符号引用转换为直接引用
3. 初始化：为类的静态变量赋予正确的初始值
4. 使用：new出对象，程序中使用
5. 卸载：执行GC

### 2.4 类加载器

![](https://image-for.oss-cn-guangzhou.aliyuncs.com/for-obsidian/Java_Study/2_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_Java%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83/1_Java%E5%9F%BA%E7%A1%80/1_Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240227205148933.png)


`启动类加载器`
	BootstrapClassLoader，负责加载存放在`JDK\jre\lib（JDK代表JDK的安装目录，下同）`，或被 -Xbootclasspath参数指定路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被其加载）。启动加载器是无法被Java程序直接引用的。
`扩展类加载器`
	ExtensionClassLoader，sun.misc.Launcher$ExtClassLoader实现，它是java.lang.ClassLoader的子类。该类加载器`负责加载Java的扩展库JAVA_HOME/jre/lib/ext/*.jar或者java.ext.dirs路径下的内容`。
`应用类加载器`
	AppClassLoader，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器
### 2.5 双亲委派机制

双亲委派机制的工作流是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。
![](https://image-for.oss-cn-guangzhou.aliyuncs.com/for-obsidian/Java_Study/2_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_Java%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83/1_Java%E5%9F%BA%E7%A1%80/1_Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240227205927918.png)

双亲委派机制：
（1）当 AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。  
（2）当 ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。  
（3）如果 BootStrapClassLoader加载失败（例如在 $JAVA_HOME/jre/lib里未查找到该class），会使用 ExtClassLoader来尝试加载；  
（4）若ExtClassLoader也加载失败，则会使用 AppClassLoader来加载，如果 AppClassLoader也加载失败，则会报出异常 ClassNotFoundException。

## 3 JVM内存模型

![](https://image-for.oss-cn-guangzhou.aliyuncs.com/for-obsidian/Java_Study/2_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_Java%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83/1_Java%E5%9F%BA%E7%A1%80/1_Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240227222446871.png)

![](https://image-for.oss-cn-guangzhou.aliyuncs.com/for-obsidian/Java_Study/2_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_Java%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83/1_Java%E5%9F%BA%E7%A1%80/1_Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240228000655632.png)



![](https://image-for.oss-cn-guangzhou.aliyuncs.com/for-obsidian/Java_Study/2_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_Java%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83/1_Java%E5%9F%BA%E7%A1%80/1_Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240227222523438.png)

### 3.1 Java堆（Heap）

`所有通过new创建的对象的内存都在堆中分配`，堆的大小可以通过-Xmx和-Xms来控制。堆被划分为新生代和旧生代，新生代又被进一步划分为Eden和Survivor区最后Survivor由From Space和To Space组成

1. 与程序开发密切相关
2. 应用系统对象都保存在Java堆中
3. 所有线程共享Java堆
4. 对分代GC来说，堆也是分代的
5. GC的主要工作区间
### 3.2 Java栈（Stack）

`每个线程执行每个方法的时候都会在栈中申请一个栈帧`，`每个栈帧包括局部变量去和操作数栈`，用于存放此次方法调用过程中的临时变量、参数和中间结果

-xss：设置每个线程的堆栈大小，JDK1.5+ 每个线程堆栈大小为1M，一般来说如果栈不是很深的话，1M是绝对够用了

1. 线程私有
2. 栈由一些列帧组成（因此Java栈也叫做帧栈）
3. 帧保存一个方法的局部变量、操作数栈、常量池指针
4. 每一次方法调用创建一个帧，并压栈
### 3.3 本地方法栈（Native Method Stacks）

用于支持native方法的执行，存储了每个native方法调用的状态
### 3.4 方法区（Method Area）

`存放了要加载的类信息、静态变量、final类型的常量、属性和方法。`

JVM用持久代（Permanent Generation）来存放方法区，可通过-XX：PermSize 和 -XX：MaxPermSize来指定最小值和最大值

- 保存装载的类信息
	1. 类型的常量池
	2. 字段，方法信息
	3. 方法字节码
- 通常和永久区（Perm）关联在一起
- JDK6时，String等常量信息置于方法区，JDK7时，已移动至堆
### 3.5 程序计数器（Program Counter Register）

虽然JVM中的程序计数器并不像汇编语言中的程序计数器一样是物理概念上的CPU寄存器，但是JVM中的程序计数器的功能跟汇编语言中的程序计数器的功能在逻辑上是等同的，也就是说用来指示 执行哪条指令的。

由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复到切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能相互被干扰，否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的

在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是点前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。

由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对应程序计数器是不会发生内存溢出现象（OutOfMemory）的。
## 4 GC算法 垃圾收集器

### 4.1 垃圾收集器（标记 - 清除算法）

标记-清除（Mark-Sweep）算法，如它的名字一样，算法分为”标记“和”清除“两个阶段：
- 首先，标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。
- 之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的

它的缺点主要有两点：
- 以个效率问题，标记和清除的过程的效率都不高
- 另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前出发来一次垃圾收集动作
![](https://image-for.oss-cn-guangzhou.aliyuncs.com/for-obsidian/Java_Study/2_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_Java%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83/1_Java%E5%9F%BA%E7%A1%80/1_Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240227224252449.png)

### 4.2 垃圾收集器（标记 - 复制收集器）

复制算法是为了解决效率问题而出现的，它`将可用的内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉`。

这样每次只需要对整个半区进行内存回收，内存分配时也不需要考虑内存碎片等复制情况，只需要移动指正，按照顺序分配即可。
![](https://image-for.oss-cn-guangzhou.aliyuncs.com/for-obsidian/Java_Study/2_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_Java%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83/1_Java%E5%9F%BA%E7%A1%80/1_Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240227224603337.png)

### 4.3 垃圾收集器（标记 - 压缩算法）

复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。

复制算法在对象存活率较高的场景下要进行大量的复制操作，效率很低。万一对象100%存活，那么需要有额外的空间进行分配担保。老年代都是不易被回收的对象，存活率很高，因此一般不能直接选用复制算法。

根据老年代的特点，有人提出了另外一种标记-整理算法，过程与标记-清除算法一样，不过不是直接对可回收对象进行清理，而是`让所有存活对象都向一段移动，然后直接清理掉边界以外的内存`。
![](https://image-for.oss-cn-guangzhou.aliyuncs.com/for-obsidian/Java_Study/2_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/1_Java%E8%AF%AD%E8%A8%80%E6%A0%B8%E5%BF%83/1_Java%E5%9F%BA%E7%A1%80/1_Java%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20240227225001135.png)

### 4.4 垃圾收集器（分代收集算法- 常用）

一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。

在`新生代`中，每次垃圾收集时都会发现有大批对象死去，`只有少量存活，那就选用复制算法`，只需要付出少量存活对象的复制成本就可以完成收集。

而`老年代`中，因为`对象存活率高`，没有额外空间对它进行分配担保，就`必须使用“标记-清理”或“标记-整理”算法来进行回收`。
### 4.5 垃圾回收器（串行垃圾回收）

串行垃圾回收器通过持有应用程序所有的线程进行工作。

它为单线程环境设计，只使用一个单独的线程进行垃圾回收，通过冻结所有引用程序线程进行工作，所以可能不适合服务器环境。它最适合的是简单的命令行程序。
### 4.6 垃圾回收器（并行垃圾回收）

并行垃圾回收器也叫做 throughput collector。

它是`JVM默认垃圾回收器`。与串行垃圾回收器不同，它使用多线程进行垃圾回收。相似的是，它也会 冻结所有的应用程序线程，当执行垃圾回收的时候
### 4.7 垃圾回收器（并发标记扫描垃圾回收）

并发标记垃圾回收使用多线程扫描内存，标记需要清理的实例并且清理被标记过的实例。

并发标记垃圾回收只会在下面两种情况次用应用程序所有线程：
- 当标记的引用对象在tenured区域；
- 在进行垃圾回收的时候，堆内存的数据被并发的改变；

相比并行垃圾回收器，并发标记扫描垃圾回收器使用更多的CPU来确保程序的吞吐量。如果我们可以为了更好的程序性能分配更多的CPU，那么并发标记上扫描垃圾回收器是更好的选择。

我们可以通过JVM参数 XX：+USeParNewGC 打开并发标记扫描垃圾回收器
### 4.8 垃圾回收器（G1垃圾回收）

G1垃圾回收器适用于堆内存很大的情况，它将堆内存分割成不同的区域，并且并发的对其进行垃圾回收。

G1也可以在回收内存之后堆剩余的堆内存空间进行压缩。并发标记扫描垃圾回收器在STW情况下压缩内存。G1垃圾回收回有限选择第一块垃圾最多的区域。
### 4.9 垃圾收集算法小结

由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。

垃圾回收有两种类型，Minor GC 和 Full GC。
- Minor GC：对新生代进行回收，不会影响到老年代。因为新生代的Java对象大多死亡频繁，所以Minor GC非常频繁，一般在这里使用速度快、效率高的算法、使得垃圾回收能尽快完成
- Full GC：也叫Major GC，对整个堆进行回收，包括新生代和老年代。由于Full GC需要对整个堆进行回收，所以比Minor GC要慢，因此，应该减少Full GC的次数，导致Full GC的原因包括：老年代被写满、永久代（Perm）被写满 和 System.gc()被显式调用

## 5 GC分析 命令调优

### 5.1 JVM调优目标

使用较小的内存占用来获得较高的吞吐量或较低的延迟

程序在上线的测试或运行中有时会出现一些大大小小的JVM问题，比如CPU load过高、请求延迟、tps降低等，甚至出现内存泄漏（每次垃圾收集使用的时间越来越长，垃圾收集频率越来越高，每次垃圾收集清理掉的垃圾数据越来越少）、内存溢出导致系统崩溃，因此需要对JVM进行调优，使得程序在正常运行的前提下，获得更高的用户体验和运行效率。

这里有几个比较重要的指标：
1. 内存占用：程序正常运行需要的内存大小
2. 延迟：由于垃圾收集而一起的程序停顿时间
3. 吞吐量：用户程序运行时间占用户程序和垃圾收集占用总时间的比值

当然，和CAP原则一样，同时满足一个程序内存占用小、延迟低、高吞吐量是不可能的，程序的目标不同，调优时所考虑的方向也不同，在调优之前，必须要结合实际场景，有明确的优化目标，找到性能瓶颈，对瓶颈有针对性的优化，最后进行测试，通过各种监控工具确认调优后的结果是否符合目标。

### 5.2 JVM调优的常见命令工具

1. jps命令用于查询正在运行的JVM进程
2. jstat可以实时显式本地或远程JVM进程中类装载、内存、垃圾收集、JIT编译等数据
3. jinfo用于查询点前运行着的JVM属性和参数的值
4. jmap用于显示点前Java堆和永久代的详细信息
5. jhat用于分析使用jmap生成的dump文件，是JDK自带的工具
6. jstack用于生成点前JVM的所有线程快照，线程快照是虚拟机每一条线程正在执行的方法，目的是定位线程出现长时间停顿的原因
### 5.3 JVM常见的调优参数

-Xmx
	指定java程序的最大堆内存，使用java -Xmx5000m -version判断点前系统能分配的最大内存

-Xms
	指定最小堆内存，通常设置成跟最大堆内存一样，减少GC

-Xmn
	设置年轻代大小。整个堆大小 = 年轻代大小（1） + 老年代大小（2）。所以增大年轻代后，会减少老年代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8

-XX：NewRatio
	新生代和老年代的比例，减一设为整个堆大小的1/3或者1/4

-Xss
	指定线程的最大栈空间，此参数决定了java函数调用的深度，值越大调用深度越深，若值太小则容易出现栈溢出错误（StackOverflowError）

-XX：PermSize
	指定方法区（永久区）的初始值，默认是物理内存的1/64，在Java8永久区移除, 代之的是元数据区， 由-XX:MetaspaceSize指定

-XX：MaxPermSize
	指定方法区的最大值, 默认是物理内存的1/4， 在java8中由-XX:MaxMetaspaceSize指定元数据区的大小

-XX：NewRatio=n
	年老代与年轻代的比值，-XX:NewRatio=2, 表示年老代与年轻代的比值为2:1

-XX：SurvivorRatio=n
	Eden区与Survivor区的大小比值，-XX:SurvivorRatio=8表示Eden区与Survivor区的大小比值是8:1:1，因为Survivor区有两个(from, to)。


-XX：NewSize 和 -XX：MaxNewSize
	用于设置年轻代的大小，建议设为整个堆大小的1/3或者1/4,两个值设为一样大。
	
-XX：SurvivorRatio
	用于设置Eden和其中一个Survivor的比值，这个值也比较重要。

-XX：+PrintTenuringDistribution
	这个参数用于显示每次Minor GC时Survivor区中各个年龄段的对象的大小。

-XX：InitialTenuringThreshol 和 -XX：MaxTenuringThreshol
	用于设置晋升到老年代的对象年龄的最小值和最大值，每个对象在坚持过一次Minor GC之后，年龄就加1。

-XX：+printGC
	这个打印的GC信息

X:loggc:log/gc.log
	这个就表示，指定输出gc.log的文件位置


## 6 JVM其他知识

### 6.1 Java引用的四种状态

`强引用`
	- 用的最广。我们平时写代码，new一个Object存放在堆内存，然后用一个引用指向它，这就是强引用
	- 如果一个对象具有强引用，那么垃圾回收器绝对不会回收它。当内存空间不足，JVM宁愿抛出OOM错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题

`软引用`
	- 如果一个对象只具有软引用，则内存空间足够时，垃圾回收器就不会回收它
	- 如果内存空间不足了，就会回收这些对象的内存（如果内存不足，随时有可能被回收）
	- 只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存

`弱引用`
	- 弱引用和软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期
	- 每次执行GC的时候，一旦发现了只具有弱引用的对象，不管点前内存空间足够与否，都会回收它的内存
	- 不过，由于GC是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象

`虚引用`
	- 顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期
	- 如果一个对象仅持有虚引用，那么它就和没有引用一样，在任何时候都可能被GC

### 6.2 Java堆内存划分

Java中的堆是JVM所管理的最大的一块内存空间，主要用于存放各种类的实例对象。

在Java中，堆被划分成两个不同的区域：年轻代 ( Young )、老年代 ( Tenured)。年轻代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。 这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。

`年轻代`
	- 年轻代用来存放新近创建的对象，尺寸随堆大小的增大和减小而相应的变化，默认值是保持为堆大小的1/15，可以通过 -Xmn 参数设置年轻代为固定大小，也可以通过 -XX:NewRatio 来设置年轻代与年老代的大小比例，年青代的特点是对象更新速度快，在短时间内产生大量的“死亡对象”。
	- 年轻代的特点是产生大量的死亡对象,并且要是产生连续可用的空间, 所以使用复制清除算法和并行收集器进行垃圾回收.对年轻代的垃圾回收称作初级回收 (minor gc)。

`老年代`
	- Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法。
	- 现实的生活中，老年代的人通常会比新生代的人 “早死”。堆内存中的老年代(Old)不同于这个，老年代里面的对象几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 “死掉” 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。 另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。

`永久代`
	- 永久代是Hotspot虚拟机特有的概念，是方法区的一种实现，别的JVM都没有这个东西。在Java 8中，永久代被彻底移除，取而代之的是另一块与堆不相连的本地内存——元空间。
	- 永久代或者“Perm Gen”包含了JVM需要的应用元数据，这些元数据描述了在应用里使用的类和方法。注意，永久代不是Java堆内存的一部分。永久代存放JVM运行时使用的类。永久代同样包含了Java SE库的类和方法。永久代的对象在full GC时进行垃圾收集。

## 7 7、JVM的参考文献  
（1）优秀书本：《《深入理解JAVA虚拟机：JAVA高级特性与最佳实践》》  
[https://blog.csdn.net/huyuyang6688/article/details/81490570](https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fhuyuyang6688%2Farticle%2Fdetails%2F81490570)
