## 目录

- [1 比较和交换相邻元素的排序](#1%20%E6%AF%94%E8%BE%83%E5%92%8C%E4%BA%A4%E6%8D%A2%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0%E7%9A%84%E6%8E%92%E5%BA%8F)
	- [1.1 冒泡排序](#1.1%20%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F)
	- [1.2 插入排序](#1.2%20%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F)
- [2 相邻元素比较算法的时间复杂度](#2%20%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0%E6%AF%94%E8%BE%83%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)
	- [2.1 冒泡排序的时间复杂度](#2.1%20%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)
	- [2.2 插入排序的时间复杂度](#2.2%20%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)
	- [2.3 一般算法下界分析](#2.3%20%E4%B8%80%E8%88%AC%E7%AE%97%E6%B3%95%E4%B8%8B%E7%95%8C%E5%88%86%E6%9E%90)
- [3 希尔排序](#3%20%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F)
	- [3.1 分析](#3.1%20%E5%88%86%E6%9E%90)
	- [3.2 代码实现](#3.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0)
	- [3.3 时间复杂度](#3.3%20%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6)
- [4 拆归类的排序算法](#4%20%E6%8B%86%E5%BD%92%E7%B1%BB%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95)
	- [4.1 归并排序](#4.1%20%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F)
	- [4.2 快速排序](#4.2%20%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F)
- [5 线性时间的排序](#5%20%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E7%9A%84%E6%8E%92%E5%BA%8F)
	- [5.1 桶排序](#5.1%20%E6%A1%B6%E6%8E%92%E5%BA%8F)
	- [5.2 基数排序¿](#5.2%20%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%C2%BF)
- [6 选择排序](#6%20%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F)

## 1 比较和交换相邻元素的排序

### 1.1 冒泡排序

- 每轮冒泡不断地比较`相邻`的两个元素，如果他们是`逆序`的，则`交换`他们的位置
- 下一轮冒泡，可以`调整未排序的右边界`，减少不必要比较

```java
public static int[] BubbleSort(int[] arr){  
    for (int i = 0; i < arr.length-1; i++) {  
        for (int j = 0; j < arr.length-i-1; j++) {  
            if (arr[j]>arr[j+1]){  
                int temp = arr[j];  
                arr[j] = arr[j+1];  
                arr[j+1] = temp;  
            }  
        }  
    }  
    return arr;  
}

//优化1：
public static int[] BubbleSort(int[] arr){  
    for (int i = 0; i < arr.length-1; i++) {  
	    boolean isFlag = true;
        for (int j = 0; j < arr.length-i-1; j++) {  
            if (arr[j]>arr[j+1]){  
	            isFlag = false;
	            //如果发生了元素交换，说明存在逆序对
                int temp = arr[j];  
                arr[j] = arr[j+1];  
                arr[j+1] = temp;  
            }  
        }  
        if（isFlag）
	        break;
	    //作用1：如果没有元素发生交换了，就直接停止外层循环
	    //作用2：如果数组本来就是有序的，那么在第一次循环的时候，就结束循环了，时间复杂度为O(N)的
    }  
    return arr;  
}

//优化2：
public static int[] BubbleSort(int[] arr){
	int j = arr.length-1;
	do{
		int x = 0; 
		for(i = 0; i<j ;i++){
			if (arr[j]>arr[j+1]){  
                int temp = arr[j];  
                arr[j] = arr[j+1];  
                arr[j+1] = temp;  
                x = i;
                //x记录最近一次交换元素后的索引位置  
				//若x没有发生变化，即x右边的元素是有序的  
				//所以x记录的是无序数组的右边界
            }  
		}
		j = x;
		//当j=0，停止循环  
		//情况1：完成排序后j=0  
		//情况2：arr为有序数组，第一次循环时，没有发现逆序对，即排好序的，直接停止循环。
	}while(j！=0)
	return arr；

}
```

### 1.2 插入排序

- 每次由后一个数，向前一个数插入，如果他们是逆序的，则交换他们的位置

```java
public static int[] insertSort(int[] arr){  
    for (int i = 1; i < arr.length - 1; i++) {  
        for (int j = i; j > 0 ; j--) {  
            if (arr[j-1]>arr[j]){  
                int temp = arr[j];  
                arr[j] = arr[j-1];  
                arr[j-1] = temp;  
            }else{  
                break;  //不加的话，会进行无用比较
            }  
        }  
    }  
    return arr;  
}
```

## 2 相邻元素比较算法的时间复杂度

### 2.1 冒泡排序的时间复杂度

- 假设替换和比较都是t的常数时间消耗
- 最好的情况：是排好序的，即进行比较 $O(N^2)$
- 最坏的情况：全是逆序的，也是进行比较和替换$O(N^2)+O(N^2)$，即$O(N^2)$
- 所以平均复杂度，也是$O(N^2)$，了解在插入后说

### 2.2 插入排序的时间复杂度

- 最好的情况：是排好序的，第二层for每次都只执行一次，即$O(N)$
- 最坏的情况：全是逆序的，很显然是$O(N^2)$

- `逆序对的定义`
	- 如果 $index1 < index2$ ，而 $arr[index1] > arr[index2]$
	- 那么$arr[index1]$   $arr[index2]$为一对逆序对 
- `结论`
	- <font color="#d83931">相邻的元素交换</font>会消除一个逆序对
	- 每个逆序对，都需要一次交换区消除
	- 所以<font color="#d83931">逆序对的个数 = 交换的次数</font>

- `分析平均时间复杂度`
	- 数组有几个逆序对， 那么平均的交换次数=平均的逆序对个数
	- N个互异的数字，并且随机排列，其平均逆序对为 $N*(N-1)/4$
	- 就算在插入一个数，并且这个数是有序的，那么这个数的插入时间为$N-1$
	- 所以平均时间复杂度为 $O(N^2)$

### 2.3 一般算法下界分析

- 通过交换相邻元素排序的任何算法平均都需要$Ω(N^2)$

## 3 希尔排序

### 3.1 分析

- 假设根据[8,4,2,1]的顺序
- 对一个由16个元素的数组，按上述顺序，间隔进行插入排序
- 如下
```java
假设用4
a[4] --- a[0]
a[5] --- a[1]
a[6] --- a[2]
a[7] --- a[3]
a[8] --- a[4],a[0]
a[9] --- a[5],a[1]
a[10] --- a[6],a[2]
a[11] --- a[7],a[3]
a[12] --- a[8],a[4],a[0]
...依次类推
```

### 3.2 代码实现

```java

```

### 3.3 时间复杂度

## 4 拆归类的排序算法

### 4.1 归并排序

### 4.2 快速排序

## 5 线性时间的排序

### 5.1 桶排序

### 5.2 基数排序¿

## 6 选择排序

- 每一轮选择，找出最大\最小的元素，并把它交换到合适的位置

- 代码实现
- 
