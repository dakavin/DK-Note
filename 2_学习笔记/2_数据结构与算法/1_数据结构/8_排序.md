
## 1. 比较和交换相邻元素的排序

### 1.1 冒泡排序

- 每轮冒泡不断地比较`相邻`的两个元素，如果他们是`逆序`的，则`交换`他们的位置
- 下一轮冒泡，可以`调整未排序的右边界`，减少不必要比较

```java
public static int[] BubbleSort(int[] arr){  
    for (int i = 0; i < arr.length-1; i++) {  
        for (int j = 0; j < arr.length-i-1; j++) {  
            if (arr[j]>arr[j+1]){  
                int temp = arr[j];  
                arr[j] = arr[j+1];  
                arr[j+1] = temp;  
            }  
        }  
    }  
    return arr;  
}

//优化1：
public static int[] BubbleSort(int[] arr){  
    for (int i = 0; i < arr.length-1; i++) {  
	    boolean isFlag = true;
        for (int j = 0; j < arr.length-i-1; j++) {  
            if (arr[j]>arr[j+1]){  
	            isFlag = false;
	            //如果发生了元素交换，说明存在逆序对
                int temp = arr[j];  
                arr[j] = arr[j+1];  
                arr[j+1] = temp;  
            }  
        }  
        if（isFlag）
	        break;
	    //作用1：如果没有元素发生交换了，就直接停止外层循环
	    //作用2：如果数组本来就是有序的，那么在第一次循环的时候，就结束循环了，时间复杂度为O(N)的
    }  
    return arr;  
}

//优化2：
public static int[] BubbleSort(int[] arr){
	int j = arr.length-1;
	do{
		int x = 0; 
		for(i = 0; i<j ;i++){
			if (arr[j]>arr[j+1]){  
                int temp = arr[j];  
                arr[j] = arr[j+1];  
                arr[j+1] = temp;  
                x = i;
                //x记录最近一次交换元素后的索引位置  
				//若x没有发生变化，即x右边的元素是有序的  
				//所以x记录的是无序数组的右边界
            }  
		}
		j = x;
		//当j=0，停止循环  
		//情况1：完成排序后j=0  
		//情况2：arr为有序数组，第一次循环时，没有发现逆序对，即排好序的，直接停止循环。
	}while(j！=0)
	return arr；

}
```

### 1.2 插入排序

- 每次由后一个数，向前一个数插入，如果他们是逆序的，则交换他们的位置

```java
public static int[] insertSort(int[] arr){  
    for (int i = 1; i < arr.length - 1; i++) {  
        for (int j = i; j > 0 ; j--) {  
            if (arr[j-1]>arr[j]){  
                int temp = arr[j];  
                arr[j] = arr[j-1];  
                arr[j-1] = temp;  
            }else{  
                break;  //不加的话，会进行无用比较
            }  
        }  
    }  
    return arr;  
}
```

## 2. 相邻元素比较算法的时间复杂度

### 2.1 冒泡排序的时间复杂度

- 假设替换和比较都是t的常数时间消耗
- 最好的情况：是排好序的，即进行比较 $O(N^2)$
- 最坏的情况：全是逆序的，也是进行比较和替换$O(N^2)+O(N^2)$，即$O(N^2)$
- 所以平均复杂度，也是$O(N^2)$，了解在插入后说

### 2.2 插入排序的时间复杂度

- 最好的情况：是排好序的，第二层for每次都只执行一次，即$O(N)$
- 最坏的情况：全是逆序的，很显然是$O(N^2)$

- `逆序对的定义`
	- 如果 $index1 < index2$ ，而 $arr[index1] > arr[index2]$
	- 那么$arr[index1]$   $arr[index2]$为一对逆序对 
- `结论`
	- <font color="#d83931">相邻的元素交换</font>会消除一个逆序对
	- 每个逆序对，都需要一次交换区消除
	- 所以<font color="#d83931">逆序对的个数 = 交换的次数</font>

- `分析平均时间复杂度`
	- 数组有几个逆序对， 那么平均的交换次数=平均的逆序对个数
	- N个互异的数字，并且随机排列，其平均逆序对为 $N*(N-1)/4$
	- 就算在插入一个数，并且这个数是有序的，那么这个数的插入时间为$N-1$
	- 所以平均时间复杂度为 $O(N^2)$

### 2.3 一般算法下界分析

- 通过交换相邻元素排序的任何算法平均都需要$Ω(N^2)$

## 3. 希尔排序

### 3.1 分析

- 假设根据[8,4,2,1]的顺序
- 对一个由16个元素的数组，按上述顺序，间隔进行插入排序
- 如下
```java
假设用4
a[4] --- a[0]
a[5] --- a[1]
a[6] --- a[2]
a[7] --- a[3]
a[8] --- a[4],a[0]
a[9] --- a[5],a[1]
a[10] --- a[6],a[2]
a[11] --- a[7],a[3]
a[12] --- a[8],a[4],a[0]
...依次类推
```

### 3.2 代码实现

```java

```

### 3.3 时间复杂度

## 4. 拆归类的排序算法

### 4.1 归并排序

### 4.2 快速排序

## 5. 线性时间的排序

### 5.1 桶排序

### 5.2 基数排序¿

## 6. 选择排序

- 每一轮选择，找出最大\最小的元素，并把它交换到合适的位置

- 代码实现
- 
