
[28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

## 1、题意理解

题意：对于两个字符串s1和s2，在s1中找到和s2相同的子串，且返回第一个相同子串的头元素下标

**示例 1: 输入: haystack = "hello", needle = "ll" 输出: 2**

**示例 2: 输入: haystack = "aaaaa", needle = "bba" 输出: -1**

说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。

## 2、思路

### 2.1 暴力匹配

对于 s1 = "aabaabaaf" 和 s2 = "aabaaf" 这两个字符串
- 两个字符串都从下标为0开始，i1=0，i2=0，然后同步向后移动
- 如果s2字符串没有最后一个节点，就有匹配不上的字符，s1字符串从i1=1开始，s2重新从i2=0开始，继续上一步操作
- 直到s2可以完全匹配（即i2大于s2.length）此时找到匹配串，并记录第一个字符的下标，并返回
- 如果i1>s1.length都没有匹配上，说明没有

### 2.2 KMP算法

[0_KMP算法](0_KMP算法.md)
## 3、代码实现

### 3.1 暴力匹配

```java
/**
 * 基于窗口滑动的算法
 * <p>
 * 时间复杂度：O(m*n)
 * 空间复杂度：O(1)
 * 注：n为haystack的长度，m为needle的长度
 */
class Solution {
    public int strStr(String haystack, String needle) {
        int m = needle.length();
        int n = haystack.length();
        //1. 先排除不符合的情况
        if(m==0){
            return 0;
        }
        if(n<m){
            return -1;
        }
        //2.逐一匹配,匹配的次数最大为n-m+1
        int i = 0; //haystack字符串的指针
        int j = 0; //needle字符串的指针
        while(i<n-m+1){
            //2.1 找到首字母相等
            while(i<n&&haystack.charAt(i)!=needle.charAt(j)){
                i++;
            }
            //2.2 没有首字母相等
            if(i==n){
                return -1;
            }
            //2.3 遍历后续字符，判断是否相等
            i++;
            j++;
            while(i<n&&j<m&&haystack.charAt(i)==needle.charAt(j)){
                i++;
                j++;
            }
            //2.4 找到相等/不相等的情况
            if(j==m){
                return i-j;
            }else{
                //回退i和j指针
                i -= j-1;
                j=0;
            }
        }
        return -1;
    }
}
```

### 3.2 KMP

```java
// 方法一
class Solution {
    public void getNext(int[] next, String s){
        int j = -1;
        next[0] = j;
        for (int i = 1; i < s.length(); i++){
            while(j >= 0 && s.charAt(i) != s.charAt(j+1)){
                j=next[j];
            }

            if(s.charAt(i) == s.charAt(j+1)){
                j++;
            }
            next[i] = j;
        }
    }
    public int strStr(String haystack, String needle) {
        if(needle.length()==0){
            return 0;
        }

        int[] next = new int[needle.length()];
        getNext(next, needle);
        int j = -1;
        for(int i = 0; i < haystack.length(); i++){
            while(j>=0 && haystack.charAt(i) != needle.charAt(j+1)){
                j = next[j];
            }
            if(haystack.charAt(i) == needle.charAt(j+1)){
                j++;
            }
            if(j == needle.length()-1){
                return (i-needle.length()+1);
            }
        }

        return -1;
    }
}
```

```java
class Solution {
    //前缀表（不减一）Java实现
    public int strStr(String haystack, String needle) {
        if (needle.length() == 0) return 0;
        int[] next = new int[needle.length()];
        getNext(next, needle);

        int j = 0;
        for (int i = 0; i < haystack.length(); i++) {
            while (j > 0 && needle.charAt(j) != haystack.charAt(i)) 
                j = next[j - 1];
            if (needle.charAt(j) == haystack.charAt(i)) 
                j++;
            if (j == needle.length()) 
                return i - needle.length() + 1;
        }
        return -1;

    }
    
    private void getNext(int[] next, String s) {
        int j = 0;
        next[0] = 0;
        for (int i = 1; i < s.length(); i++) {
            while (j > 0 && s.charAt(j) != s.charAt(i)) 
                j = next[j - 1];
            if (s.charAt(j) == s.charAt(i)) 
                j++;
            next[i] = j; 
        }
    }
}
```