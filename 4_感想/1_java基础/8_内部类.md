在Java中，可以将一个类定义在另一个类里面或者一个方法里边，这样的类称为内部类，广泛意义上的内部类一般包括四种：****<font color="#4f81bd">成员内部类</font>****，<font color="#4f81bd">局部内部类</font>，<font color="#4f81bd">匿名内部类</font>，<font color="#4f81bd">静态内部类</font> 。

# 1.成员内部类

（1）该类像是<font color="#4f81bd">外部类的一个成员</font>，可以无条件的访问外部类的所有成员属性和成员方法（包括private成员和静态成员）；

（2）成员内部类拥有与外部类同名的成员变量时，会发生隐藏现象<span style="background:#d4b106">(this$0)</span>，即默认情况下访问的是成员内部类中的成员。如果要访问外部类中的成员，需要以下形式访问：【外部类.this.成员变量  或  外部类.this.成员方法】；

（3）在<font color="#4f81bd">外部类</font>中如果要<font color="#4f81bd">访问成员内部类的成员</font>，<font color="#4f81bd">必须先创建一个成员内部类的对象</font>，再通过指向这个对象的引用来访问；

（4）成员内部类是依附外部类而存在的，也就是说，如果要<font color="#4f81bd">创建成员内部类的对象，前提是必须存在一个外部类的对象</font>；

（5）<font color="#4f81bd">内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限</font>。如果成员内部类用private修饰，则只能在外部类的内部访问；如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。外部类只能被public和包访问两种权限修饰。

# 2.局部内部类

（1）局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于<font color="#4f81bd">局部内部类的访问仅限于方法内或者该作用域内</font>；

（2）局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。

（3）在jdk1.8版本之前如果"内部类"需要访问其所在方法中的局部属性，则这个局部属性需要用final修饰。jdk1.8版本就不需要进行这个操作了，主要是jdk1.8之后增加了effective final这样的功能，但是其本质还是final的，是不能对其进行修改的，看一个例子：
```java
public class innerTest {
	public void innerMethod(){
		int num = 100;
		class innerClass{
			public void print(){
				System.out.println("可以访问方法的属性，但不可以修改："+num);
			}
		}
		innerClass inner = new innerClass();
		inner.print();
	}
	public static void main(String[] args) {
		innerTest inner = new innerTest();
		inner.innerMethod();
	}	
}
//输出结果为：可以访问方法的属性，但不可以修改：100
```

Q：为什么JAVA的编译器要做除这种限制呢？
A ：因为局部内部类最终会被编译为一个单独的类，其所访问的局部变量会成为这个类的属性。如果访问的一个值类型局部变量，就会造成这个类的属性与所访  问的局部变量不是同一个，会造成数据不同步。 所以强制要求局部变量必须为final，避免数据不同步。

# 3.匿名内部类

（1）一般使用匿名内部类的方法来编写事件监听代码；

（2）匿名内部类是不能有访问修饰符和static修饰符的；

（3）匿名内部类是唯一一种没有构造器的类；

（4）匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。

# 4.内部静态类

（1）静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似；

（2）不能使用外部类的非static成员变量或者方法。
