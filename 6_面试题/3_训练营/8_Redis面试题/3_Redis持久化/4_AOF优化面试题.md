
## 1 AOF混合持久化方案是什么？（很简单，把它学了）

分析：
- 需要记住的是，AOF混合持久化，就是在AOF重写的基础上 做了一些改动

回答：
- AOF混合持久化 会使用`RDB持久化函数 将内存数据写入到新的AOF文件中（数据格式也是RDB格式）`
- 而重写期间 新的写入命令 追加到 新的AOF文件 仍然是AOF格式
- 此时新的AOF文件就是由RDB格式和AOF格式组成的日志文件

## 2 为什么需要混合持久化

分析：
- 关键描述混合持久化解决了什么问题，既然混合，当然是利用两者的优势

回答：
- `混合持久化实际是AOF的优化`，还是AOF记录的方式，但是重写的时候是使用子进程将当前数据库内容保存为RDB格式，写到新的AOF文件，作为前半部分，后面新增的内容就和普通的AOF时一样写入后面。
- 这样做的好处是`既有RDB文件小、加载快的优势，也有AOF持久化数据丢失少的优势`

## 3 启动加载AOF文件时，怎么判断它是否混合持久化？ （很简单，把它学了）

分析：
- 只需要支持判断条件即可，混合持久化文件里有REDIS这个标记![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/7a7a862ebbb24c21d272d5d2e5d74aa3.png)

回答：
- `混合持久化的AOF文件里开头有REDIS这个标记，加载时候通过这个标记来进行的判断`

## 4 AOF重写你觉得有什么不足之处么？（对于冲击高分，可以学一下MP-AOF）

分析：
- 我们可以从 “一次拷贝 两次缓冲（日志）”来进行分析
	- 一次拷贝：使用子进程来重写日志，没有问题
	- 两处日志：重写期间 新的写命令，会将数据写入到两份日志（AOF缓冲和AOF重写缓冲）中，这是`额外的CPU和内存开销`；重写时会将AOF缓冲和AOF重写缓冲 分别 写入到旧日志和新日志中，这是`额外的磁盘开销`
- 除了清楚AOF的不足此处，如果还知道改进方案，那么会令人刮目相看，Redis 7.0就做了新的改进

回答1：
- 不足之处在于有一些额外开销，重复缓冲区写入的开销、主进程将增量数据写入管道的开销。
- Redis 7.0做了解决方案，叫做MP-AOF，核心思路在于不再是单个AOF文件，而是由manifest清单管理一组AOF文件，这组AOF文件由一个BASE文件、多个增量文件组成，这样重写时就可以主进程字节写新的增量文件，不再需要额外的缓冲区。



