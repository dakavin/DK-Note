
## 1 四种符号

1. 如果存在正常数$c$和$n0$,使得当$x>=n0$时，$T(x)<=cF(x)$,则记为 $T(x)=O(F(x))$

- 举例
```java
T(x) = x
F(x) = x^2
c = 1 , n0 = 1

//在x>1时
1*F(x) >= T(x)

T(x) = O(x^2)
```

- `即T的增长速度小于等于F`

2. 如果存在正常数$c$和$n0$,使得当$x>=n0$时，$T(x)>=cF(x)$,则记为 $T(N)=Ω(F(N))$

- 上述例子反过来写即可

- `即T的增长速度大于等于F`

3. 如果1和2同时满足，则$T(N)=Θ(F(N))$

- `即T的增长速度等于F`

4. 如果1满足，2不满足，则$T(N)=o(F(N))$

- `即T的增长速度严格小于F`

拓展性规则:
![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/e2095155d8e29561bd0b4a11f83ce689.png)



## 2 运行时间抽象为函数

1. 增长速度: 简单来说，是看一个函数，`它的最高次数`。

2. 我们要知道O或者小o的最佳写法

- 定义：+，—，\*，/ ，赋值，判断执行的时候为单位时间n,变量申明不需要时间。

- 例子1:
```java
int a=0;//n

if(a>1){//n
	a=100;//n
}

总时间:n+n+n = 3n = 3 ---> O(1)
```

- 例子2：
```java
int a=0;// n

While(a<X){ //n*(X+1)
	a=a+1;//2n*X
}

a=1000;//n

总时间:n+2n*X+n*(X+1)+n=1+2X+X+1+1=3X+3 ---> O(X)

T(x)=3X+3

F(X)=X

T(X)=O(F(X))
```

3. 步骤就是把代码大概抽象为一个函数$T(x)$，然后找到一个$F(X)$,可以表示成$T(X)=O(F(X))$.

4. 真正当我们去做算法分析，我们其实不必求T(x), 我们`直接就可以找到F(X)`

## 3 递归思想讲解

1. 考虑如下函数$f(x)=f(x-1)+1$, 并且$f(0)=0, x>=0$且$x$是整数。那么$f(10)$等于多少

- 计算如下：
```java
f(x)=x
x=1 f(x)=1 f(1)=f(0)+1=0+1=1
x=2 f(x)=2 f(2)=f(1)+1

f(2)=1+1=2,
f(3)=2+1=3
f(4)=f(3)+1=3+1=4
...
f(10) = f(9)+1 = f(8) + 1 +1 = ... = f(0) + 10 = 10


```

- 代码举例
```java

int test(int n){
	if(n == 0){
		return 0;
	}
	return test(n-1)+1;
}

//主方法:

f(3)--->test(3)--->3

test(3)调用并且挂起，return test(2)+1. //a

test(2)调用并且挂起，return test(1)+1 //b

test(1)调用并且挂起， return test(0)+1//c

test(0)调用直接返回0.

回到c这一步，test(1)调用结束，返回0+1=1.

回到b这一步，test(2)调用结束，返回1+1.

回到a这一步，test(3)调用结束，返回2+1.
```


2. 总结:

a.进行一项任务，这个任务可以拆解成更简单并且相同的任务去执行

b.一定要有一个基准的条件，否则这项任务可能永远也无法完成了

3. 上述递归运行时间评估

```java
int test(int n){   
	if(n==0)             //n
		return 0;        
	return test(n-1)+1;  // n + n + T(n-1)
}

//N代表输入的实参，n代表+ - * / 赋值 包括return语句消耗的常数时间.

T(N)=n+n+n+T(N-1), T(0)=n+n=2n

T(N)=3n+(N-1)*3n+T(0)=N*3n+2n=O(N)
```

## 4 数学归纳法和斐波那契数列

- `斐波那契数列(后面的数是前面2个数的和)`
- 时间复杂度是O（2^n）
- 2,2,4,6,10,16

- 1,1,2,3,5,8,13 
```java
long fib(int n){
	if(n<=2){
		return 1;
	}else{
		return fib(n-1)+fib(n-2);
	}
}
```

- 第一个问题：我们怎么证明这个方法对所有n成立？

- `数学归纳法`

- $f(k)=f(k-1)+f(k-2),k>=3$

- 如果f(k-1)是数列的第k-1项，k-2是数列的第k-2项，那f(k)一定会是数列的第k项。

- f(1)=1，f(2)=1
- f(3)一定是第三项
- f(4)=f(3)+f(2)，f(4)一定是第四项
- f(5)=f(4)+f(3)，f(5)一定是第五项

- 。。。。f(k)=f(k-1)=f(k-2)一定是第k项

- 第二个问题:为什么是一个不好的递归?
	- 并没有利用之前递归的有效信息

## 5 运行时间中的对数

考虑如下需求: 内存中已经有了从小到大排序好的数组A，给定一个整数X，求下标i，使得A\[i]=X。A数组的长度是N. 若X不在数组中，则返回-1。

分析如下代码:
```java
class A{
	static int binarySearch(int[] a,int x){
	  int low=0;
	  int high=a.length-1;
	  while(high-low>=0){
			 int mid=(high+low)/2;
			 if(a[mid]<x){	
					low=mid+1;	
			 }else if(a[mid]>x){	
					high=mid-1;	
			 }else{	
					return mid;	
			 }
		}
	  return -1;
	}
}

//每次进入都会发生(high-low)/2
//32 --> 16 --> 8 --> 4 --> 2 --> 1
//log2(32) + 1 = 6
//log2(N)
```


- 通过分析可以发现，如上方法的时间复杂度是O（logN）

- 总结: 如果一个算法，通过常数时间，可以让任务量只占原来任务量的部分（可以是一半），那么这个算法的时间复杂度就是O(logN）