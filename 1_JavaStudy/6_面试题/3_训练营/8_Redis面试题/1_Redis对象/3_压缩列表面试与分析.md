
## 1 压缩列表面试考点分析

压缩列表是List的底层数据结构，它体现了Redis节约内存的设计理念。

面试的考察点集中压缩列表本身的概念，结合List的操作，以及连锁更新这个经典问题

## 2 面试题

### 2.1 ZIPLIST有什么优点

分析：
- 基本认知考察。另外，说优点最好和LINKEDLIST对比，才好说。

回答：
- 压缩列表，顾名思义，是用来压缩结构，节约内存，相比于LINKEDLIST链表式设计，压缩列表的内存都是紧凑排列在一起的，这就带来了几个优点：
	1. 节约内存；
	2. 方便一次性分配；
	3. 遍历时局部性更强；
- 如果单独拉开视角看ZIPLIST的优点，那就是内存利用率很高，也能减少内存碎片

### 2.2 ZIPLIST是怎么压缩数据的？

分析：
- 这个问题就是对ZIPLIST数据结构本身的考察。ZIPLIST是为了节约内存开发的，回答这个问题可以从ZIPLIST的结构入手。下图是ZIPLIST的结构：![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/b17d2fef91f8985ea81cb460f67171ce.png)
- 其中entry结构为![|380](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2024/04/155cdcac9120f2b428cf06338c825aa0.png)
![](assets/Pasted%20image%2020231015210713.png)

- 为了方便记忆和理解，可以将ZIPLIST分为三部分讲述：
	1. 结构头，即header，包括`<zlbytes> <zltail> <zllen>`字段
	2. 数据部分，即entry列表，entry中有`<prevlen> <encoding> <entry-data>`字段
	3. 结尾部分，即zlend

回答：
- ZIPLIST可以看做三个部分，结构头、数据部分、结尾标识。其中，结构头记录了`字节数，起始地址距尾部节点距离、节点个数`；数据部分记录了`上个节点的长度，内容编码，内容本身`；最后有1个字节的`结尾标识`。

### 2.3 ZIPLIST下List可以从后往前遍历吗？

分析：
- 首先，一切的基石，在于要知道List是一种双端数据结构，无论那种底层编码，都需要能支持从后往前遍历。
- 接着，需要阐述ZIPLIST是如何做到从后往前遍历的，其实还是在考察ZIPLIST的数据结构。
- ZIPLIST下entry的结构包含了上一个节点的长度，所以可以通过上一个节点的长度，找到上个节点的起始位置，这样就能实现从后往前遍历。

回答：
- 可以，List是双端数据结构，无论那种底层编码，都需要能支持从后往前遍历。ZIPLIST每个节点中都`保存了上个节点的长度`，所以可以用`当前节点地址减去上个节点长度来找到上个节点的起始位置`，进而实现从后往前遍历。

### 2.4 ZIPLIST下List如何从前往后遍历？

分析：
- 首先，一切的基石，在于要知道List是一种双端数据结构，无论那种底层编码，都需要能支持从前往后遍历。
- ZIPLIST entry结构可以看上图
- 其中prevlen是找到上一个节点的起始位置，entry-data是实际的内容，显然，答案就在encoding里，encoding里无论是String还是Int都是可以知道长度信息的。

回答：
- 可以，List是双端数据结构，无论那种底层编码，都需要能支持从前往后遍历。ZIPLIST每个节点中的`encoding字段，都包含了字符串或整型的长度信息`，可以用该信息实现向后遍历。

### 2.5 在ZIPLIST数据结构下，查询节点个数的时间复杂度是多少？

分析：
- 由于ZIPLIST的header中定义了记录节点数量的字段zllen，所以通常是可以在O(1)时间复杂度直接返回，为什么说通常呢？因为zllen是2个字节的，当zllen大于65535时，zllen就存不下了，所以真实的节点数量需要遍历来得到。

回答：
- 在ZIPLIST编码下，查询节点个数的时间复杂度是O(1)，因为ZIPLIST的header中定义了记录节点数量的字段zllen，
- 但是这里也有个限制，`记录节点数量的字段只有2字节`，也就是说如果节点数量查过65535，就失效了，此时只能通过O(n)复杂度的遍历来查节点总数。

### 2.6 压缩列表插入的时间复杂度是多少？

分析：
- 通过操作考察对结构的理解

回答：
- 从头部插入，因为后面的内存都要移动，整体可以看做O(n)，尾部则是O(1)，平均而言是O(n)，
- 最坏是发生连锁更新O(n^2)

### 2.7 连锁更新是什么问题

分析：
- 考察ZIPLIST的不足之处

回答：
- ZIPLIST每个节点会有个字段prevlen记录上一个节点的长度，如果`上个节点小于254字节，这个记录字段则是1字节，否则是5字节`。
- 由于更新某个节点，会导致长度变化，如果从小于254变得大于254了，则会影响下个节点的长度，依次递推，就像多米诺骨牌一样，这种情况就是连锁更新。

### 2.8 如何解决连锁更新问题？

分析：
- LISTPACK思路

回答：
- 在5.0版本的LISTPACK可以替代ZIPLIST来解决连锁更新问题，核心思路就是`不去记录上一个节点的长度`，而是`记录自身长度`，使用LISTPACK的第三部分element-tot-len(backlen)来特殊化处理（记录encoding和data的长度），以遍历到前一个节点

### 2.9 LISTPACK是如何正向和反向遍历的（不考）？

- LISTPACK处理头部结构少了结尾偏移量，LISTPACK节点的结构与ZIPLIST相比也大不相同，LISTPACK单个节点可以分为三部分：`编码类型、实际内容，编码类型+实际内容的长度`

- 当我们进行`正向遍历`的时候，可以借助编码类型来进行遍历，LISTPACK拥有多种编码类型，但是每一种编码类型除了保存特定的编码标志外，还会保存实际内容的长度，而我们`可以通过编码类型的长度和实际内容的长度 相加起来 推断出 最后一部分的字节长度`

- 当我们进行反向遍历时，需要借助单个节点最后一部分，因为它记录了当前节点（编码类型长度+实际内容的长度），而且这一部分拥有两个特殊设计，
	- 第一个是它采用大端模式存储，也就是高字节放在低地址存储（方便我们进行从右向左遍历 或者 从高地址向低地址遍历）
	- 第二个是它的每一个字节都由两部分组成，每一个字节的最高位 和 其他的低7位，低7位就代表记录的长度信息，而当最高位是1时，代表我们还需要向左遍历，最高位是0时，代表遍历结束，我们已经完整地得到了 长度信息；