---
文章标题: "[[4_1047.删除字符串中的所有相邻重复项]]" 
文章作者: Dakkk
文章概要: |
  文章演示如何使用栈数据结构解决LeetCode 1047题，高效移除字符串相邻重复字符。文章还通过游戏类比栈的应用，并深入探讨递归与调用栈的关系，警示在企业项目中应慎用递归以防栈溢出。
tags:
- "栈"
- "数据结构"
- "字符串操作"
- "算法"
- "递归"
- "栈溢出"
- "LeetCode"
- "Java"
相关文章:
- "[[3_20.有效括号]]"
- "[[5_150.逆波兰表达式求值]]"
- "[[6_239.滑动窗口最大值]]"
- "[[7_347.前K个高频元素]]"
- "[[0_课程完整内容]]"
文章分类: "📐 计算机基础"
文章路径: "07-📐 计算机基础/02-🧮 算法设计/06-↩️ 栈与队列/4_1047.删除字符串中的所有相邻重复项.md"
文章难度: 中级 🌳
目前阶段: ✅ 已完成
重要性: ⭐⭐⭐⭐⭐ 精通必备
创建时间: 2025-04-24 23:51:21
修改时间: 2025-05-28 00:44:03
---

[1047. 删除字符串中的所有相邻重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/submissions/520501500/)
## 1 思路

本题和leetcode20题（有效括号）思路一致
- 遍历字符串s，将每个字符都存入栈中
- 依靠栈的特性，来去除重复的相邻元素

## 2 代码

```java
class Solution {
    public String removeDuplicates(String s) {
        //1.使用Deque模拟栈
        Deque<Character> deque = new ArrayDeque<>();
        //2. 将s的每个字符放入栈中
        char c;
        for(int i = 0;i<s.length();i++){
            c = s.charAt(i);
            //3.先判断栈是否存在该字符
            if(!deque.isEmpty()&&deque.peek()==c){
                deque.pop();
            }else{
                deque.push(c);
            }
        }
        //3.将deque剩余的元素，转化为字符串
        String str = "";
        while(!deque.isEmpty()){
            //注意，pop出来的元素的排列
            str = deque.pop() + str;
        }
        return str;
    }
}
```

## 3 额外TIP

这道题目就像是我们玩过的游戏对对碰，如果相同的元素挨在一起就要消除。

可能我们在玩游戏的时候感觉理所当然应该消除，但程序又怎么知道该如何消除呢，特别是消除之后又有新的元素可能挨在一起。

此时游戏的后端逻辑就可以用一个栈来实现（我没有实际考察对对碰或者爱消除游戏的代码实现，仅从原理上进行推断）。

游戏开发可能使用栈结构，编程语言的一些功能实现也会使用栈结构，实现函数递归调用就需要栈，但不是每种编程语言都支持递归，例如：

**递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中**，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。

相信大家应该遇到过一种错误就是栈溢出，系统输出的异常是`Segmentation fault`（当然不是所有的`Segmentation fault` 都是栈溢出导致的） ，如果你使用了递归，就要想一想是不是无限递归了，那么系统调用栈就会溢出。

而且**在企业项目开发中，尽量不要使用递归**！在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），**造成栈溢出错误（这种问题还不好排查！）**