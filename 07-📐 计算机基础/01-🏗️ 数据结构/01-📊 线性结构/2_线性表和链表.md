## 1 çº¿æ€§è¡¨çš„å®šä¹‰ä¸ç‰¹ç‚¹

å®šä¹‰ï¼šç”± nï¼ˆ n â©¾0 ï¼‰ä¸ªæ•°æ®ç‰¹æ€§ç›¸åŒçš„å…ƒç´ æ„æˆçš„æœ‰é™åºåˆ—ï¼Œç§°ä¸ºçº¿æ€§è¡¨ï¼Œçº¿æ€§è¡¨æ˜¯ n ä¸ªæ•°æ®å…ƒç´ çš„æœ‰é™åºåˆ—ï¼Œå…¶ä¸­ n ä¸ªæ•°æ®æ˜¯ç›¸åŒæ•°æ®ç±»å‹çš„

çº¿æ€§è¡¨ä¸­å…ƒç´ çš„ä¸ªæ•° nï¼ˆ ï¼‰å®šä¹‰ä¸ºçº¿æ€§è¡¨çš„é•¿åº¦ï¼Œå½“ n=0 æ—¶ç§°ä¹‹ä¸ºç©ºè¡¨ã€‚ å¯¹äºéç©ºçš„çº¿æ€§è¡¨æˆ–çº¿æ€§ç»“æ„ï¼Œå…¶ç‰¹ç‚¹æ˜¯ï¼š
- å­˜åœ¨å”¯ä¸€çš„ä¸€ä¸ªè¢«ç§°ä½œâ€œç¬¬ä¸€ä¸ªâ€çš„æ•°æ®å…ƒç´ ï¼› 
- å­˜åœ¨å”¯ä¸€çš„ä¸€ä¸ªè¢«ç§°ä½œâ€œæœ€åä¸€ä¸ªâ€çš„æ•°æ®å…ƒç´ ï¼› 
- é™¤ç¬¬ä¸€ä¸ªå…ƒç´ å¤–ï¼Œç»“æ„ä¸­çš„æ¯ä¸ªæ•°æ®å…ƒç´ å‡åªæœ‰ä¸€ä¸ªå‰é©±ï¼› 
- é™¤æœ€åä¸€ä¸ªå…ƒç´ å¤–ï¼Œç»“æ„ä¸­çš„æ¯ä¸ªæ•°æ®å…ƒç´ å‡åªæœ‰ä¸€ä¸ªåç»§ã€‚

## 2 å®å®šä¹‰

æ³¨æ„æ·»åŠ å®å®šä¹‰
```c
#define TRUE 1          // â€œçœŸâ€  
#define FALSE 0         // â€œå‡â€  
  
#define OK 1            // æ“ä½œæˆåŠŸæ ‡å¿—  
#define ERROR 0         // æ“ä½œå¤±è´¥æ ‡å¿—  
#define INFEASIBLE -1   // æ“ä½œæ— æ³•æ‰§è¡Œï¼ˆä¸å¯è¡Œï¼‰  
#define OVERFLOW -2     // æº¢å‡ºé”™è¯¯  
  
typedef int Status;      // å‡½æ•°è¿”å›çŠ¶æ€ç±»å‹ï¼Œä¸€èˆ¬ç”¨ä¸Šè¿°å®è¡¨ç¤ºçŠ¶æ€
```
## 3 é¡ºåºè¡¨

**é¡ºåºè¡¨çš„å®šä¹‰**ï¼šç”¨ä¸€ç»„`è¿ç»­çš„å†…å­˜å•å…ƒ`ä¾æ¬¡`å­˜å‚¨çº¿æ€§è¡¨çš„å„ä¸ªå…ƒç´ `ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œé€»è¾‘ä¸Šç›¸é‚» çš„å…ƒç´ ï¼Œå®é™…çš„ç‰©ç†å­˜å‚¨ç©ºé—´ä¹Ÿæ˜¯è¿ç»­çš„ã€‚
### 3.1 å­˜å‚¨ç»“æ„

```c
#define SQLMAXSIZE 100  
typedef int SqlElemType;  
  
typedef struct __Sqlist{  
    SqlElemType *base;  
    int length;  
}Sqlist;

```

### 3.2 é¡ºåºè¡¨çš„å¤´æ–‡ä»¶

```c
#ifndef INC_3_C_ALGORITHM_SEQUENCE_LIST_H  
#define INC_3_C_ALGORITHM_SEQUENCE_LIST_H  
  
#include "define.h"  
#include <stdio.h>  
#include <stdlib.h>  
  
#define SQLMAXSIZE 100  
  
typedef int SqlElemType;  
  
typedef struct __Sqlist {  
    SqlElemType *base;  
    int length;  
} Sqlist;  
  
// åˆå§‹åŒ–é¡ºåºè¡¨  
Status InitSqlist(Sqlist *L, int *arr, int length);  
  
// æ’å…¥å…ƒç´   
Status SqlInsert(Sqlist *L, int pos, SqlElemType e);  
  
// åˆ é™¤å¯¹åº”ç´¢å¼•çš„å…ƒç´ ,eä¸ºè¢«åˆ é™¤çš„å…ƒç´   
Status SqlDeleteByIndex(Sqlist *L,int pos,SqlElemType *e);  
  
// åˆ é™¤æŒ‡å®šå…ƒç´   
Status SqlDeleteByElem(Sqlist *L,SqlElemType e);  
  
// è·å–å…ƒç´   
Status GetElem(Sqlist *L, int pos, SqlElemType *e);  
  
// æŸ¥æ‰¾å…ƒç´ çš„ç´¢å¼•  
int LocateElem(Sqlist *L, SqlElemType e);  
  
// é”€æ¯é¡ºåºè¡¨  
Status SqlDestory(Sqlist *L);  
  
// æ¸…ç©ºé¡ºåºè¡¨  
void SqlClear(Sqlist *L);  
  
// åˆ¤æ–­é¡ºåºè¡¨æ˜¯å¦ä¸ºç©º  
Status SqlIsEmpty(Sqlist *L);  
  
// éå†é¡ºåºè¡¨  
void Traverse(Sqlist *L);  
  
// åˆå¹¶ä¸¤ä¸ªé¡ºåºè¡¨  
Sqlist *MergeList(Sqlist *La, Sqlist *Lb);  
  
// é¡ºåºè¡¨æ±‚å¹¶é›†  
Sqlist *MergeList_Seq(Sqlist *La, Sqlist *Lb, Sqlist *Lc);  
  
#endif //INC_3_C_ALGORITHM_SEQUENCE_LIST_H
```
### 3.3 åˆå§‹åŒ–

```c
Status InitSL(Sqlist *L, int length) {  
    //1. å†…éƒ¨æ•°ç»„åˆ†é…å†…å­˜  
    L->base = (SqlElemType *) malloc(sizeof(SqlElemType) * SQLMAXSIZE);  
    //2. åˆ¤æ–­å†…å­˜åˆ†é…æ˜¯å¦æˆåŠŸ  
    if (!L->base) {  
        return OVERFLOW;  
    }  
    //3. åˆå§‹åŒ–é•¿åº¦ä¸º0  
    L->length = 0;  
    //4. å¡«å……å†…éƒ¨æ•°ç»„  
    for (int i = 1; i < length + 1; i++) {  
        SqlElemType e = 0;  
        scanf_s("%d", &e);  
        SqlInsert(L, i, e);  
    }  
    //5. æ“ä½œæˆåŠŸ  
    return OK;  
}
```
### 3.4 æ’å…¥

å°¾æ’æ³•ï¼ˆä»åå¾€å‰ï¼‰ï¼Œæ³¨æ„è„šæ ‡è¶Šç•Œ

```c
Status SqlInsert(Sqlist *L, int pos, SqlElemType e) {  
    // åˆ¤æ–­è¾¹ç•Œæ¡ä»¶  
    if (pos < 0 || pos > L->length) {  
        return ERROR;  
    }  
    if (L->length > SQLMAXSIZE) {  
        return OVERFLOW;  
    }  
    // å½“å‰é¡ºåºè¡¨çš„æœ‰æ•ˆé•¿åº¦  
    int len = L->length;  
    // ä»åå¾€å‰è¿›è¡Œæ’å…¥  
    for (int i = len - 1; i >= pos; i--) {  
        L->base[i + 1] = L->base[i];  
    }  
    L->base[pos] = e;  
    L->length++;  
    return OK;  
}
```

æ”¹è¿›ç‚¹ï¼š
- é¡ºåºè¡¨ä¸­çš„æ•°ç»„ä½¿ç”¨SQLMAXSIZEï¼Œå›ºå®šäº†å¤§å°ï¼ŒåæœŸæ·»åŠ é˜ˆå€¼ï¼Œä½¿ç”¨reallocå‡½æ•°è¿›è¡ŒåŠ¨æ€æ‰©å®¹
- å¯¹äºå°¾æ’å¯ä»¥ç›´æ¥ä¼˜åŒ–ï¼Œæ£€æŸ¥æ—¶é—´æ¶ˆè€—
### 3.5 åˆ é™¤

**é€šè¿‡ç´¢å¼•ä½ç½®åˆ é™¤**
```c
Status SqlDeleteByIndex(Sqlist *L, int pos, SqlElemType *e) {  
    if (pos < 0 || pos >= L->length) {  
        return ERROR;  
    }  
    *e = *(L->base + pos);  
    int len = L->length;  
    for (int i = pos + 1; i < len; i++) {  
        // iä»pos+1å¼€å§‹ï¼Œé˜²æ­¢è¶Šç•Œ  
        // L->base[i + 1] = L->base[i];  
        L->base[i - 1] = L->base[i];  
    }  
    L->length--;  
    return OK;  
}
```

**é€šè¿‡å…ƒç´ åˆ é™¤**
```c
Status SqlDeleteByElem(Sqlist *L,SqlElemType e){  
    int index = LocateElem(L,e);  
    SqlElemType res;  
    return SqlDeleteByIndex(L,index,&res);  
}
```
### 3.6 è·å–å…ƒç´ 

```c
Status GetElem(Sqlist *L, int pos, SqlElemType *e) {  
    if (pos < 0 || pos >= L->length) {  
        return ERROR;  
    }  
    // é”™è¯¯ï¼Œeæ˜¯ä¸´æ—¶æŒ‡é’ˆï¼Œå‡½æ•°è°ƒç”¨ç»“æŸï¼ŒæŒ‡é’ˆå°±ä¼šå¤±æ•ˆ  
    //e = L->base + pos;  
    // èµ‹å€¼ï¼Œéœ€è¦è§£å¼•ç”¨  
    *e = *(L->base + pos);  
    return OK;  
}
```
### 3.7 æŸ¥æ‰¾å…ƒç´ ğŸ“•

```c
int LocateElem(Sqlist *L, SqlElemType e) {  
    int *p = L->base;  
    int len = L->length;  
    for (int i = 0; i < len; i++) {  
        if (e == *(p++)) {  
            return i;  
        }  
    }  
    return ERROR;  
}
```
### 3.8 é”€æ¯ã€æ¸…ç©ºã€éå†å’Œæ£€æŸ¥ä¸ºç©º

```c
Status SqlDestory(Sqlist *L) {  
    if (!L->base) {  
        return ERROR;  
    } else {  
        free(L->base);  
        return OK;  
    }  
}  
  
void SqlClear(Sqlist *L) {  
    L->length = 0;  
}  
  
Status SqlIsEmpty(Sqlist *L) {  
    return L->length == 0 ? OK : ERROR;  
}  
  
void Traverse(Sqlist *L) {  
    if (!L) {  
        printf("ç©ºè¡¨\n");  
    }  
    for (int i = 0; i < L->length; i++) {  
        printf("%d ", L->base[i]);  
    }  
    printf("\n");  
}
```
## 4 å•é“¾è¡¨ï¼ˆSingle Linked Listï¼‰

### 4.1 å­˜å‚¨ç»“æ„

- å•é“¾è¡¨ç”±å¤´èŠ‚ç‚¹(ä¸å­˜æ”¾æ•°æ®åªå­˜æ”¾ä¸‹ä¸ªèŠ‚ç‚¹çš„åœ°å€)å’Œnä¸ªèŠ‚ç‚¹ç»„æˆ
- æ¯ä¸ªèŠ‚ç‚¹åˆ†ä¸ºä¸¤ä¸ªåŸŸï¼šæ•°æ®åŸŸå’ŒæŒ‡é’ˆåŸŸ(å­˜æ”¾ä¸‹ä¸ªèŠ‚ç‚¹çš„åœ°å€)
- ç¬¬nä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆåŸŸä¸ºNULL

å¦‚ä¸‹å›¾æ‰€ç¤º
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/2615d51d44f01765905ed80e905ed391.png)

### 4.2 å­˜å‚¨ç»“æ„

```c
typedef int LlElemtype
typedef struct __LNode{
	LlElemtype data;   //å­˜æ”¾å•ä¸ªèŠ‚ç‚¹çš„æ•°æ®
	struct __LNode *next;     //å­˜æ”¾ä¸‹ä¸ªèŠ‚ç‚¹çš„åœ°å€
}LNode,*LinkedList;
```
### 4.3 åˆå§‹åŒ–å’Œéå†

```c
// å•é“¾è¡¨åˆå§‹åŒ–  
Status InitLl(Linkedlist *L) {     //Læ˜¯ä¸€ä¸ªäºŒçº§æŒ‡é’ˆ  
    (*L) = (Linkedlist) malloc(sizeof(LNode));  
    (*L)->next = NULL;  
    return OK;  
}

// å•é“¾è¡¨ä»å‰åˆ°åéå†  
void Traverse(Linkedlist L){  
    if(!L->next){  
        printf("é“¾è¡¨ä¸­ä¸å­˜åœ¨å…ƒç´ ");  
        return;  
    }  
    Linkedlist p = L->next;  
    while(p){  
        printf("%d ",p->data);  
        p = p->next;  
    }  
}
```
### 4.4 åˆ›å»ºé“¾è¡¨ï¼ˆå¤´æ’æ³•ï¼‰$O(n)$

```c
// åˆ›å»ºé“¾è¡¨ï¼ˆå¤´æ’æ³•ï¼‰  
// æ³¨æ„ï¼šé€†åºå­˜å‚¨ï¼Œéå†éœ€è¦åè¿‡æ¥  
// ä¾‹å¦‚ï¼šè¾“å¦‚ 1 2 3 ï¼Œé“¾è¡¨ï¼šå¤´èŠ‚ç‚¹ -> 3 -> 2 -> 1 -> NULL// ä¸€èˆ¬æˆ‘ä»¬å¿½ç•¥å¤´ç»“ç‚¹æ˜¯å•¥ï¼Œå½“åšä¸€ä¸ªèµ·å§‹ä½ç½®å³å¯  
void CreateLL_H(Linkedlist L, int n) {  
    printf("è¯·è¾“å…¥ %d ä¸ªæ•´æ•°ï¼Œä½œä¸ºé“¾è¡¨çš„å…ƒç´ ï¼š", n);  
    fflush(stdout);  
    for (int i = 0; i < n; i++) {  
        Linkedlist p = (Linkedlist) malloc(sizeof(LNode));  
        int data;  
        scanf_s(" %d", &data);  
        p->data = data;  
        p->next = L->next;  
        L->next = p;  
    }  
}
```

### 4.5 åˆ›å»ºé“¾è¡¨ï¼ˆå°¾æ’æ³•ï¼‰$O(n)$

```c
// åˆ›å»ºé“¾è¡¨ï¼ˆå°¾æ’æ³•ï¼‰  
void CreateLL_R(Linkedlist L, int n) {  
    printf("è¯·è¾“å…¥ %d ä¸ªæ•´æ•°ï¼Œä½œä¸ºé“¾è¡¨çš„å…ƒç´ ï¼š", n);  
    fflush(stdout);  
    // å¤´ç»“ç‚¹ä¿æŒä¸åŠ¨ï¼Œä½¿ç”¨ç§»åŠ¨èŠ‚ç‚¹  
    Linkedlist pm = L;  
    for (int i = 0; i < n; i++) {  
        Linkedlist p = (Linkedlist) malloc(sizeof(LNode));  
        int data;  
        scanf_s(" %d", &data);  
        // æ–°èŠ‚ç‚¹èµ‹å€¼  
        p->data = data;  
        // æ–°èŠ‚ç‚¹å°¾éƒ¨å¿…ç„¶æ˜¯NULL  
        p->next = NULL;  
        // æ–°èŠ‚ç‚¹æ’å…¥åˆ°å‰ä¸€ä¸ªèŠ‚ç‚¹å  
        pm -> next = p;  
        // æŒ‡é’ˆç§»åŠ¨åˆ°æ–°èŠ‚ç‚¹çš„å‰ä¸€ä¸ªèŠ‚ç‚¹  
        pm = pm -> next;  
    }  
}
```
### 4.6 è·å–å…ƒç´ $O(n)$

```c
// è·å–æŒ‡å®šä½ç½®çš„å…ƒç´   
// æ³¨æ„å¤´ç»“ç‚¹çš„ä½ç½®ä¸º0  
Status GetElem(Linkedlist L, int pos, LlElemtype *e) {  
    Linkedlist pl = L;  
    for (int i = 1; i <= pos; i++) {  
        pl = pl->next;  
    }  
    *e = pl->data;  
    return OK;  
}
```
### 4.7 æŸ¥æ‰¾å…ƒç´ $O(n)$

```c
//æŸ¥æ‰¾å…ƒç´ ï¼Œè¿”å›å…ƒç´ å¯¹åº”çš„èŠ‚ç‚¹  
Linkedlist LocateElem(Linkedlist L, LlElemtype e) {  
    Linkedlist pl = L->next;  
    while (pl) {  
        if (pl->data == e) {  
            return pl;  
        }  
        pl = pl->next;  
    }  
    return NULL;  
}
```
### 4.8 æ’å…¥å…ƒç´ $O(n)$ğŸ“•

```c
//æ’å…¥å…ƒç´   
Status Insert(Linkedlist L, int pos, LlElemtype e) {  
    if(pos<1){  
        return ERROR;  
    }  
    //ç¡®å®šæ’å…¥çš„ä½ç½®ï¼Œå³poså‰1ä½  
    Linkedlist p = L;  
    // æ³¨æ„pä»0å¼€å§‹ï¼Œå³Lå¼€å§‹ï¼Œæ‰€ä»¥æœ€åçš„ä½ç½®æ˜¯posçš„å‰1ä¸ªèŠ‚ç‚¹  
    for (int i = 0; i < pos - 1; i++) {  
        p = p->next;  
        if(!p){  
            printf("posè¶…è¿‡é“¾è¡¨é•¿åº¦\n");  
            return ERROR;  
        }  
    }  
    // åˆ¤æ–­è·å¾—çš„èŠ‚ç‚¹æ˜¯å¦åˆæ³•  
    //åˆ›å»ºæ–°èŠ‚ç‚¹  
    Linkedlist pnew = (Linkedlist) malloc(sizeof(LNode));  
    pnew->data = e;  
    // æ­¤æ—¶pä¸ºposçš„å‰1ä¸ªèŠ‚ç‚¹ï¼Œå¼€å§‹æ›¿æ¢  
    pnew->next = p->next;  
    p->next = pnew;  
    return OK;  
}
```
### 4.9 åˆ é™¤å…ƒç´ $O(n)$ğŸ“•

```c
//åˆ é™¤å…ƒç´   
Status Delete(Linkedlist L, int pos, LlElemtype *e) {  
    if(pos<1){  
        return ERROR;  
    }  
    //ç¡®å®šæ’å…¥çš„ä½ç½®ï¼Œå³poså‰1ä½  
    Linkedlist p = L;  
    // æ³¨æ„pæœ€åçš„ä½ç½®ï¼Œposçš„å‰1ä¸ªèŠ‚ç‚¹  
    for (int i = 0; i < pos - 1; i++) {  
        p = p->next;  
        if(!p){  
            printf("posè¶…è¿‡é“¾è¡¨é•¿åº¦\n");  
            return ERROR;  
        }  
    }  
    //è·å–åˆ é™¤çš„å…ƒç´   
    Linkedlist dp = p->next;  
    *e = dp->data;  
    // åˆ é™¤å…ƒç´   
    p->next = p->next->next;  
    free(dp);  
    return OK;  
}
```
### 4.10 é”€æ¯é“¾è¡¨

```c
//é”€æ¯é“¾è¡¨ï¼Œé‡Šæ”¾æ‰€æœ‰mallocçš„æŒ‡é’ˆå˜é‡  
Status Destory(Linkedlist *L){  
    if(!(*L)){  
        return ERROR;  
    }  
    Linkedlist p = *L;  
    while(p){  
        Linkedlist pfree = p;  
        p = p->next;  
        free(pfree);  
        pfree = NULL;  
    }  
    *L = NULL;  
    return OK;  
}
```
### 4.11 å•é“¾è¡¨å¤´æ–‡ä»¶

```c
#ifndef INC_3_C_ALGORITHM_LINKEDLIST_H  
#define INC_3_C_ALGORITHM_LINKEDLIST_H  
  
#include <stdio.h>  
#include <stdlib.h>  
#include "define.h"  
  
typedef int LlElemtype;  
  
typedef struct __LNode{  
    LlElemtype data;  
    struct __LNode *next;  
}LNode,*Linkedlist;  
  
// å•é“¾è¡¨åˆå§‹åŒ–  
Status InitLl(Linkedlist *L);  
  
// å•é“¾è¡¨ä»å‰åˆ°åéå†  
void Traverse(Linkedlist L);  
  
// åˆ›å»ºé“¾è¡¨ï¼ˆå¤´æ’æ³•ï¼‰  
void CreateLL_H(Linkedlist L, int n);  
  
// åˆ›å»ºé“¾è¡¨ï¼ˆå°¾æ’æ³•ï¼‰  
void CreateLL_R(Linkedlist L, int n);  
  
// è·å–æŒ‡å®šä½ç½®çš„å…ƒç´   
// æ³¨æ„å¤´ç»“ç‚¹çš„ä½ç½®ä¸º0  
Status GetElem(Linkedlist L, int pos, LlElemtype *e);  
  
//æŸ¥æ‰¾å…ƒç´ ï¼Œè¿”å›å…ƒç´ å¯¹åº”çš„èŠ‚ç‚¹  
Linkedlist LocateElem(Linkedlist L, LlElemtype e);  
  
//æ’å…¥å…ƒç´   
Status Insert(Linkedlist L, int pos, LlElemtype e);  
  
//åˆ é™¤å…ƒç´   
Status Delete(Linkedlist L, int pos, LlElemtype *e);  
  
//é”€æ¯é“¾è¡¨ï¼Œé‡Šæ”¾æ‰€æœ‰mallocçš„æŒ‡é’ˆå˜é‡  
Status Destory(Linkedlist *L);  
#endif //INC_3_C_ALGORITHM_LINKEDLIST_H
```
## 5 å¾ªç¯é“¾è¡¨

ç‰¹ç‚¹
- æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆåŸŸï¼ŒæŒ‡å‘å¤´ç»“ç‚¹ï¼Œæ•´ä¸ªè¡¨å½¢æˆä¸€ä¸ªç¯
- ç”±æ­¤ï¼Œä»è¡¨ä¸­ä»»æ„èŠ‚ç‚¹å‡ºå‘ï¼Œå¯ä»¥æ‰¾åˆ°å…¶ä»–èŠ‚ç‚¹

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/3a0871d55327f766097c1daae817db46.png)

å’Œå•é“¾è¡¨å¾ˆåƒï¼ŒåŒºåˆ«å°±æ˜¯æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„nextåŸŸæŒ‡å‘å¤´èŠ‚ç‚¹
## 6 åŒå‘é“¾è¡¨

æœ‰ä¸¤ä¸ªæŒ‡é’ˆåŸŸï¼Œä¸€ä¸ªæŒ‡å‘ç›´æ¥å‰é©±ï¼Œå¦ä¸€ä¸ªæŒ‡å‘ç›´æ¥åç»§

### 6.1 æ•°æ®ç±»å‹

```c
// æ•°æ®ç±»å‹  
typedef int DouLElemtype;  
  
typedef struct __DouLinkNode {  
    DouLElemtype data;  
    struct __DouLinkNode *prev;  
    struct __DouLinkNode *next;  
} DouLinkNode, *DouLinkList;
```
### 6.2 åˆå§‹åŒ–

```c
// åˆå§‹åŒ–  
void InitDl(DouLinkList *D) {  
    (*D) = (DouLinkList) malloc(sizeof(DouLinkNode));  
    (*D)->prev = NULL;  
    (*D)->next = NULL;  
}  
  
// éå†é“¾è¡¨  
void Traverse(DouLinkList D) {  
    DouLinkList p = D->next;  
    while (p) {  
        printf(" %d", p->data);  
        p = p->next;  
    }  
    printf("\n");  
}
```
### 6.3 åˆ›å»º

```c
// åˆ›å»ºé“¾è¡¨ï¼ˆå¤´æ’æ³•ï¼‰  
void CreateDl_H(DouLinkList D, int n) {  
    if (n < 1) {  
        printf("è‡³å°‘è¾“å…¥ä¸€ä¸ªå…ƒç´ ï¼");  
        return;  
    }  
    printf("è¯·è¾“å…¥%dä¸ªæ’å…¥çš„å…ƒç´ ï¼š", n);  
    fflush(stdout);  
    while (n) {  
        DouLinkList pnew = (DouLinkList) malloc(sizeof(DouLinkNode));  
        int data;  
        scanf_s(" %d", &data);  
        pnew->data = data;  
        pnew->next = D->next;  
        pnew->prev = D;  
        // D->next å¯èƒ½ä¸ºNULLï¼Œè¿™é‡Œå®¹æ˜“çŠ¯é”™  
        //D->next->prev = pnew;  
        D->next = pnew;  
        n--;  
    }  
}  
  
// åˆ›å»ºé“¾è¡¨ï¼ˆå°¾æ’æ³•ï¼‰  
void CreateDl_R(DouLinkList D, int n) {  
    if (n < 1) {  
        printf("è‡³å°‘è¾“å…¥ä¸€ä¸ªå…ƒç´ ï¼");  
        return;  
    }  
    printf("è¯·è¾“å…¥%dä¸ªæ’å…¥çš„å…ƒç´ ï¼š", n);  
    fflush(stdout);  
    DouLinkList p = D;  
    while (n) {  
        DouLinkList pnew = (DouLinkList) malloc(sizeof(DouLinkNode));  
        int data;  
        scanf_s(" %d", &data);  
        pnew->data = data;  
        //å…³é”®æ˜¯è¿™é‡Œ  
        pnew->next = NULL;  
        pnew->prev = p;  
        p->next = pnew;  
        p = pnew;  
        n--;  
    }  
}
```
### 6.4 æ’å…¥å’Œåˆ é™¤

```c
// æ’å…¥ï¼ˆä»å‰å¾€åï¼‰  
void Insert(DouLinkList D, int pos, DouLElemtype e) {  
    if (pos < 1) {  
        printf("è¾“å…¥ä½ç½®æœ‰è¯¯\n");  
        return;  
    }  
    // æ‰¾åˆ°poså‰ä¸€ä¸ªå…ƒç´   
    DouLinkList p = D;  
    for (int i = 0; i < pos - 1; i++) {  
        p = p->next;  
    }  
    // äº¤æ¢è¿æ¥å…³ç³»ï¼ˆå»ºè®®ç”»å›¾ï¼‰  
    DouLinkList pnew = (DouLinkList) malloc(sizeof(DouLinkNode));  
    pnew->data = e;  
    // å‰ä¸€ä¸ªå…ƒç´ è¦æ¢nextï¼Œåä¸€ä¸ªå…ƒç´ è¦æ¢prev  
    // æ–°å¢çš„å…ƒç´ è¦æ¢nextå’Œprev  
    // å…ˆæ¢åä¸€ä¸ªå…ƒç´ çš„  
    pnew->next = p->next;  
    p->next->prev = pnew;  
    // åœ¨æ¢å‰ä¸€ä¸ªå…ƒç´ çš„  
    p->next = pnew;  
    pnew->prev = p;  
}  
  
//åˆ é™¤  
void Delete(DouLinkList D, int pos, DouLElemtype *e){  
    if (pos < 1) {  
        printf("è¾“å…¥ä½ç½®æœ‰è¯¯\n");  
        return;  
    }  
    // æ‰¾åˆ°poså‰ä¸€ä¸ªå…ƒç´   
    DouLinkList p = D;  
    for (int i = 0; i < pos - 1; i++) {  
        p = p->next;  
    }  
    // å…ˆè·å–è¦åˆ é™¤çš„èŠ‚ç‚¹  
    DouLinkList pfree = p->next;  
    *e = pfree->data;  
    // äº¤æ¢è¿æ¥å…³ç³»  
    p->next = pfree->next;  
    pfree->next->prev = p;  
    free(pfree);  
    pfree = NULL;  
}
```
## 7 åº”ç”¨

### 7.1 çº¿æ€§è¡¨åˆå¹¶

å·²çŸ¥ä¸¤ä¸ªé›†åˆå¦‚ä¸‹å›¾
![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/b6faf65a84dc0f5ae598509813bba161.png)

```c
void MergeList(Sqlist *La, Sqlist *Lb) {  
    //å°†bè¡¨ä¸­ä¸å­˜åœ¨äºaè¡¨çš„å…ƒç´ æ·»åŠ åˆ°aè¡¨  
    for (int i = 0; i < Lb->length; i++) {  
        SqlElemType e;  
        GetElem(Lb, i, &e);  
        int index = LocateElem(La, e);  
        if (index < 0 || index >= La->length) {  
            SqlInsert(La,La->length,e);  
        }  
    }  
}
```
### 7.2 æœ‰åºè¡¨åˆå¹¶ï¼ˆå¹¶å½’æ’åºçš„åŸºç¡€ï¼‰

![image.png|500](https://my-obsidian-image.oss-cn-guangzhou.aliyuncs.com/2025/05/ae1c457e2f2e8cadd14b380b071ea109.png)

```c
void MergeList_Seq(Sqlist *La, Sqlist *Lb, Sqlist *Lc) {  
    //1. å®šä¹‰å˜é‡  
    // è·å–é•¿åº¦  
    Lc->length = La->length + Lb->length;  
    // è·å–aå’Œbçš„é¦–ä½èŠ‚ç‚¹  
    SqlElemType *pa = La->base, *pa_last = La->base + (La->length - 1);  
    SqlElemType *pb = Lb->base, *pb_last = Lb->base + (Lb->length - 1);  
    // è·å–cçš„é¦–èŠ‚ç‚¹  
    SqlElemType *pc = Lc->base;  
  
    //2.å…ˆæ¯”è¾ƒaå’Œbï¼Œå°†å†…å®¹æ”¾å…¥cä¸­  
    while (pa <= pa_last && pb <= pb_last) {  
        if (*pa < *pb) {  
            *(pc++) = *(pa++);  
        } else {  
            *(pc++) = *(pb++);  
        }  
    }  
  
    // 3. å‰©ä¸‹å¤šä½™çš„ç»§ç»­å¡«å……  
    while (pa <= pa_last) {  
        *(pc++) = *(pa++);  
    }  
  
    while (pb <= pb_last) {  
        *(pc++) = *(pb++);  
    }  
}
```
### 7.3 æœ‰åºé“¾è¡¨åˆå¹¶

```c
void Merge_LinkedList(Linkedlist *La, Linkedlist *Lb, Linkedlist *Lc) {  
    //1ã€‚å®šä¹‰å˜é‡  
    // å…ˆè®©LcæŒ‡å‘La  
    *Lc = *La;  
    // è·å–aå’Œbçš„å…ƒç´ é¦–èŠ‚ç‚¹  
    Linkedlist pa = (*La)->next;  
    Linkedlist pb = (*Lb)->next;  
    // è·å–cçš„å…ƒç´ é¦–èŠ‚ç‚¹  
    Linkedlist pc = *Lc;  
  
    //2.æœ‰åºé“¾æ¥aå’Œbçš„å…ƒç´   
    while (pa && pb) {  
        if (pa->data < pb->data) {  
            pc->next = pa;  
            //ç§»åŠ¨pcæŒ‡é’ˆ  
            pc = pa;  
            //ç§»åŠ¨paæŒ‡é’ˆ  
            pa = pa->next;  
        } else {  
            pc->next = pb;  
            pc = pb;  
            pb = pb->next;  
        }  
    }  
  
    //3.è¿˜æœ‰å¤šçš„å…ƒç´   
    pc->next = pa ? pa : pb;  
    free(*Lb);  
    *La = * Lb = NULL;  
}
```

